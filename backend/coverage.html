
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mesbahtanvir/focus-notebook/backend/cmd/server/main.go (1.8%)</option>
				
				<option value="file1">github.com/mesbahtanvir/focus-notebook/backend/internal/clients/alphavantage.go (2.6%)</option>
				
				<option value="file2">github.com/mesbahtanvir/focus-notebook/backend/internal/clients/anthropic.go (13.2%)</option>
				
				<option value="file3">github.com/mesbahtanvir/focus-notebook/backend/internal/clients/openai.go (27.8%)</option>
				
				<option value="file4">github.com/mesbahtanvir/focus-notebook/backend/internal/clients/plaid.go (14.3%)</option>
				
				<option value="file5">github.com/mesbahtanvir/focus-notebook/backend/internal/clients/ratelimiter.go (97.3%)</option>
				
				<option value="file6">github.com/mesbahtanvir/focus-notebook/backend/internal/clients/stripe.go (5.7%)</option>
				
				<option value="file7">github.com/mesbahtanvir/focus-notebook/backend/internal/config/config.go (85.7%)</option>
				
				<option value="file8">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/analytics.go (79.1%)</option>
				
				<option value="file9">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/chat.go (4.0%)</option>
				
				<option value="file10">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/entity_graph.go (69.3%)</option>
				
				<option value="file11">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/health.go (6.2%)</option>
				
				<option value="file12">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/import_export.go (23.2%)</option>
				
				<option value="file13">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/investment.go (1.6%)</option>
				
				<option value="file14">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/packing_list.go (1.4%)</option>
				
				<option value="file15">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/photo.go (1.5%)</option>
				
				<option value="file16">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/places_visa.go (4.8%)</option>
				
				<option value="file17">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/plaid.go (1.0%)</option>
				
				<option value="file18">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/spending.go (1.2%)</option>
				
				<option value="file19">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/stock.go (1.6%)</option>
				
				<option value="file20">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/stripe.go (1.4%)</option>
				
				<option value="file21">github.com/mesbahtanvir/focus-notebook/backend/internal/handlers/thought.go (1.8%)</option>
				
				<option value="file22">github.com/mesbahtanvir/focus-notebook/backend/internal/middleware/auth.go (26.5%)</option>
				
				<option value="file23">github.com/mesbahtanvir/focus-notebook/backend/internal/middleware/cors.go (100.0%)</option>
				
				<option value="file24">github.com/mesbahtanvir/focus-notebook/backend/internal/middleware/logging.go (95.0%)</option>
				
				<option value="file25">github.com/mesbahtanvir/focus-notebook/backend/internal/middleware/recovery.go (100.0%)</option>
				
				<option value="file26">github.com/mesbahtanvir/focus-notebook/backend/internal/repository/firestore.go (12.4%)</option>
				
				<option value="file27">github.com/mesbahtanvir/focus-notebook/backend/internal/repository/mocks/mock_repository.go (94.6%)</option>
				
				<option value="file28">github.com/mesbahtanvir/focus-notebook/backend/internal/services/action_processor.go (11.5%)</option>
				
				<option value="file29">github.com/mesbahtanvir/focus-notebook/backend/internal/services/chat.go (54.3%)</option>
				
				<option value="file30">github.com/mesbahtanvir/focus-notebook/backend/internal/services/context_gatherer.go (0.0%)</option>
				
				<option value="file31">github.com/mesbahtanvir/focus-notebook/backend/internal/services/csv_processing.go (0.0%)</option>
				
				<option value="file32">github.com/mesbahtanvir/focus-notebook/backend/internal/services/dashboard_analytics.go (67.0%)</option>
				
				<option value="file33">github.com/mesbahtanvir/focus-notebook/backend/internal/services/entity_graph.go (68.2%)</option>
				
				<option value="file34">github.com/mesbahtanvir/focus-notebook/backend/internal/services/import_export.go (0.3%)</option>
				
				<option value="file35">github.com/mesbahtanvir/focus-notebook/backend/internal/services/investment_calculations.go (76.4%)</option>
				
				<option value="file36">github.com/mesbahtanvir/focus-notebook/backend/internal/services/investment_prediction.go (0.0%)</option>
				
				<option value="file37">github.com/mesbahtanvir/focus-notebook/backend/internal/services/packing_list.go (0.0%)</option>
				
				<option value="file38">github.com/mesbahtanvir/focus-notebook/backend/internal/services/photo.go (0.4%)</option>
				
				<option value="file39">github.com/mesbahtanvir/focus-notebook/backend/internal/services/places_visa.go (9.1%)</option>
				
				<option value="file40">github.com/mesbahtanvir/focus-notebook/backend/internal/services/plaid.go (0.5%)</option>
				
				<option value="file41">github.com/mesbahtanvir/focus-notebook/backend/internal/services/spending_analytics.go (0.6%)</option>
				
				<option value="file42">github.com/mesbahtanvir/focus-notebook/backend/internal/services/stock.go (23.1%)</option>
				
				<option value="file43">github.com/mesbahtanvir/focus-notebook/backend/internal/services/stripe_billing.go (0.0%)</option>
				
				<option value="file44">github.com/mesbahtanvir/focus-notebook/backend/internal/services/subscription.go (3.6%)</option>
				
				<option value="file45">github.com/mesbahtanvir/focus-notebook/backend/internal/services/thought_processing.go (0.0%)</option>
				
				<option value="file46">github.com/mesbahtanvir/focus-notebook/backend/internal/services/transaction_categorization.go (0.0%)</option>
				
				<option value="file47">github.com/mesbahtanvir/focus-notebook/backend/internal/utils/csv.go (98.0%)</option>
				
				<option value="file48">github.com/mesbahtanvir/focus-notebook/backend/internal/utils/logger.go (100.0%)</option>
				
				<option value="file49">github.com/mesbahtanvir/focus-notebook/backend/internal/utils/response.go (91.7%)</option>
				
				<option value="file50">github.com/mesbahtanvir/focus-notebook/backend/pkg/firebase/admin.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "cloud.google.com/go/storage"
        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.uber.org/zap"
        "google.golang.org/api/option"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/config"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/handlers"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/middleware"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
        "github.com/mesbahtanvir/focus-notebook/backend/pkg/firebase"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load("config/config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // Initialize logger
        <span class="cov0" title="0">logger, err := utils.NewLogger(&amp;cfg.Logging)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = logger.Sync()
        }</span>()

        <span class="cov0" title="0">logger.Info("Starting Focus Notebook Backend",
                zap.String("version", "1.0.0"),
                zap.String("port", fmt.Sprintf("%d", cfg.Server.Port)),
        )

        // Initialize Firebase
        ctx := context.Background()
        fbAdmin, err := firebase.Initialize(ctx, &amp;firebase.Config{
                ProjectID:       cfg.Firebase.ProjectID,
                CredentialsPath: cfg.Firebase.CredentialsPath,
                StorageBucket:   cfg.Firebase.StorageBucket,
                DatabaseID:      cfg.Firebase.DatabaseID,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize Firebase", zap.Error(err))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := fbAdmin.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to close Firebase", zap.Error(closeErr))
                }</span>
        }()

        <span class="cov0" title="0">logger.Info("Firebase initialized successfully")

        // Initialize Cloud Storage client (for CSV processing)
        storageClient, err := storage.NewClient(ctx, option.WithCredentialsFile(cfg.Firebase.CredentialsPath))
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to initialize Cloud Storage client", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Cloud Storage client initialized")
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if storageClient != nil </span><span class="cov0" title="0">{
                        if closeErr := storageClient.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to close Cloud Storage client", zap.Error(closeErr))
                        }</span>
                }
        }()

        // Initialize AI clients
        <span class="cov0" title="0">var openaiClient *clients.OpenAIClient
        if cfg.OpenAI.APIKey != "" </span><span class="cov0" title="0">{
                openaiClient, err = clients.NewOpenAIClient(&amp;cfg.OpenAI, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to initialize OpenAI client", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("OpenAI client initialized")
                }</span>
        }

        <span class="cov0" title="0">var anthropicClient *clients.AnthropicClient
        if cfg.Anthropic.APIKey != "" </span><span class="cov0" title="0">{
                anthropicClient, err = clients.NewAnthropicClient(&amp;cfg.Anthropic, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to initialize Anthropic client", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("Anthropic client initialized")
                }</span>
        }

        // Check if at least one AI client is available
        <span class="cov0" title="0">if openaiClient == nil &amp;&amp; anthropicClient == nil </span><span class="cov0" title="0">{
                logger.Warn("No AI clients configured - thought processing will not work")
        }</span>

        // Initialize transaction categorization service
        <span class="cov0" title="0">var categorizationSvc *services.TransactionCategorizationService
        if openaiClient != nil </span><span class="cov0" title="0">{
                categorizationSvc = services.NewTransactionCategorizationService(openaiClient, logger)
                logger.Info("Transaction categorization service initialized")
        }</span>

        // Initialize chat service
        <span class="cov0" title="0">var chatService *services.ChatService
        if openaiClient != nil || anthropicClient != nil </span><span class="cov0" title="0">{
                chatService = services.NewChatService(openaiClient, anthropicClient, logger)
                logger.Info("Chat service initialized")
        }</span>

        // Initialize Stripe client
        <span class="cov0" title="0">var stripeClient *clients.StripeClient
        if cfg.Stripe.SecretKey != "" </span><span class="cov0" title="0">{
                var err error
                stripeClient, err = clients.NewStripeClient(&amp;cfg.Stripe, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to initialize Stripe client", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("Stripe client initialized")
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Warn("Stripe not configured - billing features will not work")
        }</span>

        // Initialize Plaid client
        <span class="cov0" title="0">var plaidClient *clients.PlaidClient
        if cfg.Plaid.ClientID != "" &amp;&amp; cfg.Plaid.Secret != "" </span><span class="cov0" title="0">{
                var err error
                plaidClient, err = clients.NewPlaidClient(&amp;cfg.Plaid, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to initialize Plaid client", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("Plaid client initialized")
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Warn("Plaid not configured - banking features will not work")
        }</span>

        // Initialize Alpha Vantage client
        <span class="cov0" title="0">var alphaVantageClient *clients.AlphaVantageClient
        if cfg.AlphaVantage.APIKey != "" </span><span class="cov0" title="0">{
                alphaVantageClient = clients.NewAlphaVantageClient(&amp;cfg.AlphaVantage, logger)
                logger.Info("Alpha Vantage client initialized")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Alpha Vantage not configured - stock price features will not work")
        }</span>

        // Initialize repository
        <span class="cov0" title="0">repo := repository.NewFirestoreRepository(fbAdmin.Firestore)

        // Initialize services
        contextGatherer := services.NewContextGathererService(repo, logger)
        subscriptionSvc := services.NewSubscriptionService(repo, logger, cfg.Anonymous.AIOverrideKey)
        actionProcessor := services.NewActionProcessor(repo, logger)

        // Initialize thought processing service
        var thoughtProcessingSvc *services.ThoughtProcessingService
        if openaiClient != nil || anthropicClient != nil </span><span class="cov0" title="0">{
                thoughtProcessingSvc = services.NewThoughtProcessingService(
                        repo,
                        openaiClient,
                        anthropicClient,
                        contextGatherer,
                        subscriptionSvc,
                        actionProcessor,
                        logger,
                )
                logger.Info("Thought processing service initialized")
        }</span>

        // Initialize Stripe billing service
        <span class="cov0" title="0">var stripeBillingSvc *services.StripeBillingService
        if stripeClient != nil </span><span class="cov0" title="0">{
                stripeBillingSvc = services.NewStripeBillingService(stripeClient, repo, logger)
                logger.Info("Stripe billing service initialized")
        }</span>

        // Initialize Plaid service
        <span class="cov0" title="0">var plaidService *services.PlaidService
        if plaidClient != nil </span><span class="cov0" title="0">{
                plaidService = services.NewPlaidService(plaidClient, repo, logger)
                logger.Info("Plaid service initialized")
        }</span>

        // Initialize analytics services
        <span class="cov0" title="0">dashboardAnalyticsSvc := services.NewDashboardAnalyticsService(repo, logger)
        logger.Info("Dashboard analytics service initialized")
        spendingAnalyticsSvc := services.NewSpendingAnalyticsService(repo, logger)
        logger.Info("Spending analytics service initialized")

        // Initialize import/export service
        importExportSvc := services.NewImportExportService(repo, logger)
        logger.Info("Import/export service initialized")

        // Initialize investment calculation service
        investmentCalcSvc := services.NewInvestmentCalculationService(repo, logger)
        logger.Info("Investment calculation service initialized")

        // Initialize entity graph service
        entityGraphSvc := services.NewEntityGraphService(repo, logger)
        logger.Info("Entity graph service initialized")

        // Initialize stock service
        var stockService *services.StockService
        if alphaVantageClient != nil </span><span class="cov0" title="0">{
                stockService = services.NewStockService(repo, alphaVantageClient, logger)
                logger.Info("Stock service initialized")
        }</span>

        // Initialize investment prediction service
        <span class="cov0" title="0">var predictionService *services.InvestmentPredictionService
        if openaiClient != nil </span><span class="cov0" title="0">{
                predictionService = services.NewInvestmentPredictionService(openaiClient, logger)
                logger.Info("Investment prediction service initialized")
        }</span>

        // Initialize CSV processing service
        <span class="cov0" title="0">var csvProcessingSvc *services.CSVProcessingService
        if storageClient != nil &amp;&amp; categorizationSvc != nil </span><span class="cov0" title="0">{
                csvProcessingSvc = services.NewCSVProcessingService(
                        repo,
                        storageClient,
                        categorizationSvc,
                        cfg.Firebase.StorageBucket,
                        logger,
                )
                logger.Info("CSV processing service initialized")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("CSV processing service disabled (Cloud Storage or categorization not available)")
        }</span>

        // Initialize photo service
        <span class="cov0" title="0">var photoService *services.PhotoService
        if storageClient != nil </span><span class="cov0" title="0">{
                photoService = services.NewPhotoService(
                        repo,
                        storageClient,
                        cfg.Firebase.StorageBucket,
                        logger,
                )
                logger.Info("Photo service initialized")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Photo service disabled (Cloud Storage not available)")
        }</span>

        // Initialize packing list service
        <span class="cov0" title="0">packingListService := services.NewPackingListService(repo, logger)
        logger.Info("Packing list service initialized")

        // Initialize place insights service
        var placeInsightsService *services.PlaceInsightsService
        if openaiClient != nil </span><span class="cov0" title="0">{
                placeInsightsService = services.NewPlaceInsightsService(openaiClient, logger)
                logger.Info("Place insights service initialized")
        }</span>

        // Initialize visa service
        <span class="cov0" title="0">visaService := services.NewVisaService(repo, logger)
        logger.Info("Visa service initialized")

        // Initialize middleware
        authMiddleware := middleware.NewAuthMiddleware(
                fbAdmin.Auth,
                fbAdmin.Firestore,
                cfg.Anonymous.AIOverrideKey,
        )

        // Initialize handlers
        healthHandler := handlers.NewHealthHandler(fbAdmin)

        var thoughtHandler *handlers.ThoughtHandler
        if thoughtProcessingSvc != nil </span><span class="cov0" title="0">{
                thoughtHandler = handlers.NewThoughtHandler(thoughtProcessingSvc, logger)
        }</span>

        <span class="cov0" title="0">var stripeHandler *handlers.StripeHandler
        if stripeBillingSvc != nil </span><span class="cov0" title="0">{
                stripeHandler = handlers.NewStripeHandler(stripeClient, stripeBillingSvc, logger)
        }</span>

        <span class="cov0" title="0">var plaidHandler *handlers.PlaidHandler
        if plaidService != nil </span><span class="cov0" title="0">{
                plaidHandler = handlers.NewPlaidHandler(plaidService, logger)
        }</span>

        // Analytics handler (always available)
        <span class="cov0" title="0">analyticsHandler := handlers.NewAnalyticsHandler(dashboardAnalyticsSvc, spendingAnalyticsSvc, logger)

        // Import/export handler (always available)
        importExportHandler := handlers.NewImportExportHandler(importExportSvc, logger)

        // Investment calculation handler (always available)
        investmentHandler := handlers.NewInvestmentHandler(investmentCalcSvc, logger)

        // Entity graph handler (always available)
        entityGraphHandler := handlers.NewEntityGraphHandler(entityGraphSvc, logger)

        // Stock handler
        var stockHandler *handlers.StockHandler
        if stockService != nil || predictionService != nil </span><span class="cov0" title="0">{
                stockHandler = handlers.NewStockHandler(stockService, predictionService, logger)
                logger.Info("Stock handler initialized")
        }</span>

        // Spending handler
        <span class="cov0" title="0">var spendingHandler *handlers.SpendingHandler
        if csvProcessingSvc != nil </span><span class="cov0" title="0">{
                spendingHandler = handlers.NewSpendingHandler(csvProcessingSvc, logger)
                logger.Info("Spending handler initialized")
        }</span>

        // Chat handler
        <span class="cov0" title="0">var chatHandler *handlers.ChatHandler
        if chatService != nil </span><span class="cov0" title="0">{
                chatHandler = handlers.NewChatHandler(chatService, logger)
                logger.Info("Chat handler initialized")
        }</span>

        // Photo handler
        <span class="cov0" title="0">var photoHandler *handlers.PhotoHandler
        if photoService != nil </span><span class="cov0" title="0">{
                photoHandler = handlers.NewPhotoHandler(photoService, logger)
                logger.Info("Photo handler initialized")
        }</span>

        // Packing list handler (always available)
        <span class="cov0" title="0">packingListHandler := handlers.NewPackingListHandler(packingListService, logger)
        logger.Info("Packing list handler initialized")

        // Place insights handler
        var placeInsightsHandler *handlers.PlaceInsightsHandler
        if placeInsightsService != nil </span><span class="cov0" title="0">{
                placeInsightsHandler = handlers.NewPlaceInsightsHandler(placeInsightsService, logger)
                logger.Info("Place insights handler initialized")
        }</span>

        // Visa handler (always available)
        <span class="cov0" title="0">visaHandler := handlers.NewVisaHandler(visaService, logger)
        logger.Info("Visa handler initialized")

        // Create router
        router := mux.NewRouter()

        // Apply global middleware
        router.Use(middleware.Recovery(logger))
        router.Use(middleware.Logging(logger))
        router.Use(middleware.CORS(&amp;cfg.Server.CORS))

        // Health and metrics (no auth required)
        router.HandleFunc("/health", healthHandler.Handle).Methods("GET")
        if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                router.Handle("/metrics", promhttp.Handler()).Methods("GET")
        }</span>

        // API routes (require authentication)
        <span class="cov0" title="0">api := router.PathPrefix("/api").Subrouter()
        api.Use(authMiddleware.Authenticate)

        // Thought processing routes (requires AI access)
        if thoughtHandler != nil </span><span class="cov0" title="0">{
                thoughtRoutes := api.PathPrefix("/").Subrouter()
                thoughtRoutes.Use(authMiddleware.RequireAI)
                thoughtRoutes.Use(authMiddleware.RequireSubscription)
                thoughtRoutes.HandleFunc("/process-thought", thoughtHandler.ProcessThought).Methods("POST")
                thoughtRoutes.HandleFunc("/reprocess-thought", thoughtHandler.ReprocessThought).Methods("POST")
                thoughtRoutes.HandleFunc("/revert-thought-processing", thoughtHandler.RevertThoughtProcessing).Methods("POST")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Thought processing endpoints disabled (no AI clients configured)")
        }</span>

        // Stripe billing routes
        <span class="cov0" title="0">if stripeHandler != nil </span><span class="cov0" title="0">{
                // Webhook endpoint (no auth - uses Stripe signature verification)
                router.HandleFunc("/api/stripe/webhook", stripeHandler.HandleWebhook).Methods("POST")

                // Authenticated Stripe endpoints
                stripeRoutes := api.PathPrefix("/stripe").Subrouter()
                stripeRoutes.HandleFunc("/create-checkout-session", stripeHandler.CreateCheckoutSession).Methods("POST")
                stripeRoutes.HandleFunc("/create-portal-session", stripeHandler.CreatePortalSession).Methods("POST")
                stripeRoutes.HandleFunc("/invoices", stripeHandler.GetInvoices).Methods("GET")
                stripeRoutes.HandleFunc("/payment-method", stripeHandler.GetPaymentMethod).Methods("GET")
                stripeRoutes.HandleFunc("/reactivate-subscription", stripeHandler.ReactivateSubscription).Methods("POST")
                stripeRoutes.HandleFunc("/usage-stats", stripeHandler.GetUsageStats).Methods("GET")

                logger.Info("Stripe endpoints registered")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Stripe endpoints disabled (Stripe not configured)")
        }</span>

        // Plaid banking routes
        <span class="cov0" title="0">if plaidHandler != nil </span><span class="cov0" title="0">{
                // Webhook endpoint (no auth - Plaid webhooks)
                router.HandleFunc("/api/plaid/webhook", plaidHandler.HandleWebhook).Methods("POST")

                // Authenticated Plaid endpoints
                plaidRoutes := api.PathPrefix("/plaid").Subrouter()
                plaidRoutes.HandleFunc("/create-link-token", plaidHandler.CreateLinkToken).Methods("POST")
                plaidRoutes.HandleFunc("/exchange-public-token", plaidHandler.ExchangePublicToken).Methods("POST")
                plaidRoutes.HandleFunc("/create-relink-token", plaidHandler.CreateRelinkToken).Methods("POST")
                plaidRoutes.HandleFunc("/mark-relinking", plaidHandler.MarkRelinking).Methods("POST")
                plaidRoutes.HandleFunc("/trigger-sync", plaidHandler.TriggerSync).Methods("POST")

                logger.Info("Plaid endpoints registered")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Plaid endpoints disabled (Plaid not configured)")
        }</span>

        // Analytics routes (authenticated)
        <span class="cov0" title="0">analyticsRoutes := api.PathPrefix("/analytics").Subrouter()
        analyticsRoutes.HandleFunc("/dashboard", analyticsHandler.GetDashboardAnalytics).Methods("GET")
        analyticsRoutes.HandleFunc("/spending", analyticsHandler.GetSpendingAnalytics).Methods("GET")
        logger.Info("Analytics endpoints registered")

        // Import/export routes (authenticated)
        importRoutes := api.PathPrefix("/import").Subrouter()
        importRoutes.HandleFunc("/validate", importExportHandler.ValidateImport).Methods("POST")
        importRoutes.HandleFunc("/execute", importExportHandler.ExecuteImport).Methods("POST")

        exportRoutes := api.PathPrefix("/export").Subrouter()
        exportRoutes.HandleFunc("", importExportHandler.ExportData).Methods("GET")
        exportRoutes.HandleFunc("/summary", importExportHandler.GetExportSummary).Methods("GET")
        logger.Info("Import/export endpoints registered")

        // Investment calculation routes (authenticated)
        portfolioRoutes := api.PathPrefix("/portfolio").Subrouter()
        portfolioRoutes.HandleFunc("/{portfolioId}/metrics", investmentHandler.GetPortfolioMetrics).Methods("GET")
        portfolioRoutes.HandleFunc("/{portfolioId}/snapshots", investmentHandler.GetPortfolioSnapshots).Methods("GET")
        portfolioRoutes.HandleFunc("/projection", investmentHandler.GenerateProjection).Methods("POST")
        portfolioRoutes.HandleFunc("/summary", investmentHandler.GetDashboardSummary).Methods("GET")
        logger.Info("Investment calculation endpoints registered")

        // Entity graph routes (authenticated)
        entityGraphRoutes := api.PathPrefix("/entity-graph").Subrouter()
        entityGraphRoutes.HandleFunc("/relationships", entityGraphHandler.QueryRelationships).Methods("GET", "POST")
        entityGraphRoutes.HandleFunc("/linked/{entityType}/{entityId}", entityGraphHandler.GetLinkedEntities).Methods("GET")
        entityGraphRoutes.HandleFunc("/tools", entityGraphHandler.GetToolRelationships).Methods("GET")
        entityGraphRoutes.HandleFunc("/stats", entityGraphHandler.GetRelationshipStats).Methods("GET")
        logger.Info("Entity graph endpoints registered")

        // Stock routes (authenticated)
        if stockHandler != nil </span><span class="cov0" title="0">{
                api.HandleFunc("/stock-price", stockHandler.GetStockPrice).Methods("POST")
                api.HandleFunc("/stock-history", stockHandler.GetStockHistory).Methods("POST")
                api.HandleFunc("/predict-investment", stockHandler.PredictInvestment).Methods("POST")
                logger.Info("Stock endpoints registered (3 endpoints)")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Stock endpoints disabled")
        }</span>

        // Spending routes (authenticated)
        <span class="cov0" title="0">if spendingHandler != nil </span><span class="cov0" title="0">{
                spendingRoutes := api.PathPrefix("/spending").Subrouter()
                spendingRoutes.HandleFunc("/process-csv", spendingHandler.ProcessCSV).Methods("POST")
                spendingRoutes.HandleFunc("/delete-csv", spendingHandler.DeleteCSV).Methods("POST")
                spendingRoutes.HandleFunc("/categorize", spendingHandler.CategorizeTransaction).Methods("POST")
                spendingRoutes.HandleFunc("/link-trip", spendingHandler.LinkTransactionToTrip).Methods("POST")
                spendingRoutes.HandleFunc("/delete-all", spendingHandler.DeleteAllTransactions).Methods("POST")
                logger.Info("Spending endpoints registered (5 endpoints)")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Spending endpoints disabled (CSV processing service not available)")
        }</span>

        // Chat route (authenticated, requires AI access)
        <span class="cov0" title="0">if chatHandler != nil </span><span class="cov0" title="0">{
                api.HandleFunc("/chat", chatHandler.Chat).Methods("POST")
                logger.Info("Chat endpoint registered")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Chat endpoint disabled (no AI clients configured)")
        }</span>

        // Photo routes (vote endpoint allows anonymous, others require auth)
        <span class="cov0" title="0">if photoHandler != nil </span><span class="cov0" title="0">{
                photoRoutes := api.PathPrefix("/photo").Subrouter()
                // Vote can be submitted by anonymous users
                photoRoutes.HandleFunc("/vote", photoHandler.SubmitVote).Methods("POST")
                // Next pair can be fetched anonymously
                photoRoutes.HandleFunc("/next-pair", photoHandler.GetNextPair).Methods("POST")
                // Signed URL requires authentication
                photoRoutes.HandleFunc("/signed-url", photoHandler.GetSignedURL).Methods("POST")
                logger.Info("Photo endpoints registered (3 endpoints)")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Photo endpoints disabled (Cloud Storage not available)")
        }</span>

        // Packing list routes (authenticated)
        <span class="cov0" title="0">packingRoutes := api.PathPrefix("/packing-list").Subrouter()
        packingRoutes.HandleFunc("/create", packingListHandler.CreatePackingList).Methods("POST")
        packingRoutes.HandleFunc("/update", packingListHandler.UpdatePackingList).Methods("POST")
        packingRoutes.HandleFunc("/toggle-item", packingListHandler.SetItemStatus).Methods("POST")
        logger.Info("Packing list endpoints registered (3 endpoints)")

        // Place insights routes (authenticated, requires AI access)
        if placeInsightsHandler != nil </span><span class="cov0" title="0">{
                api.HandleFunc("/place-insights", placeInsightsHandler.GenerateInsights).Methods("POST")
                logger.Info("Place insights endpoint registered")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Place insights endpoint disabled (no AI clients configured)")
        }</span>

        // Visa routes (authenticated)
        <span class="cov0" title="0">api.HandleFunc("/visa-requirements", visaHandler.GetVisaRequirements).Methods("GET")
        logger.Info("Visa requirements endpoint registered")

        // Log registered routes
        logger.Info("Routes registered",
                zap.Int("count", countRoutes(router)),
        )

        // Create HTTP server
        server := &amp;http.Server{
                Addr:           cfg.GetServerAddr(),
                Handler:        router,
                ReadTimeout:    cfg.Server.ReadTimeout,
                WriteTimeout:   cfg.Server.WriteTimeout,
                IdleTimeout:    cfg.Server.IdleTimeout,
                MaxHeaderBytes: cfg.Server.MaxHeaderBytes,
        }

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                logger.Info("Server listening",
                        zap.String("addr", server.Addr),
                )
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Fatal("Server failed", zap.Error(err))
                }</span>
        }()

        // Graceful shutdown
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
        &lt;-quit

        logger.Info("Shutting down server...")

        // Give server 30 seconds to finish processing requests
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Server forced to shutdown", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Server stopped")</span>
}

// countRoutes counts the number of registered routes
func countRoutes(router *mux.Router) int <span class="cov8" title="1">{
        count := 0
        _ = router.Walk(func(_ *mux.Route, _ *mux.Router, _ []*mux.Route) error </span><span class="cov8" title="1">{
                count++
                return nil
        }</span>)
        <span class="cov8" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package clients

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/config"
)

const (
        AlphaVantageBaseURL = "https://www.alphavantage.co/query"
        AlphaVantageSource  = "Alpha Vantage"
)

// AlphaVantageClient handles interactions with Alpha Vantage API
type AlphaVantageClient struct {
        apiKey string
        client *http.Client
        logger *zap.Logger
}

// StockQuote represents a real-time stock quote
type StockQuote struct {
        Symbol        string  `json:"symbol"`
        Price         float64 `json:"price"`
        Change        float64 `json:"change"`
        ChangePercent float64 `json:"changePercent"`
        Timestamp     string  `json:"timestamp"`
        Source        string  `json:"source"`
}

// HistoricalDataPoint represents a single data point in historical data
type HistoricalDataPoint struct {
        Date   string  `json:"date"`
        Price  float64 `json:"price"`
        Volume int64   `json:"volume,omitempty"`
}

// StockHistory represents historical stock data
type StockHistory struct {
        Symbol string                `json:"symbol"`
        Data   []HistoricalDataPoint `json:"data"`
        Source string                `json:"source"`
}

// AlphaVantageGlobalQuoteResponse is the API response structure
type AlphaVantageGlobalQuoteResponse struct {
        GlobalQuote GlobalQuoteData `json:"Global Quote"`
        Note        string          `json:"Note,omitempty"`
        ErrorMsg    string          `json:"Error Message,omitempty"`
}

// GlobalQuoteData contains the actual quote data
type GlobalQuoteData struct {
        Symbol           string `json:"01. symbol"`
        Price            string `json:"05. price"`
        Change           string `json:"09. change"`
        ChangePercent    string `json:"10. change percent"`
        LatestTradingDay string `json:"07. latest trading day"`
}

// AlphaVantageTimeSeriesResponse is the response for historical data
type AlphaVantageTimeSeriesResponse struct {
        MetaData   TimeSeriesMetaData       `json:"Meta Data"`
        TimeSeries map[string]TimeSeriesDay `json:"Time Series (Daily)"`
        Note       string                   `json:"Note,omitempty"`
        ErrorMsg   string                   `json:"Error Message,omitempty"`
}

// TimeSeriesMetaData contains metadata about the time series
type TimeSeriesMetaData struct {
        Symbol string `json:"2. Symbol"`
}

// TimeSeriesDay represents a single day's data
type TimeSeriesDay struct {
        Open   string `json:"1. open"`
        High   string `json:"2. high"`
        Low    string `json:"3. low"`
        Close  string `json:"4. close"`
        Volume string `json:"5. volume"`
}

// NewAlphaVantageClient creates a new Alpha Vantage API client
func NewAlphaVantageClient(cfg *config.AlphaVantageConfig, logger *zap.Logger) *AlphaVantageClient <span class="cov8" title="1">{
        timeout := cfg.Timeout
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 30 * time.Second
        }</span>
        <span class="cov8" title="1">return &amp;AlphaVantageClient{
                apiKey: cfg.APIKey,
                client: &amp;http.Client{
                        Timeout: timeout,
                },
                logger: logger,
        }</span>
}

// GetQuote fetches a real-time stock quote
func (c *AlphaVantageClient) GetQuote(ctx context.Context, symbol string) (*StockQuote, error) <span class="cov0" title="0">{
        symbol = strings.ToUpper(strings.TrimSpace(symbol))

        params := url.Values{}
        params.Set("function", "GLOBAL_QUOTE")
        params.Set("symbol", symbol)
        params.Set("apikey", c.apiKey)

        requestURL := fmt.Sprintf("%s?%s", AlphaVantageBaseURL, params.Encode())

        c.logger.Info("Requesting Alpha Vantage quote",
                zap.String("symbol", symbol),
                zap.String("endpoint", AlphaVantageBaseURL),
        )

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, requestURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch quote: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var result AlphaVantageGlobalQuoteResponse
        if decodeErr := json.NewDecoder(resp.Body).Decode(&amp;result); decodeErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", decodeErr)
        }</span>

        // Check for API errors
        <span class="cov0" title="0">if result.Note != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Alpha Vantage rate limit exceeded")
        }</span>
        <span class="cov0" title="0">if result.ErrorMsg != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Alpha Vantage error: %s", result.ErrorMsg)
        }</span>

        // Parse the quote data
        <span class="cov0" title="0">quote, err := c.parseGlobalQuote(symbol, result.GlobalQuote)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.logger.Info("Successfully fetched quote",
                zap.String("symbol", symbol),
                zap.Float64("price", quote.Price),
        )

        return quote, nil</span>
}

// GetHistoricalData fetches historical stock data
func (c *AlphaVantageClient) GetHistoricalData(ctx context.Context, symbol string, days int) (*StockHistory, error) <span class="cov0" title="0">{
        symbol = strings.ToUpper(strings.TrimSpace(symbol))

        params := url.Values{}
        params.Set("function", "TIME_SERIES_DAILY")
        params.Set("symbol", symbol)
        params.Set("apikey", c.apiKey)

        // For more than 100 days, use full output
        if days &gt; 100 </span><span class="cov0" title="0">{
                params.Set("outputsize", "full")
        }</span> else<span class="cov0" title="0"> {
                params.Set("outputsize", "compact")
        }</span>

        <span class="cov0" title="0">requestURL := fmt.Sprintf("%s?%s", AlphaVantageBaseURL, params.Encode())

        c.logger.Info("Requesting Alpha Vantage historical data",
                zap.String("symbol", symbol),
                zap.Int("days", days),
        )

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, requestURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch historical data: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var result AlphaVantageTimeSeriesResponse
        if decodeErr := json.NewDecoder(resp.Body).Decode(&amp;result); decodeErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", decodeErr)
        }</span>

        // Check for API errors
        <span class="cov0" title="0">if result.Note != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Alpha Vantage rate limit exceeded")
        }</span>
        <span class="cov0" title="0">if result.ErrorMsg != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Alpha Vantage error: %s", result.ErrorMsg)
        }</span>

        // Parse historical data
        <span class="cov0" title="0">history, err := c.parseTimeSeries(symbol, result.TimeSeries, days)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.logger.Info("Successfully fetched historical data",
                zap.String("symbol", symbol),
                zap.Int("dataPoints", len(history.Data)),
        )

        return history, nil</span>
}

// parseGlobalQuote parses the Global Quote response
func (c *AlphaVantageClient) parseGlobalQuote(symbol string, data GlobalQuoteData) (*StockQuote, error) <span class="cov0" title="0">{
        if data.Symbol == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no quote found for symbol: %s", symbol)
        }</span>

        <span class="cov0" title="0">price, err := strconv.ParseFloat(data.Price, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid price: %w", err)
        }</span>

        <span class="cov0" title="0">change, err := strconv.ParseFloat(data.Change, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Invalid change value, using 0", zap.Error(err))
                change = 0
        }</span>

        // Parse change percent, removing the % sign
        <span class="cov0" title="0">changePercentStr := strings.TrimSuffix(data.ChangePercent, "%")
        changePercent, err := strconv.ParseFloat(changePercentStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Invalid change percent, using 0", zap.Error(err))
                changePercent = 0
        }</span>

        // Parse timestamp
        <span class="cov0" title="0">var timestamp string
        if data.LatestTradingDay != "" </span><span class="cov0" title="0">{
                // Convert trading day to ISO format
                t, err := time.Parse("2006-01-02", data.LatestTradingDay)
                if err == nil </span><span class="cov0" title="0">{
                        timestamp = t.UTC().Format(time.RFC3339)
                }</span> else<span class="cov0" title="0"> {
                        timestamp = time.Now().UTC().Format(time.RFC3339)
                }</span>
        } else<span class="cov0" title="0"> {
                timestamp = time.Now().UTC().Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">return &amp;StockQuote{
                Symbol:        symbol,
                Price:         price,
                Change:        change,
                ChangePercent: changePercent,
                Timestamp:     timestamp,
                Source:        AlphaVantageSource,
        }, nil</span>
}

// parseTimeSeries parses the time series data
func (c *AlphaVantageClient) parseTimeSeries(symbol string, timeSeries map[string]TimeSeriesDay, days int) (*StockHistory, error) <span class="cov0" title="0">{
        if len(timeSeries) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no historical data found for symbol: %s", symbol)
        }</span>

        // Sort dates and take the most recent N days
        <span class="cov0" title="0">dates := make([]string, 0, len(timeSeries))
        for date := range timeSeries </span><span class="cov0" title="0">{
                dates = append(dates, date)
        }</span>

        // Sort dates in descending order (most recent first)
        <span class="cov0" title="0">sortDatesDescending(dates)

        // Limit to requested number of days
        if len(dates) &gt; days </span><span class="cov0" title="0">{
                dates = dates[:days]
        }</span>

        // Reverse to get chronological order (oldest first)
        <span class="cov0" title="0">reverseDates(dates)

        // Build data points
        dataPoints := make([]HistoricalDataPoint, 0, len(dates))
        for _, date := range dates </span><span class="cov0" title="0">{
                day := timeSeries[date]

                closePrice, err := strconv.ParseFloat(day.Close, 64)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("Invalid close price for date",
                                zap.String("date", date),
                                zap.Error(err),
                        )
                        continue</span>
                }

                <span class="cov0" title="0">volume, err := strconv.ParseInt(day.Volume, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("Invalid volume for date",
                                zap.String("date", date),
                                zap.Error(err),
                        )
                        volume = 0
                }</span>

                <span class="cov0" title="0">dataPoints = append(dataPoints, HistoricalDataPoint{
                        Date:   date,
                        Price:  closePrice,
                        Volume: volume,
                })</span>
        }

        <span class="cov0" title="0">return &amp;StockHistory{
                Symbol: symbol,
                Data:   dataPoints,
                Source: AlphaVantageSource,
        }, nil</span>
}

// Helper functions for sorting dates

func sortDatesDescending(dates []string) <span class="cov0" title="0">{
        // Simple bubble sort in descending order
        n := len(dates)
        for i := 0; i &lt; n-1; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; n-i-1; j++ </span><span class="cov0" title="0">{
                        if dates[j] &lt; dates[j+1] </span><span class="cov0" title="0">{
                                dates[j], dates[j+1] = dates[j+1], dates[j]
                        }</span>
                }
        }
}

func reverseDates(dates []string) <span class="cov0" title="0">{
        for i, j := 0, len(dates)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                dates[i], dates[j] = dates[j], dates[i]
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package clients

import (
        "context"
        "fmt"
        "time"

        "github.com/anthropics/anthropic-sdk-go"
        "github.com/anthropics/anthropic-sdk-go/option"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/config"
)

// AnthropicClient wraps the Anthropic API client
type AnthropicClient struct {
        client      *anthropic.Client
        config      *config.AnthropicConfig
        logger      *zap.Logger
        rateLimiter *RateLimiter
}

// NewAnthropicClient creates a new Anthropic client
func NewAnthropicClient(cfg *config.AnthropicConfig, logger *zap.Logger) (*AnthropicClient, error) <span class="cov8" title="1">{
        if cfg.APIKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Anthropic API key is required")
        }</span>

        <span class="cov8" title="1">client := anthropic.NewClient(option.WithAPIKey(cfg.APIKey))

        // Create rate limiter
        rateLimiter := NewRateLimiter(
                cfg.RateLimit.RequestsPerMinute,
                100000, // Anthropic doesn't publish token limits, use conservative value
        )

        return &amp;AnthropicClient{
                client:      client,
                config:      cfg,
                logger:      logger,
                rateLimiter: rateLimiter,
        }, nil</span>
}

// ChatCompletion sends a chat completion request to Anthropic
func (c *AnthropicClient) ChatCompletion(ctx context.Context, req ChatCompletionRequest) (*ChatCompletionResponse, error) <span class="cov0" title="0">{
        // Use default model if not specified
        if req.Model == "" </span><span class="cov0" title="0">{
                req.Model = c.config.DefaultModel
        }</span>

        // Use default settings if not specified
        <span class="cov0" title="0">if req.MaxTokens == 0 </span><span class="cov0" title="0">{
                req.MaxTokens = c.config.MaxTokens
        }</span>
        <span class="cov0" title="0">if req.Temperature == 0 </span><span class="cov0" title="0">{
                req.Temperature = 0.7 // Anthropic default
        }</span>

        // Wait for rate limit
        <span class="cov0" title="0">if err := c.rateLimiter.WaitForRequest(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate limit wait failed: %w", err)
        }</span>

        // Convert messages to Anthropic format
        <span class="cov0" title="0">var messages []anthropic.MessageParam
        var systemPrompt string

        for _, msg := range req.Messages </span><span class="cov0" title="0">{
                if msg.Role == "system" </span><span class="cov0" title="0">{
                        // Anthropic uses a separate system parameter
                        systemPrompt = msg.Content
                }</span> else<span class="cov0" title="0"> {
                        messages = append(messages, anthropic.NewUserMessage(
                                anthropic.NewTextBlock(msg.Content),
                        ))
                }</span>
        }

        // Set timeout
        <span class="cov0" title="0">reqCtx, cancel := context.WithTimeout(ctx, c.config.Timeout)
        defer cancel()

        c.logger.Debug("Sending Anthropic request",
                zap.String("model", req.Model),
                zap.Int("max_tokens", req.MaxTokens),
                zap.Float32("temperature", req.Temperature),
        )

        startTime := time.Now()

        // Build request
        params := anthropic.MessageNewParams{
                Model:     anthropic.F(anthropic.Model(req.Model)),
                MaxTokens: anthropic.F(int64(req.MaxTokens)),
                Messages:  anthropic.F(messages),
        }

        if systemPrompt != "" </span><span class="cov0" title="0">{
                params.System = anthropic.F([]anthropic.TextBlockParam{
                        anthropic.NewTextBlock(systemPrompt),
                })
        }</span>

        // Send request
        <span class="cov0" title="0">message, err := c.client.Messages.New(reqCtx, params)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Anthropic request failed",
                        zap.Error(err),
                        zap.String("model", req.Model),
                )
                return nil, fmt.Errorf("Anthropic request failed: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)

        // Extract response
        if len(message.Content) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no response content returned")
        }</span>

        <span class="cov0" title="0">content := message.Content[0].Text
        tokensUsed := int(message.Usage.InputTokens + message.Usage.OutputTokens)

        // Update token rate limiter
        c.rateLimiter.RecordTokens(tokensUsed)

        c.logger.Info("Anthropic request completed",
                zap.String("model", string(message.Model)),
                zap.Int("tokens_used", tokensUsed),
                zap.Duration("duration", duration),
                zap.String("stop_reason", string(message.StopReason)),
        )

        return &amp;ChatCompletionResponse{
                Content:      content,
                FinishReason: string(message.StopReason),
                TokensUsed:   tokensUsed,
                Model:        string(message.Model),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package clients

import (
        "context"
        "fmt"
        "time"

        "github.com/sashabaranov/go-openai"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/config"
)

// OpenAIClient wraps the OpenAI API client with retry and rate limiting
type OpenAIClient struct {
        client      *openai.Client
        config      *config.OpenAIConfig
        logger      *zap.Logger
        rateLimiter *RateLimiter
}

// NewOpenAIClient creates a new OpenAI client
func NewOpenAIClient(cfg *config.OpenAIConfig, logger *zap.Logger) (*OpenAIClient, error) <span class="cov8" title="1">{
        if cfg.APIKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("OpenAI API key is required")
        }</span>

        <span class="cov8" title="1">client := openai.NewClient(cfg.APIKey)

        // Create rate limiter
        rateLimiter := NewRateLimiter(
                cfg.RateLimit.RequestsPerMinute,
                cfg.RateLimit.TokensPerMinute,
        )

        return &amp;OpenAIClient{
                client:      client,
                config:      cfg,
                logger:      logger,
                rateLimiter: rateLimiter,
        }, nil</span>
}

// ChatCompletionRequest represents a chat completion request
type ChatCompletionRequest struct {
        Model          string
        Messages       []ChatMessage
        MaxTokens      int
        Temperature    float32
        ResponseFormat *ResponseFormat
}

// ChatMessage represents a single message in the chat
type ChatMessage struct {
        Role    string // system, user, assistant
        Content string
}

// ResponseFormat specifies the response format
type ResponseFormat struct {
        Type string // json_object or text
}

// ChatCompletionResponse represents the response from OpenAI
type ChatCompletionResponse struct {
        Content      string
        FinishReason string
        TokensUsed   int
        Model        string
}

// ChatCompletion sends a chat completion request to OpenAI
func (c *OpenAIClient) ChatCompletion(ctx context.Context, req ChatCompletionRequest) (*ChatCompletionResponse, error) <span class="cov0" title="0">{
        // Use default model if not specified
        if req.Model == "" </span><span class="cov0" title="0">{
                req.Model = c.config.DefaultModel
        }</span>

        // Use default settings if not specified
        <span class="cov0" title="0">if req.MaxTokens == 0 </span><span class="cov0" title="0">{
                req.MaxTokens = c.config.MaxTokens
        }</span>
        <span class="cov0" title="0">if req.Temperature == 0 </span><span class="cov0" title="0">{
                req.Temperature = c.config.Temperature
        }</span>

        // Wait for rate limit
        <span class="cov0" title="0">if err := c.rateLimiter.WaitForRequest(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate limit wait failed: %w", err)
        }</span>

        // Convert messages to OpenAI format
        <span class="cov0" title="0">var messages []openai.ChatCompletionMessage
        for _, msg := range req.Messages </span><span class="cov0" title="0">{
                messages = append(messages, openai.ChatCompletionMessage{
                        Role:    msg.Role,
                        Content: msg.Content,
                })
        }</span>

        // Build request
        <span class="cov0" title="0">openaiReq := openai.ChatCompletionRequest{
                Model:       req.Model,
                Messages:    messages,
                MaxTokens:   req.MaxTokens,
                Temperature: req.Temperature,
        }

        // Set response format if specified
        if req.ResponseFormat != nil &amp;&amp; req.ResponseFormat.Type == "json_object" </span><span class="cov0" title="0">{
                openaiReq.ResponseFormat = &amp;openai.ChatCompletionResponseFormat{
                        Type: openai.ChatCompletionResponseFormatTypeJSONObject,
                }
        }</span>

        // Set timeout
        <span class="cov0" title="0">reqCtx, cancel := context.WithTimeout(ctx, c.config.Timeout)
        defer cancel()

        // Log request
        c.logger.Debug("Sending OpenAI request",
                zap.String("model", req.Model),
                zap.Int("max_tokens", req.MaxTokens),
                zap.Float32("temperature", req.Temperature),
        )

        startTime := time.Now()

        // Send request with retry
        var resp openai.ChatCompletionResponse
        var err error

        err = c.retryWithBackoff(reqCtx, func() error </span><span class="cov0" title="0">{
                resp, err = c.client.CreateChatCompletion(reqCtx, openaiReq)
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("OpenAI request failed",
                        zap.Error(err),
                        zap.String("model", req.Model),
                )
                return nil, fmt.Errorf("OpenAI request failed: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)

        // Extract response
        if len(resp.Choices) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no response choices returned")
        }</span>

        <span class="cov0" title="0">choice := resp.Choices[0]
        tokensUsed := resp.Usage.TotalTokens

        // Update token rate limiter
        c.rateLimiter.RecordTokens(tokensUsed)

        c.logger.Info("OpenAI request completed",
                zap.String("model", resp.Model),
                zap.Int("tokens_used", tokensUsed),
                zap.Duration("duration", duration),
                zap.String("finish_reason", string(choice.FinishReason)),
        )

        return &amp;ChatCompletionResponse{
                Content:      choice.Message.Content,
                FinishReason: string(choice.FinishReason),
                TokensUsed:   tokensUsed,
                Model:        resp.Model,
        }, nil</span>
}

// retryWithBackoff retries the operation with exponential backoff
func (c *OpenAIClient) retryWithBackoff(ctx context.Context, operation func() error) error <span class="cov0" title="0">{
        maxRetries := 3
        baseDelay := 1 * time.Second
        maxDelay := 30 * time.Second

        var lastErr error
        for attempt := 0; attempt &lt; maxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        // Calculate delay with exponential backoff
                        // #nosec G115 -- attempt is guaranteed to be &gt;= 1 here, so attempt-1 &gt;= 0
                        delay := time.Duration(1&lt;&lt;uint(attempt-1)) * baseDelay
                        if delay &gt; maxDelay </span><span class="cov0" title="0">{
                                delay = maxDelay
                        }</span>

                        <span class="cov0" title="0">c.logger.Debug("Retrying OpenAI request",
                                zap.Int("attempt", attempt+1),
                                zap.Duration("delay", delay),
                        )

                        select </span>{
                        case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }
                }

                <span class="cov0" title="0">lastErr = operation()
                if lastErr == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Check if error is retryable
                <span class="cov0" title="0">if !isRetryableError(lastErr) </span><span class="cov0" title="0">{
                        return lastErr
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("max retries exceeded: %w", lastErr)</span>
}

// isRetryableError checks if an error is retryable
func isRetryableError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for specific OpenAI errors
        <span class="cov8" title="1">errStr := err.Error()

        // Rate limit errors
        if contains(errStr, "rate_limit_exceeded") || contains(errStr, "429") </span><span class="cov8" title="1">{
                return true
        }</span>

        // Server errors
        <span class="cov8" title="1">if contains(errStr, "500") || contains(errStr, "502") || contains(errStr, "503") || contains(errStr, "504") </span><span class="cov8" title="1">{
                return true
        }</span>

        // Timeout errors
        <span class="cov8" title="1">if contains(errStr, "timeout") || contains(errStr, "deadline exceeded") </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// contains checks if a string contains a substring
func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || len(s) &gt; len(substr) &amp;&amp;
                (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr ||
                        findSubstring(s, substr)))
}</span>

func findSubstring(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package clients

import (
        "context"
        "fmt"
        "time"

        "github.com/plaid/plaid-go/v20/plaid"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/config"
)

// PlaidClient wraps the Plaid API client
type PlaidClient struct {
        client       *plaid.APIClient
        environment  plaid.Environment
        clientID     string
        secret       string
        products     []plaid.Products
        countryCodes []plaid.CountryCode
        webhookURL   string
        logger       *zap.Logger
}

// PlaidConfig holds initialization parameters
type PlaidClientConfig struct {
        ClientID     string
        Secret       string
        Environment  string // "sandbox", "development", or "production"
        Products     []string
        CountryCodes []string
        WebhookURL   string
}

// NewPlaidClient creates a new Plaid client
func NewPlaidClient(cfg *config.PlaidConfig, logger *zap.Logger) (*PlaidClient, error) <span class="cov8" title="1">{
        if cfg.ClientID == "" || cfg.Secret == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Plaid client ID and secret are required")
        }</span>

        // Map environment string to Plaid enum
        <span class="cov8" title="1">var env plaid.Environment
        switch cfg.Environment </span>{
        case "sandbox":<span class="cov8" title="1">
                env = plaid.Sandbox</span>
        case "development":<span class="cov8" title="1">
                env = plaid.Development</span>
        case "production":<span class="cov8" title="1">
                env = plaid.Production</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("invalid Plaid environment: %s", cfg.Environment)</span>
        }

        // Map products
        <span class="cov8" title="1">products := []plaid.Products{}
        for _, p := range cfg.Products </span><span class="cov8" title="1">{
                switch p </span>{
                case "transactions":<span class="cov8" title="1">
                        products = append(products, plaid.PRODUCTS_TRANSACTIONS)</span>
                case "auth":<span class="cov8" title="1">
                        products = append(products, plaid.PRODUCTS_AUTH)</span>
                case "identity":<span class="cov0" title="0">
                        products = append(products, plaid.PRODUCTS_IDENTITY)</span>
                case "assets":<span class="cov0" title="0">
                        products = append(products, plaid.PRODUCTS_ASSETS)</span>
                case "liabilities":<span class="cov0" title="0">
                        products = append(products, plaid.PRODUCTS_LIABILITIES)</span>
                case "investments":<span class="cov0" title="0">
                        products = append(products, plaid.PRODUCTS_INVESTMENTS)</span>
                }
        }

        // Map country codes
        <span class="cov8" title="1">countryCodes := []plaid.CountryCode{}
        for _, c := range cfg.CountryCodes </span><span class="cov8" title="1">{
                countryCodes = append(countryCodes, plaid.CountryCode(c))
        }</span>

        // Create Plaid configuration
        <span class="cov8" title="1">configuration := plaid.NewConfiguration()
        configuration.AddDefaultHeader("PLAID-CLIENT-ID", cfg.ClientID)
        configuration.AddDefaultHeader("PLAID-SECRET", cfg.Secret)
        configuration.UseEnvironment(env)

        client := plaid.NewAPIClient(configuration)

        logger.Info("Plaid client initialized",
                zap.String("environment", cfg.Environment),
                zap.Int("products", len(products)),
        )

        return &amp;PlaidClient{
                client:       client,
                environment:  env,
                clientID:     cfg.ClientID,
                secret:       cfg.Secret,
                products:     products,
                countryCodes: countryCodes,
                webhookURL:   cfg.WebhookURL,
                logger:       logger,
        }, nil</span>
}

// CreateLinkTokenRequest holds parameters for link token creation
type CreateLinkTokenRequest struct {
        UserID      string
        UserEmail   string
        Platform    string // "web", "ios", or "android"
        RedirectURI string // Optional redirect URI for OAuth
        AccessToken string // Optional: for update mode
}

// CreateLinkTokenResponse holds the link token result
type CreateLinkTokenResponse struct {
        LinkToken  string
        Expiration time.Time
        RequestID  string
}

// CreateLinkToken creates a Plaid Link token for connecting accounts
func (c *PlaidClient) CreateLinkToken(ctx context.Context, req CreateLinkTokenRequest) (*CreateLinkTokenResponse, error) <span class="cov0" title="0">{
        c.logger.Debug("Creating Plaid link token",
                zap.String("userId", req.UserID),
                zap.String("platform", req.Platform),
                zap.Bool("updateMode", req.AccessToken != ""),
        )

        // Build user info
        user := plaid.LinkTokenCreateRequestUser{
                ClientUserId: req.UserID,
        }
        if req.UserEmail != "" </span><span class="cov0" title="0">{
                user.EmailAddress = plaid.PtrString(req.UserEmail)
        }</span>

        // Build request
        <span class="cov0" title="0">request := plaid.NewLinkTokenCreateRequest(
                "Focus Notebook",
                "en",
                c.countryCodes,
                user,
        )

        // Set products (not needed in update mode)
        if req.AccessToken == "" </span><span class="cov0" title="0">{
                request.SetProducts(c.products)
        }</span>

        // Set webhook URL
        <span class="cov0" title="0">if c.webhookURL != "" </span><span class="cov0" title="0">{
                request.SetWebhook(c.webhookURL)
        }</span>

        // Set platform-specific redirect URI
        <span class="cov0" title="0">if req.RedirectURI != "" </span><span class="cov0" title="0">{
                request.SetRedirectUri(req.RedirectURI)
        }</span>

        // Set access token for update mode
        <span class="cov0" title="0">if req.AccessToken != "" </span><span class="cov0" title="0">{
                request.SetAccessToken(req.AccessToken)
        }</span>

        // Call Plaid API
        <span class="cov0" title="0">response, httpResp, err := c.client.PlaidApi.LinkTokenCreate(ctx).LinkTokenCreateRequest(*request).Execute()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to create link token",
                        zap.Error(err),
                        zap.String("userId", req.UserID),
                )
                return nil, fmt.Errorf("failed to create link token: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = httpResp.Body.Close() }</span>()

        <span class="cov0" title="0">expiration := response.GetExpiration()

        c.logger.Info("Link token created",
                zap.String("userId", req.UserID),
                zap.String("platform", req.Platform),
                zap.Time("expiration", expiration),
        )

        return &amp;CreateLinkTokenResponse{
                LinkToken:  response.GetLinkToken(),
                Expiration: expiration,
                RequestID:  response.GetRequestId(),
        }, nil</span>
}

// ExchangePublicTokenRequest holds parameters for public token exchange
type ExchangePublicTokenRequest struct {
        PublicToken string
}

// ExchangePublicTokenResponse holds the exchange result
type ExchangePublicTokenResponse struct {
        AccessToken string
        ItemID      string
        RequestID   string
}

// ExchangePublicToken exchanges a public token for an access token
func (c *PlaidClient) ExchangePublicToken(ctx context.Context, req ExchangePublicTokenRequest) (*ExchangePublicTokenResponse, error) <span class="cov0" title="0">{
        c.logger.Debug("Exchanging public token")

        request := plaid.NewItemPublicTokenExchangeRequest(req.PublicToken)

        response, httpResp, err := c.client.PlaidApi.ItemPublicTokenExchange(ctx).ItemPublicTokenExchangeRequest(*request).Execute()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to exchange public token", zap.Error(err))
                return nil, fmt.Errorf("failed to exchange public token: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = httpResp.Body.Close() }</span>()

        <span class="cov0" title="0">c.logger.Info("Public token exchanged",
                zap.String("itemId", response.GetItemId()),
        )

        return &amp;ExchangePublicTokenResponse{
                AccessToken: response.GetAccessToken(),
                ItemID:      response.GetItemId(),
                RequestID:   response.GetRequestId(),
        }, nil</span>
}

// GetItemResponse holds item information
type GetItemResponse struct {
        ItemID            string
        InstitutionID     string
        Webhook           string
        AvailableProducts []string
        BilledProducts    []string
        Error             *string
        UpdateType        string
}

// GetItem retrieves information about a Plaid item
func (c *PlaidClient) GetItem(ctx context.Context, accessToken string) (*GetItemResponse, error) <span class="cov0" title="0">{
        c.logger.Debug("Getting Plaid item")

        request := plaid.NewItemGetRequest(accessToken)

        response, httpResp, err := c.client.PlaidApi.ItemGet(ctx).ItemGetRequest(*request).Execute()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get item", zap.Error(err))
                return nil, fmt.Errorf("failed to get item: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = httpResp.Body.Close() }</span>()

        <span class="cov0" title="0">item := response.GetItem()
        result := &amp;GetItemResponse{
                ItemID:            item.GetItemId(),
                Webhook:           item.GetWebhook(),
                AvailableProducts: []string{},
                BilledProducts:    []string{},
        }

        // Handle nullable institution ID
        if item.InstitutionId.IsSet() &amp;&amp; item.InstitutionId.Get() != nil </span><span class="cov0" title="0">{
                result.InstitutionID = *item.InstitutionId.Get()
        }</span>

        // Convert products to strings
        <span class="cov0" title="0">for _, p := range item.GetAvailableProducts() </span><span class="cov0" title="0">{
                result.AvailableProducts = append(result.AvailableProducts, string(p))
        }</span>
        <span class="cov0" title="0">for _, p := range item.GetBilledProducts() </span><span class="cov0" title="0">{
                result.BilledProducts = append(result.BilledProducts, string(p))
        }</span>

        // Check for errors
        <span class="cov0" title="0">if item.Error.IsSet() &amp;&amp; item.Error.Get() != nil </span><span class="cov0" title="0">{
                plaidErr := item.Error.Get()
                errorStr := plaidErr.GetErrorMessage()
                result.Error = &amp;errorStr
                result.UpdateType = string(plaidErr.GetErrorType())
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Item retrieved",
                zap.String("itemId", result.ItemID),
                zap.String("institutionId", result.InstitutionID),
        )

        return result, nil</span>
}

// InstitutionInfo holds institution details
type InstitutionInfo struct {
        InstitutionID string
        Name          string
        Products      []string
        CountryCodes  []string
        URL           string
        PrimaryColor  string
        Logo          string
}

// GetInstitution retrieves institution details by ID
func (c *PlaidClient) GetInstitution(ctx context.Context, institutionID string) (*InstitutionInfo, error) <span class="cov0" title="0">{
        c.logger.Debug("Getting institution", zap.String("institutionId", institutionID))

        request := plaid.NewInstitutionsGetByIdRequest(institutionID, c.countryCodes)

        response, httpResp, err := c.client.PlaidApi.InstitutionsGetById(ctx).InstitutionsGetByIdRequest(*request).Execute()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get institution", zap.Error(err))
                return nil, fmt.Errorf("failed to get institution: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = httpResp.Body.Close() }</span>()

        <span class="cov0" title="0">inst := response.GetInstitution()
        result := &amp;InstitutionInfo{
                InstitutionID: inst.GetInstitutionId(),
                Name:          inst.GetName(),
                Products:      []string{},
                CountryCodes:  []string{},
                URL:           inst.GetUrl(),
                PrimaryColor:  inst.GetPrimaryColor(),
                Logo:          inst.GetLogo(),
        }

        for _, p := range inst.GetProducts() </span><span class="cov0" title="0">{
                result.Products = append(result.Products, string(p))
        }</span>
        <span class="cov0" title="0">for _, c := range inst.GetCountryCodes() </span><span class="cov0" title="0">{
                result.CountryCodes = append(result.CountryCodes, string(c))
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Institution retrieved", zap.String("name", result.Name))

        return result, nil</span>
}

// Account holds account information
type Account struct {
        AccountID    string
        Name         string
        Mask         string
        Type         string
        Subtype      string
        OfficialName string
        Balances     AccountBalances
}

// AccountBalances holds account balance information
type AccountBalances struct {
        Current     float64
        Available   *float64
        Limit       *float64
        IsoCurrency string
}

// GetAccounts retrieves accounts for an item
func (c *PlaidClient) GetAccounts(ctx context.Context, accessToken string) ([]Account, error) <span class="cov0" title="0">{
        c.logger.Debug("Getting accounts")

        request := plaid.NewAccountsGetRequest(accessToken)

        response, httpResp, err := c.client.PlaidApi.AccountsGet(ctx).AccountsGetRequest(*request).Execute()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get accounts", zap.Error(err))
                return nil, fmt.Errorf("failed to get accounts: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = httpResp.Body.Close() }</span>()

        <span class="cov0" title="0">accounts := []Account{}
        for _, acc := range response.GetAccounts() </span><span class="cov0" title="0">{
                account := Account{
                        AccountID:    acc.GetAccountId(),
                        Name:         acc.GetName(),
                        Mask:         acc.GetMask(),
                        Type:         string(acc.GetType()),
                        Subtype:      string(acc.GetSubtype()),
                        OfficialName: acc.GetOfficialName(),
                        Balances: AccountBalances{
                                Current:     acc.Balances.GetCurrent(),
                                IsoCurrency: acc.Balances.GetIsoCurrencyCode(),
                        },
                }

                if available := acc.Balances.GetAvailable(); available != 0 </span><span class="cov0" title="0">{
                        account.Balances.Available = &amp;available
                }</span>
                <span class="cov0" title="0">if limit := acc.Balances.GetLimit(); limit != 0 </span><span class="cov0" title="0">{
                        account.Balances.Limit = &amp;limit
                }</span>

                <span class="cov0" title="0">accounts = append(accounts, account)</span>
        }

        <span class="cov0" title="0">c.logger.Debug("Accounts retrieved", zap.Int("count", len(accounts)))

        return accounts, nil</span>
}

// Transaction holds transaction information
type Transaction struct {
        TransactionID           string
        AccountID               string
        Amount                  float64
        IsoCurrency             string
        Date                    string
        AuthorizedDate          *string
        Name                    string
        MerchantName            *string
        Pending                 bool
        Category                []string
        PersonalFinanceCategory *string
}

// SyncTransactionsRequest holds parameters for transaction sync
type SyncTransactionsRequest struct {
        AccessToken string
        Cursor      *string
}

// SyncTransactionsResponse holds the sync result
type SyncTransactionsResponse struct {
        Added      []Transaction
        Modified   []Transaction
        Removed    []RemovedTransaction
        NextCursor string
        HasMore    bool
}

// RemovedTransaction holds information about removed transactions
type RemovedTransaction struct {
        TransactionID string
}

// SyncTransactions fetches transactions using the sync endpoint
func (c *PlaidClient) SyncTransactions(ctx context.Context, req SyncTransactionsRequest) (*SyncTransactionsResponse, error) <span class="cov0" title="0">{
        c.logger.Debug("Syncing transactions", zap.Bool("hasCursor", req.Cursor != nil))

        request := plaid.NewTransactionsSyncRequest(req.AccessToken)
        if req.Cursor != nil &amp;&amp; *req.Cursor != "" </span><span class="cov0" title="0">{
                request.SetCursor(*req.Cursor)
        }</span>

        <span class="cov0" title="0">response, httpResp, err := c.client.PlaidApi.TransactionsSync(ctx).TransactionsSyncRequest(*request).Execute()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to sync transactions", zap.Error(err))
                return nil, fmt.Errorf("failed to sync transactions: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = httpResp.Body.Close() }</span>()

        <span class="cov0" title="0">result := &amp;SyncTransactionsResponse{
                Added:      []Transaction{},
                Modified:   []Transaction{},
                Removed:    []RemovedTransaction{},
                NextCursor: response.GetNextCursor(),
                HasMore:    response.GetHasMore(),
        }

        // Process added transactions
        for _, txn := range response.GetAdded() </span><span class="cov0" title="0">{
                transaction := Transaction{
                        TransactionID: txn.GetTransactionId(),
                        AccountID:     txn.GetAccountId(),
                        Amount:        txn.GetAmount(),
                        IsoCurrency:   txn.GetIsoCurrencyCode(),
                        Date:          txn.GetDate(),
                        Name:          txn.GetName(),
                        Pending:       txn.GetPending(),
                        Category:      txn.GetCategory(),
                }

                if authDate := txn.GetAuthorizedDate(); authDate != "" </span><span class="cov0" title="0">{
                        transaction.AuthorizedDate = &amp;authDate
                }</span>
                <span class="cov0" title="0">if merchantName := txn.GetMerchantName(); merchantName != "" </span><span class="cov0" title="0">{
                        transaction.MerchantName = &amp;merchantName
                }</span>
                <span class="cov0" title="0">if txn.PersonalFinanceCategory.IsSet() &amp;&amp; txn.PersonalFinanceCategory.Get() != nil </span><span class="cov0" title="0">{
                        pfc := txn.PersonalFinanceCategory.Get()
                        pfcStr := pfc.GetPrimary()
                        transaction.PersonalFinanceCategory = &amp;pfcStr
                }</span>

                <span class="cov0" title="0">result.Added = append(result.Added, transaction)</span>
        }

        // Process modified transactions
        <span class="cov0" title="0">for _, txn := range response.GetModified() </span><span class="cov0" title="0">{
                transaction := Transaction{
                        TransactionID: txn.GetTransactionId(),
                        AccountID:     txn.GetAccountId(),
                        Amount:        txn.GetAmount(),
                        IsoCurrency:   txn.GetIsoCurrencyCode(),
                        Date:          txn.GetDate(),
                        Name:          txn.GetName(),
                        Pending:       txn.GetPending(),
                        Category:      txn.GetCategory(),
                }

                if authDate := txn.GetAuthorizedDate(); authDate != "" </span><span class="cov0" title="0">{
                        transaction.AuthorizedDate = &amp;authDate
                }</span>
                <span class="cov0" title="0">if merchantName := txn.GetMerchantName(); merchantName != "" </span><span class="cov0" title="0">{
                        transaction.MerchantName = &amp;merchantName
                }</span>

                <span class="cov0" title="0">result.Modified = append(result.Modified, transaction)</span>
        }

        // Process removed transactions
        <span class="cov0" title="0">for _, removed := range response.GetRemoved() </span><span class="cov0" title="0">{
                result.Removed = append(result.Removed, RemovedTransaction{
                        TransactionID: removed.GetTransactionId(),
                })
        }</span>

        <span class="cov0" title="0">c.logger.Info("Transactions synced",
                zap.Int("added", len(result.Added)),
                zap.Int("modified", len(result.Modified)),
                zap.Int("removed", len(result.Removed)),
                zap.Bool("hasMore", result.HasMore),
        )

        return result, nil</span>
}

// RemoveItem removes a Plaid item (disconnects bank)
func (c *PlaidClient) RemoveItem(ctx context.Context, accessToken string) error <span class="cov0" title="0">{
        c.logger.Debug("Removing Plaid item")

        request := plaid.NewItemRemoveRequest(accessToken)

        _, httpResp, err := c.client.PlaidApi.ItemRemove(ctx).ItemRemoveRequest(*request).Execute()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to remove item", zap.Error(err))
                return fmt.Errorf("failed to remove item: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = httpResp.Body.Close() }</span>()

        <span class="cov0" title="0">c.logger.Info("Item removed")

        return nil</span>
}

// VerifyWebhook verifies a Plaid webhook signature
func (c *PlaidClient) VerifyWebhook(_ []byte, _ string) (bool, error) <span class="cov0" title="0">{
        // Note: Plaid webhook verification is done via JWT validation
        // This is a placeholder - actual implementation would use plaid.VerifyWebhookSignature
        c.logger.Debug("Verifying webhook signature")

        // For now, return true - implement JWT verification in production
        // See: https://plaid.com/docs/api/webhooks/webhook-verification/
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package clients

import (
        "context"
        "sync"
        "time"
)

// RateLimiter implements token bucket rate limiting
type RateLimiter struct {
        requestsPerMinute int
        tokensPerMinute   int

        requestTokens int
        aiTokens      int
        lastRefill    time.Time

        mu sync.Mutex
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(requestsPerMinute, tokensPerMinute int) *RateLimiter <span class="cov8" title="1">{
        return &amp;RateLimiter{
                requestsPerMinute: requestsPerMinute,
                tokensPerMinute:   tokensPerMinute,
                requestTokens:     requestsPerMinute,
                aiTokens:          tokensPerMinute,
                lastRefill:        time.Now(),
        }
}</span>

// WaitForRequest waits until a request can be made
func (r *RateLimiter) WaitForRequest(ctx context.Context) error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                r.mu.Lock()

                // Refill tokens based on time elapsed
                r.refillTokens()

                // Check if we have request tokens available
                if r.requestTokens &gt; 0 </span><span class="cov8" title="1">{
                        r.requestTokens--
                        r.mu.Unlock()
                        return nil
                }</span>

                // Calculate wait time
                <span class="cov8" title="1">waitTime := r.calculateWaitTime()
                r.mu.Unlock()

                // Wait for tokens to refill
                select </span>{
                case &lt;-time.After(waitTime):<span class="cov0" title="0">
                        continue</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                }
        }
}

// RecordTokens records AI tokens used
func (r *RateLimiter) RecordTokens(tokens int) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.aiTokens -= tokens
        if r.aiTokens &lt; 0 </span><span class="cov8" title="1">{
                r.aiTokens = 0
        }</span>
}

// refillTokens refills the token buckets based on elapsed time
func (r *RateLimiter) refillTokens() <span class="cov8" title="1">{
        now := time.Now()
        elapsed := now.Sub(r.lastRefill)

        if elapsed &lt; time.Second </span><span class="cov8" title="1">{
                return
        }</span>

        // Calculate tokens to add (proportional to time elapsed)
        <span class="cov8" title="1">secondsElapsed := elapsed.Seconds()

        // Refill request tokens
        requestTokensToAdd := int(secondsElapsed * float64(r.requestsPerMinute) / 60.0)
        r.requestTokens += requestTokensToAdd
        if r.requestTokens &gt; r.requestsPerMinute </span><span class="cov8" title="1">{
                r.requestTokens = r.requestsPerMinute
        }</span>

        // Refill AI tokens
        <span class="cov8" title="1">aiTokensToAdd := int(secondsElapsed * float64(r.tokensPerMinute) / 60.0)
        r.aiTokens += aiTokensToAdd
        if r.aiTokens &gt; r.tokensPerMinute </span><span class="cov8" title="1">{
                r.aiTokens = r.tokensPerMinute
        }</span>

        <span class="cov8" title="1">r.lastRefill = now</span>
}

// calculateWaitTime calculates how long to wait for tokens
func (r *RateLimiter) calculateWaitTime() time.Duration <span class="cov8" title="1">{
        // Wait for 1 second worth of tokens
        return time.Second
}</span>

// GetStats returns current rate limiter stats
func (r *RateLimiter) GetStats() (requestTokens, aiTokens int) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.refillTokens()
        return r.requestTokens, r.aiTokens
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package clients

import (
        "fmt"

        "github.com/stripe/stripe-go/v76"
        billingportal "github.com/stripe/stripe-go/v76/billingportal/session"
        checkout "github.com/stripe/stripe-go/v76/checkout/session"
        "github.com/stripe/stripe-go/v76/customer"
        "github.com/stripe/stripe-go/v76/invoice"
        "github.com/stripe/stripe-go/v76/paymentmethod"
        sub "github.com/stripe/stripe-go/v76/subscription"
        "github.com/stripe/stripe-go/v76/webhook"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/config"
)

// StripeClient wraps the Stripe API client
type StripeClient struct {
        secretKey     string
        webhookSecret string
        proPriceID    string
        successURL    string
        cancelURL     string
        logger        *zap.Logger
}

// NewStripeClient creates a new Stripe client
func NewStripeClient(cfg *config.StripeConfig, logger *zap.Logger) (*StripeClient, error) <span class="cov8" title="1">{
        if cfg.SecretKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Stripe secret key is required")
        }</span>

        // Set API key globally for stripe-go library
        <span class="cov8" title="1">stripe.Key = cfg.SecretKey

        return &amp;StripeClient{
                secretKey:     cfg.SecretKey,
                webhookSecret: cfg.WebhookSecret,
                proPriceID:    cfg.ProPriceID,
                successURL:    cfg.SuccessURL,
                cancelURL:     cfg.CancelURL,
                logger:        logger,
        }, nil</span>
}

// CreateCheckoutSession creates a Stripe Checkout session for subscription
func (c *StripeClient) CreateCheckoutSession(customerEmail string, successURL, cancelURL string) (*stripe.CheckoutSession, error) <span class="cov0" title="0">{
        // Use configured URLs if not provided
        if successURL == "" </span><span class="cov0" title="0">{
                successURL = c.successURL
        }</span>
        <span class="cov0" title="0">if cancelURL == "" </span><span class="cov0" title="0">{
                cancelURL = c.cancelURL
        }</span>

        <span class="cov0" title="0">params := &amp;stripe.CheckoutSessionParams{
                Mode: stripe.String(string(stripe.CheckoutSessionModeSubscription)),
                LineItems: []*stripe.CheckoutSessionLineItemParams{
                        {
                                Price:    stripe.String(c.proPriceID),
                                Quantity: stripe.Int64(1),
                        },
                },
                SuccessURL: stripe.String(successURL),
                CancelURL:  stripe.String(cancelURL),
        }

        // Add customer email if provided
        if customerEmail != "" </span><span class="cov0" title="0">{
                params.CustomerEmail = stripe.String(customerEmail)
        }</span>

        // Allow promotion codes
        <span class="cov0" title="0">params.AllowPromotionCodes = stripe.Bool(true)

        // Add metadata
        params.AddMetadata("source", "focus-notebook-backend")

        c.logger.Debug("Creating Stripe checkout session",
                zap.String("priceId", c.proPriceID),
                zap.String("customerEmail", customerEmail),
        )

        session, err := checkout.New(params)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to create checkout session", zap.Error(err))
                return nil, fmt.Errorf("failed to create checkout session: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Checkout session created",
                zap.String("sessionId", session.ID),
                zap.String("customerEmail", customerEmail),
        )

        return session, nil</span>
}

// CreatePortalSession creates a Stripe billing portal session
func (c *StripeClient) CreatePortalSession(customerID string, returnURL string) (*stripe.BillingPortalSession, error) <span class="cov0" title="0">{
        if customerID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("customer ID is required")
        }</span>

        <span class="cov0" title="0">params := &amp;stripe.BillingPortalSessionParams{
                Customer:  stripe.String(customerID),
                ReturnURL: stripe.String(returnURL),
        }

        c.logger.Debug("Creating billing portal session",
                zap.String("customerId", customerID),
        )

        session, err := billingportal.New(params)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to create portal session", zap.Error(err))
                return nil, fmt.Errorf("failed to create portal session: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Portal session created",
                zap.String("sessionId", session.ID),
                zap.String("customerId", customerID),
        )

        return session, nil</span>
}

// GetCustomer retrieves a Stripe customer by ID
func (c *StripeClient) GetCustomer(customerID string) (*stripe.Customer, error) <span class="cov0" title="0">{
        cust, err := customer.Get(customerID, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get customer", zap.Error(err), zap.String("customerId", customerID))
                return nil, fmt.Errorf("failed to get customer: %w", err)
        }</span>

        <span class="cov0" title="0">return cust, nil</span>
}

// GetSubscription retrieves a Stripe subscription by ID
func (c *StripeClient) GetSubscription(subscriptionID string) (*stripe.Subscription, error) <span class="cov0" title="0">{
        subscription, err := sub.Get(subscriptionID, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get subscription", zap.Error(err), zap.String("subscriptionId", subscriptionID))
                return nil, fmt.Errorf("failed to get subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return subscription, nil</span>
}

// ListInvoices retrieves invoices for a customer
func (c *StripeClient) ListInvoices(customerID string, limit int64) ([]*stripe.Invoice, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">params := &amp;stripe.InvoiceListParams{
                Customer: stripe.String(customerID),
        }
        params.Filters.AddFilter("limit", "", fmt.Sprintf("%d", limit))

        c.logger.Debug("Listing invoices",
                zap.String("customerId", customerID),
                zap.Int64("limit", limit),
        )

        var invoices []*stripe.Invoice
        iter := invoice.List(params)
        for iter.Next() </span><span class="cov0" title="0">{
                invoices = append(invoices, iter.Invoice())
        }</span>

        <span class="cov0" title="0">if err := iter.Err(); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to list invoices", zap.Error(err))
                return nil, fmt.Errorf("failed to list invoices: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Invoices retrieved",
                zap.String("customerId", customerID),
                zap.Int("count", len(invoices)),
        )

        return invoices, nil</span>
}

// GetPaymentMethod retrieves the default payment method for a customer
func (c *StripeClient) GetPaymentMethod(customerID string) (*stripe.PaymentMethod, error) <span class="cov0" title="0">{
        cust, err := c.GetCustomer(customerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if cust.InvoiceSettings == nil || cust.InvoiceSettings.DefaultPaymentMethod == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no default payment method found")
        }</span>

        <span class="cov0" title="0">paymentMethodID := cust.InvoiceSettings.DefaultPaymentMethod.ID

        pm, err := paymentmethod.Get(paymentMethodID, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get payment method", zap.Error(err))
                return nil, fmt.Errorf("failed to get payment method: %w", err)
        }</span>

        <span class="cov0" title="0">return pm, nil</span>
}

// CancelSubscription cancels a subscription at period end
func (c *StripeClient) CancelSubscription(subscriptionID string, cancelAtPeriodEnd bool) (*stripe.Subscription, error) <span class="cov0" title="0">{
        params := &amp;stripe.SubscriptionParams{
                CancelAtPeriodEnd: stripe.Bool(cancelAtPeriodEnd),
        }

        subscription, err := sub.Update(subscriptionID, params)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to cancel subscription", zap.Error(err))
                return nil, fmt.Errorf("failed to cancel subscription: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Subscription cancel scheduled",
                zap.String("subscriptionId", subscriptionID),
                zap.Bool("cancelAtPeriodEnd", cancelAtPeriodEnd),
        )

        return subscription, nil</span>
}

// ReactivateSubscription reactivates a canceled subscription
func (c *StripeClient) ReactivateSubscription(subscriptionID string) (*stripe.Subscription, error) <span class="cov0" title="0">{
        params := &amp;stripe.SubscriptionParams{
                CancelAtPeriodEnd: stripe.Bool(false),
        }

        subscription, err := sub.Update(subscriptionID, params)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to reactivate subscription", zap.Error(err))
                return nil, fmt.Errorf("failed to reactivate subscription: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Subscription reactivated",
                zap.String("subscriptionId", subscriptionID),
        )

        return subscription, nil</span>
}

// ConstructWebhookEvent constructs and verifies a webhook event
func (c *StripeClient) ConstructWebhookEvent(payload []byte, signature string) (stripe.Event, error) <span class="cov0" title="0">{
        if c.webhookSecret == "" </span><span class="cov0" title="0">{
                return stripe.Event{}, fmt.Errorf("webhook secret not configured")
        }</span>

        <span class="cov0" title="0">event, err := webhook.ConstructEvent(payload, signature, c.webhookSecret)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to verify webhook signature", zap.Error(err))
                return stripe.Event{}, fmt.Errorf("failed to verify webhook: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Webhook event verified",
                zap.String("type", string(event.Type)),
                zap.String("eventId", event.ID),
        )

        return event, nil</span>
}

// GetProPriceID returns the configured Pro tier price ID
func (c *StripeClient) GetProPriceID() string <span class="cov8" title="1">{
        return c.proPriceID
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "fmt"
        "os"
        "time"

        "gopkg.in/yaml.v3"
)

// Config holds the application configuration
type Config struct {
        Server       ServerConfig       `yaml:"server"`
        Firebase     FirebaseConfig     `yaml:"firebase"`
        OpenAI       OpenAIConfig       `yaml:"openai"`
        Anthropic    AnthropicConfig    `yaml:"anthropic"`
        Stripe       StripeConfig       `yaml:"stripe"`
        Plaid        PlaidConfig        `yaml:"plaid"`
        AlphaVantage AlphaVantageConfig `yaml:"alpha_vantage"`
        Anonymous    AnonymousConfig    `yaml:"anonymous"`
        Logging      LoggingConfig      `yaml:"logging"`
        Metrics      MetricsConfig      `yaml:"metrics"`
        Workers      WorkersConfig      `yaml:"workers"`
        RateLimit    RateLimitConfig    `yaml:"rate_limit"`
        Upload       UploadConfig       `yaml:"upload"`
        Cache        CacheConfig        `yaml:"cache"`
        Retry        RetryConfig        `yaml:"retry"`
        Health       HealthConfig       `yaml:"health"`
        Development  DevelopmentConfig  `yaml:"development"`
}

type ServerConfig struct {
        Port           int           `yaml:"port"`
        Host           string        `yaml:"host"`
        ReadTimeout    time.Duration `yaml:"read_timeout"`
        WriteTimeout   time.Duration `yaml:"write_timeout"`
        IdleTimeout    time.Duration `yaml:"idle_timeout"`
        MaxHeaderBytes int           `yaml:"max_header_bytes"`
        CORS           CORSConfig    `yaml:"cors"`
}

type CORSConfig struct {
        Enabled          bool     `yaml:"enabled"`
        AllowedOrigins   []string `yaml:"allowed_origins"`
        AllowedMethods   []string `yaml:"allowed_methods"`
        AllowedHeaders   []string `yaml:"allowed_headers"`
        ExposeHeaders    []string `yaml:"expose_headers"`
        AllowCredentials bool     `yaml:"allow_credentials"`
        MaxAge           int      `yaml:"max_age"`
}

type FirebaseConfig struct {
        ProjectID       string `yaml:"project_id"`
        CredentialsPath string `yaml:"credentials_path"`
        StorageBucket   string `yaml:"storage_bucket"`
        DatabaseID      string `yaml:"database_id"`
}

type OpenAIConfig struct {
        APIKey       string        `yaml:"api_key"`
        DefaultModel string        `yaml:"default_model"`
        MaxTokens    int           `yaml:"max_tokens"`
        Temperature  float32       `yaml:"temperature"`
        Timeout      time.Duration `yaml:"timeout"`
        RateLimit    struct {
                RequestsPerMinute int `yaml:"requests_per_minute"`
                TokensPerMinute   int `yaml:"tokens_per_minute"`
        } `yaml:"rate_limit"`
}

type AnthropicConfig struct {
        APIKey       string        `yaml:"api_key"`
        DefaultModel string        `yaml:"default_model"`
        MaxTokens    int           `yaml:"max_tokens"`
        Timeout      time.Duration `yaml:"timeout"`
        RateLimit    struct {
                RequestsPerMinute int `yaml:"requests_per_minute"`
        } `yaml:"rate_limit"`
}

type StripeConfig struct {
        SecretKey     string `yaml:"secret_key"`
        WebhookSecret string `yaml:"webhook_secret"`
        APIVersion    string `yaml:"api_version"`
        ProPriceID    string `yaml:"pro_price_id"`
        SuccessURL    string `yaml:"success_url"`
        CancelURL     string `yaml:"cancel_url"`
}

type PlaidConfig struct {
        ClientID     string   `yaml:"client_id"`
        Secret       string   `yaml:"secret"`
        Environment  string   `yaml:"environment"`
        Products     []string `yaml:"products"`
        CountryCodes []string `yaml:"country_codes"`
        WebhookURL   string   `yaml:"webhook_url"`
}

type AlphaVantageConfig struct {
        APIKey    string        `yaml:"api_key"`
        Timeout   time.Duration `yaml:"timeout"`
        RateLimit struct {
                RequestsPerMinute int `yaml:"requests_per_minute"`
        } `yaml:"rate_limit"`
}

type AnonymousConfig struct {
        SessionDuration time.Duration `yaml:"session_duration"`
        AIOverrideKey   string        `yaml:"ai_override_key"`
        CleanupInterval time.Duration `yaml:"cleanup_interval"`
}

type LoggingConfig struct {
        Level            string `yaml:"level"`
        Format           string `yaml:"format"`
        Output           string `yaml:"output"`
        EnableStacktrace bool   `yaml:"enable_stacktrace"`
        Development      bool   `yaml:"development"`
}

type MetricsConfig struct {
        Enabled bool   `yaml:"enabled"`
        Path    string `yaml:"path"`
        Port    int    `yaml:"port"`
}

type WorkersConfig struct {
        Enabled           bool             `yaml:"enabled"`
        ThoughtQueue      WorkerConfig     `yaml:"thought_queue"`
        AnonymousCleanup  WorkerConfig     `yaml:"anonymous_cleanup"`
        StockPrices       WorkerConfig     `yaml:"stock_prices"`
        PortfolioSnapshot CronWorkerConfig `yaml:"portfolio_snapshot"`
        VisaDataUpdate    CronWorkerConfig `yaml:"visa_data_update"`
}

type WorkerConfig struct {
        Enabled    bool          `yaml:"enabled"`
        Interval   time.Duration `yaml:"interval"`
        BatchSize  int           `yaml:"batch_size"`
        MaxRetries int           `yaml:"max_retries"`
}

type CronWorkerConfig struct {
        Enabled bool   `yaml:"enabled"`
        Cron    string `yaml:"cron"`
}

type RateLimitConfig struct {
        Enabled           bool `yaml:"enabled"`
        RequestsPerMinute int  `yaml:"requests_per_minute"`
        Burst             int  `yaml:"burst"`
        PerUser           struct {
                FreeTier int `yaml:"free_tier"`
                ProTier  int `yaml:"pro_tier"`
        } `yaml:"per_user"`
}

type UploadConfig struct {
        MaxFileSize  int64               `yaml:"max_file_size"`
        AllowedTypes map[string][]string `yaml:"allowed_types"`
}

type CacheConfig struct {
        Enabled      bool          `yaml:"enabled"`
        TTL          time.Duration `yaml:"ttl"`
        MaxEntries   int           `yaml:"max_entries"`
        Subscription struct {
                TTL        time.Duration `yaml:"ttl"`
                MaxEntries int           `yaml:"max_entries"`
        } `yaml:"subscription"`
}

type RetryConfig struct {
        MaxAttempts    int           `yaml:"max_attempts"`
        InitialBackoff time.Duration `yaml:"initial_backoff"`
        MaxBackoff     time.Duration `yaml:"max_backoff"`
        Multiplier     float64       `yaml:"multiplier"`
        RetryableCodes []int         `yaml:"retryable_codes"`
}

type HealthConfig struct {
        Enabled bool          `yaml:"enabled"`
        Path    string        `yaml:"path"`
        Timeout time.Duration `yaml:"timeout"`
        Checks  struct {
                Firebase bool `yaml:"firebase"`
                OpenAI   bool `yaml:"openai"`
                Stripe   bool `yaml:"stripe"`
                Plaid    bool `yaml:"plaid"`
        } `yaml:"checks"`
}

type DevelopmentConfig struct {
        Enabled     bool `yaml:"enabled"`
        DebugRoutes bool `yaml:"debug_routes"`
        PrettyLogs  bool `yaml:"pretty_logs"`
        DisableAuth bool `yaml:"disable_auth"`
}

// Load reads and parses the configuration file
func Load(path string) (*Config, error) <span class="cov8" title="1">{
        // Read file
        // #nosec G304 -- path comes from command-line arg, not user input
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Expand environment variables
        <span class="cov8" title="1">expanded := os.ExpandEnv(string(data))

        // Parse YAML
        var cfg Config
        if err := yaml.Unmarshal([]byte(expanded), &amp;cfg); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        // Validate
        <span class="cov8" title="1">if err := cfg.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// Validate checks if the configuration is valid
func (c *Config) Validate() error <span class="cov8" title="1">{
        // Firebase validation
        if c.Firebase.ProjectID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("firebase.project_id is required")
        }</span>
        <span class="cov8" title="1">if c.Firebase.CredentialsPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("firebase.credentials_path is required")
        }</span>

        // Server validation
        <span class="cov8" title="1">if c.Server.Port &lt;= 0 || c.Server.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("server.port must be between 1 and 65535")
        }</span>

        // OpenAI validation (optional)
        <span class="cov8" title="1">if c.OpenAI.APIKey != "" &amp;&amp; c.OpenAI.DefaultModel == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("openai.default_model is required when api_key is set")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetServerAddr returns the full server address
func (c *Config) GetServerAddr() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>

// GetMetricsAddr returns the metrics server address
func (c *Config) GetMetricsAddr() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Metrics.Port)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "net/http"
        "strings"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// AnalyticsHandler handles analytics requests
type AnalyticsHandler struct {
        dashboardSvc *services.DashboardAnalyticsService
        spendingSvc  *services.SpendingAnalyticsService
        logger       *zap.Logger
}

// NewAnalyticsHandler creates a new analytics handler
func NewAnalyticsHandler(dashboardSvc *services.DashboardAnalyticsService, spendingSvc *services.SpendingAnalyticsService, logger *zap.Logger) *AnalyticsHandler <span class="cov8" title="1">{
        return &amp;AnalyticsHandler{
                dashboardSvc: dashboardSvc,
                spendingSvc:  spendingSvc,
                logger:       logger,
        }
}</span>

// GetDashboardAnalytics returns dashboard analytics for a user
// GET /api/analytics/dashboard?period=today|week|month
func (h *AnalyticsHandler) GetDashboardAnalytics(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Get period from query params (default to today)
        periodStr := r.URL.Query().Get("period")
        if periodStr == "" </span><span class="cov8" title="1">{
                periodStr = "today"
        }</span>

        // Validate period
        <span class="cov8" title="1">var period services.SummaryPeriod
        switch periodStr </span>{
        case "today":<span class="cov8" title="1">
                period = services.PeriodToday</span>
        case "week":<span class="cov8" title="1">
                period = services.PeriodWeek</span>
        case "month":<span class="cov8" title="1">
                period = services.PeriodMonth</span>
        default:<span class="cov8" title="1">
                utils.RespondError(w, "Invalid period. Must be 'today', 'week', or 'month'", http.StatusBadRequest)
                return</span>
        }

        <span class="cov8" title="1">h.logger.Debug("GetDashboardAnalytics request",
                zap.String("uid", uid),
                zap.String("period", periodStr),
        )

        // Compute analytics
        analytics, err := h.dashboardSvc.ComputeAnalytics(ctx, uid, period)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to compute dashboard analytics", zap.Error(err))
                utils.RespondError(w, "Failed to compute analytics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondSuccess(w, analytics, "Dashboard analytics retrieved")</span>
}

// GetSpendingAnalytics returns spending analytics for a user
// GET /api/analytics/spending?startDate=YYYY-MM-DD&amp;endDate=YYYY-MM-DD&amp;accountIds=id1,id2
func (h *AnalyticsHandler) GetSpendingAnalytics(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Get query parameters
        startDate := r.URL.Query().Get("startDate")
        endDate := r.URL.Query().Get("endDate")
        accountIDsStr := r.URL.Query().Get("accountIds")

        // Validate required parameters
        if startDate == "" </span><span class="cov8" title="1">{
                utils.RespondError(w, "startDate is required (format: YYYY-MM-DD)", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if endDate == "" </span><span class="cov8" title="1">{
                utils.RespondError(w, "endDate is required (format: YYYY-MM-DD)", http.StatusBadRequest)
                return
        }</span>

        // Parse account IDs (optional)
        <span class="cov8" title="1">var accountIDs []string
        if accountIDsStr != "" </span><span class="cov0" title="0">{
                accountIDs = strings.Split(accountIDsStr, ",")
                // Trim whitespace from each ID
                for i := range accountIDs </span><span class="cov0" title="0">{
                        accountIDs[i] = strings.TrimSpace(accountIDs[i])
                }</span>
        }

        <span class="cov8" title="1">h.logger.Debug("GetSpendingAnalytics request",
                zap.String("uid", uid),
                zap.String("startDate", startDate),
                zap.String("endDate", endDate),
                zap.Int("accountCount", len(accountIDs)),
        )

        // Compute spending analytics
        analytics, err := h.spendingSvc.ComputeSpendingAnalytics(ctx, uid, startDate, endDate, accountIDs)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to compute spending analytics", zap.Error(err))
                utils.RespondError(w, "Failed to compute spending analytics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondSuccess(w, analytics, "Spending analytics retrieved")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// ChatHandler handles chat API requests
type ChatHandler struct {
        chatService *services.ChatService
        logger      *zap.Logger
}

// NewChatHandler creates a new chat handler
func NewChatHandler(chatService *services.ChatService, logger *zap.Logger) *ChatHandler <span class="cov8" title="1">{
        return &amp;ChatHandler{
                chatService: chatService,
                logger:      logger,
        }
}</span>

// ChatRequest represents the request to the chat endpoint
type ChatRequest struct {
        Messages    []services.ChatMessage `json:"messages"`
        Model       string                 `json:"model,omitempty"`
        Temperature float32                `json:"temperature,omitempty"`
}

// ChatResponsePayload represents the full response payload
type ChatResponsePayload struct {
        Message      services.ChatMessage `json:"message"`
        Model        string               `json:"model"`
        TokensUsed   int                  `json:"tokensUsed,omitempty"`
        FinishReason string               `json:"finishReason,omitempty"`
}

// Chat handles POST /api/chat
func (h *ChatHandler) Chat(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req ChatRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if len(req.Messages) == 0 </span><span class="cov0" title="0">{
                utils.WriteError(w, "messages array cannot be empty", http.StatusBadRequest)
                return
        }</span>

        // Default temperature to 0.7 if not specified
        <span class="cov0" title="0">temperature := req.Temperature
        if temperature == 0 </span><span class="cov0" title="0">{
                temperature = 0.7
        }</span>

        // Validate temperature range
        <span class="cov0" title="0">if temperature &lt; 0 || temperature &gt; 2 </span><span class="cov0" title="0">{
                utils.WriteError(w, "temperature must be between 0 and 2", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Processing chat request",
                zap.String("uid", userID),
                zap.String("model", req.Model),
                zap.Int("messageCount", len(req.Messages)),
                zap.Float32("temperature", temperature),
        )

        // Process chat
        response, err := h.chatService.Chat(ctx, req.Messages, req.Model, temperature)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to process chat",
                        zap.String("uid", userID),
                        zap.Error(err),
                )

                // Return user-friendly error message
                utils.WriteJSON(w, map[string]interface{}{
                        "error":   "AI service error",
                        "message": "Oops! Something went wrong with the AI service. Let's try that again!",
                }, http.StatusOK) // Return 200 to avoid triggering error UI
                return
        }</span>

        // Return successful response
        <span class="cov0" title="0">payload := ChatResponsePayload{
                Message:      response.Message,
                Model:        response.Model,
                TokensUsed:   response.TokensUsed,
                FinishReason: response.FinishReason,
        }

        utils.WriteJSON(w, payload, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/gorilla/mux"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// EntityGraphHandler handles entity graph requests
type EntityGraphHandler struct {
        svc    *services.EntityGraphService
        logger *zap.Logger
}

// NewEntityGraphHandler creates a new entity graph handler
func NewEntityGraphHandler(svc *services.EntityGraphService, logger *zap.Logger) *EntityGraphHandler <span class="cov8" title="1">{
        return &amp;EntityGraphHandler{
                svc:    svc,
                logger: logger,
        }
}</span>

// QueryRelationships queries relationships with filters
// GET /api/entity-graph/relationships?sourceType=task&amp;sourceId=123&amp;limit=50
// POST /api/entity-graph/relationships/query (for complex filters)
func (h *EntityGraphHandler) QueryRelationships(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        var filters services.RelationshipFilters

        // Support both GET with query params and POST with JSON body
        if r.Method == "POST" </span><span class="cov8" title="1">{
                if err := json.NewDecoder(r.Body).Decode(&amp;filters); err != nil </span><span class="cov0" title="0">{
                        utils.RespondError(w, "Invalid request body", http.StatusBadRequest)
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                // Parse query parameters
                filters = h.parseFiltersFromQuery(r)
        }</span>

        <span class="cov8" title="1">h.logger.Debug("QueryRelationships request",
                zap.String("uid", uid),
                zap.Int("limit", filters.Limit),
        )

        // Query relationships
        relationships, totalCount, err := h.svc.QueryRelationships(ctx, uid, filters)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to query relationships", zap.Error(err))
                utils.RespondError(w, "Failed to query relationships", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondSuccess(w, map[string]interface{}{
                "relationships": relationships,
                "total":         totalCount,
                "limit":         filters.Limit,
                "offset":        filters.Offset,
        }, "Relationships retrieved")</span>
}

// parseFiltersFromQuery parses relationship filters from query parameters
func (h *EntityGraphHandler) parseFiltersFromQuery(r *http.Request) services.RelationshipFilters <span class="cov8" title="1">{
        filters := services.RelationshipFilters{}

        if sourceType := r.URL.Query().Get("sourceType"); sourceType != "" </span><span class="cov8" title="1">{
                et := services.EntityType(sourceType)
                filters.SourceType = &amp;et
        }</span>
        <span class="cov8" title="1">if sourceID := r.URL.Query().Get("sourceId"); sourceID != "" </span><span class="cov0" title="0">{
                filters.SourceID = &amp;sourceID
        }</span>
        <span class="cov8" title="1">if targetType := r.URL.Query().Get("targetType"); targetType != "" </span><span class="cov0" title="0">{
                et := services.EntityType(targetType)
                filters.TargetType = &amp;et
        }</span>
        <span class="cov8" title="1">if targetID := r.URL.Query().Get("targetId"); targetID != "" </span><span class="cov0" title="0">{
                filters.TargetID = &amp;targetID
        }</span>
        <span class="cov8" title="1">if relType := r.URL.Query().Get("relationshipType"); relType != "" </span><span class="cov0" title="0">{
                rt := services.RelationshipType(relType)
                filters.RelationshipType = &amp;rt
        }</span>
        <span class="cov8" title="1">if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filters.Status = &amp;status
        }</span>
        <span class="cov8" title="1">if createdBy := r.URL.Query().Get("createdBy"); createdBy != "" </span><span class="cov0" title="0">{
                filters.CreatedBy = &amp;createdBy
        }</span>

        // Parse numeric filters
        <span class="cov8" title="1">if minStrength := r.URL.Query().Get("minStrength"); minStrength != "" </span><span class="cov0" title="0">{
                if val := parseInt(minStrength, 0); val &gt; 0 </span><span class="cov0" title="0">{
                        filters.MinStrength = &amp;val
                }</span>
        }
        <span class="cov8" title="1">if maxStrength := r.URL.Query().Get("maxStrength"); maxStrength != "" </span><span class="cov0" title="0">{
                if val := parseInt(maxStrength, 100); val &gt; 0 </span><span class="cov0" title="0">{
                        filters.MaxStrength = &amp;val
                }</span>
        }

        // Parse pagination
        <span class="cov8" title="1">filters.Limit = parseInt(r.URL.Query().Get("limit"), 100)
        filters.Offset = parseInt(r.URL.Query().Get("offset"), 0)

        // Parse sorting
        filters.SortBy = r.URL.Query().Get("sortBy")
        filters.SortOrder = r.URL.Query().Get("sortOrder")

        return filters</span>
}

// GetLinkedEntities gets all entities linked to a specific entity
// GET /api/entity-graph/linked/{entityType}/{entityId}
func (h *EntityGraphHandler) GetLinkedEntities(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Get parameters from URL
        vars := mux.Vars(r)
        entityType := services.EntityType(vars["entityType"])
        entityID := vars["entityId"]

        if entityType == "" || entityID == "" </span><span class="cov8" title="1">{
                utils.RespondError(w, "Entity type and ID are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">h.logger.Debug("GetLinkedEntities request",
                zap.String("uid", uid),
                zap.String("entityType", string(entityType)),
                zap.String("entityId", entityID),
        )

        // Get linked entities
        linkedEntities, err := h.svc.GetLinkedEntities(ctx, uid, entityType, entityID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get linked entities", zap.Error(err))
                utils.RespondError(w, "Failed to get linked entities", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondSuccess(w, linkedEntities, "Linked entities retrieved")</span>
}

// GetToolRelationships gets tool-related relationships
// GET /api/entity-graph/tools?toolType=thought-processing
func (h *EntityGraphHandler) GetToolRelationships(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Get optional tool type filter
        var toolType *string
        if tt := r.URL.Query().Get("toolType"); tt != "" </span><span class="cov8" title="1">{
                toolType = &amp;tt
        }</span>

        <span class="cov8" title="1">h.logger.Debug("GetToolRelationships request",
                zap.String("uid", uid),
        )

        // Get tool relationships
        toolRelationships, err := h.svc.GetToolRelationships(ctx, uid, toolType)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get tool relationships", zap.Error(err))
                utils.RespondError(w, "Failed to get tool relationships", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondSuccess(w, toolRelationships, "Tool relationships retrieved")</span>
}

// GetRelationshipStats gets statistics about relationships
// GET /api/entity-graph/stats
func (h *EntityGraphHandler) GetRelationshipStats(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        h.logger.Debug("GetRelationshipStats request",
                zap.String("uid", uid),
        )

        // Get stats
        stats, err := h.svc.GetRelationshipStats(ctx, uid)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get relationship stats", zap.Error(err))
                utils.RespondError(w, "Failed to get relationship stats", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondSuccess(w, stats, "Relationship stats retrieved")</span>
}

// Helper to parse integer from string
func parseInt(s string, defaultVal int) int <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return defaultVal
        }</span>
        <span class="cov8" title="1">var val int
        _, err := fmt.Sscanf(s, "%d", &amp;val)
        if err != nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov8" title="1">return val</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
        "github.com/mesbahtanvir/focus-notebook/backend/pkg/firebase"
)

// HealthHandler handles health check requests
type HealthHandler struct {
        firebase  *firebase.Admin
        startTime time.Time
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(fb *firebase.Admin) *HealthHandler <span class="cov8" title="1">{
        return &amp;HealthHandler{
                firebase:  fb,
                startTime: time.Now(),
        }
}</span>

// Handle processes health check requests
func (h *HealthHandler) Handle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        status := "ok"
        details := make(map[string]interface{})

        // Check Firebase connectivity
        if err := h.firebase.HealthCheck(r.Context()); err != nil </span><span class="cov0" title="0">{
                status = "degraded"
                details["firebase"] = "error"
                details["firebase_error"] = err.Error()
        }</span> else<span class="cov0" title="0"> {
                details["firebase"] = "connected"
        }</span>

        // Add uptime
        <span class="cov0" title="0">uptime := time.Since(h.startTime)
        details["uptime_seconds"] = int64(uptime.Seconds())

        // Add version
        details["version"] = "1.0.0"

        // Overall status
        details["status"] = status

        statusCode := http.StatusOK
        if status != "ok" </span><span class="cov0" title="0">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">utils.RespondJSON(w, details, statusCode)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "encoding/json"
        "io"
        "net/http"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// ImportExportHandler handles import/export requests
type ImportExportHandler struct {
        svc    *services.ImportExportService
        logger *zap.Logger
}

// NewImportExportHandler creates a new import/export handler
func NewImportExportHandler(svc *services.ImportExportService, logger *zap.Logger) *ImportExportHandler <span class="cov8" title="1">{
        return &amp;ImportExportHandler{
                svc:    svc,
                logger: logger,
        }
}</span>

// ValidateImport validates import data and returns conflicts
// POST /api/import/validate
func (h *ImportExportHandler) ValidateImport(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Read uploaded file (max 50MB)
        r.Body = http.MaxBytesReader(w, r.Body, 50*1024*1024)

        // Parse multipart form
        if err := r.ParseMultipartForm(50 * 1024 * 1024); err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, "File too large or invalid multipart form", http.StatusBadRequest)
                return
        }</span>

        // Get file from form
        <span class="cov0" title="0">file, _, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, "No file provided", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = file.Close() }</span>()

        // Read file contents
        <span class="cov0" title="0">data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to read file", zap.Error(err))
                utils.RespondError(w, "Failed to read file", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("ValidateImport request",
                zap.String("uid", uid),
                zap.Int("fileSize", len(data)),
        )

        // Validate import
        result, err := h.svc.ValidateImport(ctx, uid, data)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to validate import", zap.Error(err))
                utils.RespondError(w, "Failed to validate import: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, result, "Import validation completed")</span>
}

// ExecuteImport executes the import with the given options
// POST /api/import/execute
func (h *ImportExportHandler) ExecuteImport(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Parse request body
        var req struct {
                Data    services.ImportData    `json:"data"`
                Options services.ImportOptions `json:"options"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("ExecuteImport request",
                zap.String("uid", uid),
                zap.Int("totalItems", req.Data.Metadata.TotalItems),
                zap.Bool("updateReferences", req.Options.UpdateReferences),
        )

        // Execute import
        result, err := h.svc.ExecuteImport(ctx, uid, &amp;req.Data, req.Options)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to execute import", zap.Error(err))
                utils.RespondError(w, "Failed to execute import", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Import completed",
                zap.String("uid", uid),
                zap.Int("importedCount", result.ImportedCount),
                zap.Int("skippedCount", result.SkippedCount),
                zap.Int("errorCount", result.ErrorCount),
        )

        utils.RespondSuccess(w, result, "Import completed")</span>
}

// ExportData exports user data with optional filters
// GET /api/export?entityTypes=tasks,projects&amp;startDate=2024-01-01&amp;endDate=2024-12-31
func (h *ImportExportHandler) ExportData(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Parse query parameters
        filters := services.ExportFilters{}

        // Parse entity types
        if entityTypesStr := r.URL.Query().Get("entityTypes"); entityTypesStr != "" </span><span class="cov0" title="0">{
                entityTypeStrs := splitAndTrim(entityTypesStr, ",")
                filters.EntityTypes = make([]services.EntityType, 0, len(entityTypeStrs))
                for _, etStr := range entityTypeStrs </span><span class="cov0" title="0">{
                        filters.EntityTypes = append(filters.EntityTypes, services.EntityType(etStr))
                }</span>
        }

        // Parse dates
        <span class="cov0" title="0">if startDateStr := r.URL.Query().Get("startDate"); startDateStr != "" </span><span class="cov0" title="0">{
                if startDate, err := time.Parse("2006-01-02", startDateStr); err == nil </span><span class="cov0" title="0">{
                        filters.StartDate = &amp;startDate
                }</span>
        }
        <span class="cov0" title="0">if endDateStr := r.URL.Query().Get("endDate"); endDateStr != "" </span><span class="cov0" title="0">{
                if endDate, err := time.Parse("2006-01-02", endDateStr); err == nil </span><span class="cov0" title="0">{
                        filters.EndDate = &amp;endDate
                }</span>
        }

        // Parse task filters
        <span class="cov0" title="0">if taskStatusStr := r.URL.Query().Get("taskStatus"); taskStatusStr != "" </span><span class="cov0" title="0">{
                filters.TaskStatus = splitAndTrim(taskStatusStr, ",")
        }</span>
        <span class="cov0" title="0">if taskCategoryStr := r.URL.Query().Get("taskCategory"); taskCategoryStr != "" </span><span class="cov0" title="0">{
                filters.TaskCategory = splitAndTrim(taskCategoryStr, ",")
        }</span>
        <span class="cov0" title="0">if taskTagsStr := r.URL.Query().Get("taskTags"); taskTagsStr != "" </span><span class="cov0" title="0">{
                filters.TaskTags = splitAndTrim(taskTagsStr, ",")
        }</span>

        // Parse project filters
        <span class="cov0" title="0">if projectStatusStr := r.URL.Query().Get("projectStatus"); projectStatusStr != "" </span><span class="cov0" title="0">{
                filters.ProjectStatus = splitAndTrim(projectStatusStr, ",")
        }</span>

        // Parse goal filters
        <span class="cov0" title="0">if goalStatusStr := r.URL.Query().Get("goalStatus"); goalStatusStr != "" </span><span class="cov0" title="0">{
                filters.GoalStatus = splitAndTrim(goalStatusStr, ",")
        }</span>

        <span class="cov0" title="0">h.logger.Debug("ExportData request",
                zap.String("uid", uid),
                zap.Int("entityTypeCount", len(filters.EntityTypes)),
        )

        // Execute export
        exportData, err := h.svc.ExportData(ctx, uid, filters)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to export data", zap.Error(err))
                utils.RespondError(w, "Failed to export data", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Export completed",
                zap.String("uid", uid),
                zap.Int("totalItems", exportData.Metadata.TotalItems),
        )

        // Set headers for file download
        filename := "focus-notebook-export-" + time.Now().Format("2006-01-02") + ".json"
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Disposition", "attachment; filename=\""+filename+"\"")

        // Stream JSON response
        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ") // Pretty print
        if err := encoder.Encode(exportData); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to encode export data", zap.Error(err))
                return
        }</span>
}

// GetExportSummary returns export summary statistics
// GET /api/export/summary
func (h *ImportExportHandler) GetExportSummary(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        h.logger.Debug("GetExportSummary request",
                zap.String("uid", uid),
        )

        // Get summary
        summary, err := h.svc.GetExportSummary(ctx, uid)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get export summary", zap.Error(err))
                utils.RespondError(w, "Failed to get export summary", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, summary, "Export summary retrieved")</span>
}

// splitAndTrim splits a string by delimiter and trims whitespace
func splitAndTrim(s, delim string) []string <span class="cov8" title="1">{
        parts := make([]string, 0)
        for _, part := range splitString(s, delim) </span><span class="cov8" title="1">{
                trimmed := trimSpace(part)
                if trimmed != "" </span><span class="cov8" title="1">{
                        parts = append(parts, trimmed)
                }</span>
        }
        <span class="cov8" title="1">return parts</span>
}

func splitString(s, delim string) []string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">result := []string{}
        current := ""
        for _, ch := range s </span><span class="cov8" title="1">{
                if string(ch) == delim </span><span class="cov8" title="1">{
                        result = append(result, current)
                        current = ""
                }</span> else<span class="cov8" title="1"> {
                        current += string(ch)
                }</span>
        }
        <span class="cov8" title="1">if current != "" </span><span class="cov8" title="1">{
                result = append(result, current)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func trimSpace(s string) string <span class="cov8" title="1">{
        start := 0
        end := len(s)

        // Trim leading spaces
        for start &lt; end &amp;&amp; (s[start] == ' ' || s[start] == '\t' || s[start] == '\n' || s[start] == '\r') </span><span class="cov8" title="1">{
                start++
        }</span>

        // Trim trailing spaces
        <span class="cov8" title="1">for end &gt; start &amp;&amp; (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') </span><span class="cov8" title="1">{
                end--
        }</span>

        <span class="cov8" title="1">return s[start:end]</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/gorilla/mux"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// InvestmentHandler handles investment calculation requests
type InvestmentHandler struct {
        svc    *services.InvestmentCalculationService
        logger *zap.Logger
}

// NewInvestmentHandler creates a new investment handler
func NewInvestmentHandler(svc *services.InvestmentCalculationService, logger *zap.Logger) *InvestmentHandler <span class="cov8" title="1">{
        return &amp;InvestmentHandler{
                svc:    svc,
                logger: logger,
        }
}</span>

// GetPortfolioMetrics returns calculated metrics for a portfolio
// GET /api/portfolio/{portfolioId}/metrics
func (h *InvestmentHandler) GetPortfolioMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Get portfolio ID from URL
        vars := mux.Vars(r)
        portfolioID := vars["portfolioId"]

        if portfolioID == "" </span><span class="cov0" title="0">{
                utils.RespondError(w, "Portfolio ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("GetPortfolioMetrics request",
                zap.String("uid", uid),
                zap.String("portfolioId", portfolioID),
        )

        // Calculate metrics
        metrics, err := h.svc.CalculatePortfolioMetrics(ctx, uid, portfolioID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to calculate portfolio metrics", zap.Error(err))
                utils.RespondError(w, "Failed to calculate metrics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, metrics, "Portfolio metrics calculated")</span>
}

// GenerateProjection generates a compound interest projection
// POST /api/portfolio/projection
func (h *InvestmentHandler) GenerateProjection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Parse request body
        var req services.ProjectionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("GenerateProjection request",
                zap.String("uid", uid),
                zap.Float64("initialAmount", req.InitialAmount),
                zap.Float64("annualReturn", req.AnnualReturn),
                zap.Int("months", req.Months),
                zap.Int("contributionCount", len(req.Contributions)),
        )

        // Generate projection
        projection, err := h.svc.GenerateProjection(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to generate projection", zap.Error(err))
                utils.RespondError(w, "Failed to generate projection: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, projection, "Projection generated")</span>
}

// GetDashboardSummary returns aggregate summary across all portfolios
// GET /api/portfolio/summary?currency=USD
func (h *InvestmentHandler) GetDashboardSummary(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Get base currency from query params (default to USD)
        baseCurrency := r.URL.Query().Get("currency")
        if baseCurrency == "" </span><span class="cov0" title="0">{
                baseCurrency = "USD"
        }</span>

        <span class="cov0" title="0">h.logger.Debug("GetDashboardSummary request",
                zap.String("uid", uid),
                zap.String("baseCurrency", baseCurrency),
        )

        // Calculate summary
        summary, err := h.svc.CalculateDashboardSummary(ctx, uid, baseCurrency)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to calculate dashboard summary", zap.Error(err))
                utils.RespondError(w, "Failed to calculate summary", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, summary, "Dashboard summary calculated")</span>
}

// GetPortfolioSnapshots returns historical snapshots for a portfolio
// GET /api/portfolio/{portfolioId}/snapshots?startDate=2024-01-01&amp;endDate=2024-12-31
func (h *InvestmentHandler) GetPortfolioSnapshots(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        // Get portfolio ID from URL
        vars := mux.Vars(r)
        portfolioID := vars["portfolioId"]

        if portfolioID == "" </span><span class="cov0" title="0">{
                utils.RespondError(w, "Portfolio ID is required", http.StatusBadRequest)
                return
        }</span>

        // Parse date filters
        <span class="cov0" title="0">var startDate, endDate *time.Time
        if startDateStr := r.URL.Query().Get("startDate"); startDateStr != "" </span><span class="cov0" title="0">{
                if parsed, err := time.Parse("2006-01-02", startDateStr); err == nil </span><span class="cov0" title="0">{
                        startDate = &amp;parsed
                }</span>
        }
        <span class="cov0" title="0">if endDateStr := r.URL.Query().Get("endDate"); endDateStr != "" </span><span class="cov0" title="0">{
                if parsed, err := time.Parse("2006-01-02", endDateStr); err == nil </span><span class="cov0" title="0">{
                        endDate = &amp;parsed
                }</span>
        }

        <span class="cov0" title="0">h.logger.Debug("GetPortfolioSnapshots request",
                zap.String("uid", uid),
                zap.String("portfolioId", portfolioID),
        )

        // Get snapshots
        snapshots, err := h.svc.GetPortfolioSnapshots(ctx, uid, portfolioID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get portfolio snapshots", zap.Error(err))
                utils.RespondError(w, "Failed to get snapshots", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, map[string]interface{}{
                "snapshots": snapshots,
                "count":     len(snapshots),
        }, "Portfolio snapshots retrieved")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// PackingListHandler handles packing list requests
type PackingListHandler struct {
        packingListService *services.PackingListService
        logger             *zap.Logger
}

// NewPackingListHandler creates a new packing list handler
func NewPackingListHandler(
        packingListService *services.PackingListService,
        logger *zap.Logger,
) *PackingListHandler <span class="cov8" title="1">{
        return &amp;PackingListHandler{
                packingListService: packingListService,
                logger:             logger,
        }
}</span>

// CreatePackingListRequest represents the request to create a packing list
type CreatePackingListRequest struct {
        TripID string `json:"tripId"`
}

// CreatePackingListResponse represents the response with created packing list
type CreatePackingListResponse struct {
        PackingList *services.PackingList `json:"packingList"`
}

// CreatePackingList handles POST /api/packing-list/create
func (h *PackingListHandler) CreatePackingList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req CreatePackingListRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.TripID == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "tripId is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Creating packing list",
                zap.String("uid", userID),
                zap.String("tripId", req.TripID),
        )

        packingList, err := h.packingListService.CreatePackingList(ctx, userID, req.TripID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create packing list",
                        zap.String("uid", userID),
                        zap.String("tripId", req.TripID),
                        zap.Error(err),
                )

                // Check for specific error types
                if err.Error() == "trip not found" || err.Error() == "trip not found: not found" </span><span class="cov0" title="0">{
                        utils.WriteError(w, "Trip not found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">utils.WriteError(w, "Failed to create packing list", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">response := CreatePackingListResponse{
                PackingList: packingList,
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}

// UpdatePackingListRequest represents the request to update a packing list
type UpdatePackingListRequest struct {
        TripID  string                 `json:"tripId"`
        Updates map[string]interface{} `json:"updates"`
}

// UpdatePackingListResponse represents the response for update
type UpdatePackingListResponse struct {
        Success bool `json:"success"`
}

// UpdatePackingList handles POST /api/packing-list/update
func (h *PackingListHandler) UpdatePackingList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req UpdatePackingListRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.TripID == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "tripId is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Updating packing list",
                zap.String("uid", userID),
                zap.String("tripId", req.TripID),
        )

        err := h.packingListService.UpdatePackingList(ctx, userID, req.TripID, req.Updates)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update packing list",
                        zap.String("uid", userID),
                        zap.String("tripId", req.TripID),
                        zap.Error(err),
                )

                // Check for specific error types
                if err.Error() == "trip not found" || err.Error() == "trip not found: not found" </span><span class="cov0" title="0">{
                        utils.WriteError(w, "Trip not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "packing list not found" || err.Error() == "packing list not found: not found" </span><span class="cov0" title="0">{
                        utils.WriteError(w, "Packing list not found. Create one first.", http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">utils.WriteError(w, "Failed to update packing list", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">response := UpdatePackingListResponse{
                Success: true,
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}

// SetItemStatusRequest represents the request to set item status
type SetItemStatusRequest struct {
        TripID string `json:"tripId"`
        ItemID string `json:"itemId"`
        Status string `json:"status"`
}

// SetItemStatusResponse represents the response for set status
type SetItemStatusResponse struct {
        Success bool `json:"success"`
}

// SetItemStatus handles POST /api/packing-list/toggle-item
func (h *PackingListHandler) SetItemStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req SetItemStatusRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.TripID == "" || req.ItemID == "" || req.Status == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "tripId, itemId, and status are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Setting item status",
                zap.String("uid", userID),
                zap.String("tripId", req.TripID),
                zap.String("itemId", req.ItemID),
                zap.String("status", req.Status),
        )

        err := h.packingListService.SetItemStatus(ctx, userID, req.TripID, req.ItemID, req.Status)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to set item status",
                        zap.String("uid", userID),
                        zap.String("tripId", req.TripID),
                        zap.String("itemId", req.ItemID),
                        zap.Error(err),
                )

                // Check for specific error types
                if err.Error() == "trip not found" || err.Error() == "trip not found: not found" </span><span class="cov0" title="0">{
                        utils.WriteError(w, "Trip not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "packing list not found" || err.Error() == "packing list not found: not found" </span><span class="cov0" title="0">{
                        utils.WriteError(w, "Packing list not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "invalid status: must be one of unpacked, packed, later, no-need" </span><span class="cov0" title="0">{
                        utils.WriteError(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">utils.WriteError(w, "Failed to set item status", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">response := SetItemStatusResponse{
                Success: true,
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// PhotoHandler handles photo-related requests
type PhotoHandler struct {
        photoService *services.PhotoService
        logger       *zap.Logger
}

// NewPhotoHandler creates a new photo handler
func NewPhotoHandler(photoService *services.PhotoService, logger *zap.Logger) *PhotoHandler <span class="cov8" title="1">{
        return &amp;PhotoHandler{
                photoService: photoService,
                logger:       logger,
        }
}</span>

// SubmitVoteRequest represents the request to submit a vote
type SubmitVoteRequest struct {
        SessionID string `json:"sessionId"`
        WinnerID  string `json:"winnerId"`
        LoserID   string `json:"loserId"`
}

// SubmitVote handles POST /api/photo/vote
func (h *PhotoHandler) SubmitVote(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        // VoterID can be anonymous or authenticated user
        voterID := ""
        if userID := ctx.Value("userID"); userID != nil </span><span class="cov0" title="0">{
                voterID = userID.(string)
        }</span>

        <span class="cov0" title="0">var req SubmitVoteRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if req.SessionID == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "sessionId is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">if req.WinnerID == "" || req.LoserID == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "winnerId and loserId are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Submitting photo vote",
                zap.String("sessionId", req.SessionID),
                zap.String("winnerId", req.WinnerID),
                zap.String("loserId", req.LoserID),
                zap.String("voterId", voterID),
        )

        err := h.photoService.SubmitVote(ctx, req.SessionID, req.WinnerID, req.LoserID, voterID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to submit vote",
                        zap.String("sessionId", req.SessionID),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to submit vote", http.StatusInternalServerError)
                return
        }</span>

        // Return empty response (matches Firebase callable function pattern)
        <span class="cov0" title="0">utils.WriteJSON(w, map[string]interface{}{}, http.StatusOK)</span>
}

// GetNextPairRequest represents the request to get next photo pair
type GetNextPairRequest struct {
        SessionID string `json:"sessionId"`
}

// GetNextPairResponse represents the response with photo pair
type GetNextPairResponse struct {
        Left  *services.BattlePhoto `json:"left"`
        Right *services.BattlePhoto `json:"right"`
}

// GetNextPair handles POST /api/photo/next-pair
func (h *PhotoHandler) GetNextPair(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var req GetNextPairRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.SessionID == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "sessionId is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Getting next photo pair", zap.String("sessionId", req.SessionID))

        left, right, err := h.photoService.GetNextPair(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get next pair",
                        zap.String("sessionId", req.SessionID),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to get next photo pair", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := GetNextPairResponse{
                Left:  left,
                Right: right,
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}

// GetSignedURLRequest represents the request for a signed URL
type GetSignedURLRequest struct {
        Path      string `json:"path"`
        ExpiresAt string `json:"expiresAt,omitempty"`
}

// GetSignedURLResponse represents the signed URL response
type GetSignedURLResponse struct {
        URL       string `json:"url"`
        ExpiresAt string `json:"expiresAt"`
}

// GetSignedURL handles POST /api/photo/signed-url
func (h *PhotoHandler) GetSignedURL(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req GetSignedURLRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Path == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "path is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Generating signed URL",
                zap.String("uid", userID),
                zap.String("path", req.Path),
        )

        // Parse expiry if provided
        var expiresAt *time.Time
        if req.ExpiresAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, req.ExpiresAt)
                if err != nil </span><span class="cov0" title="0">{
                        utils.WriteError(w, "invalid expiresAt format (use RFC3339)", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">expiresAt = &amp;t</span>
        }

        <span class="cov0" title="0">url, expires, err := h.photoService.GetSignedURL(ctx, userID, req.Path, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to generate signed URL",
                        zap.String("uid", userID),
                        zap.String("path", req.Path),
                        zap.Error(err),
                )

                // Check for permission denied error
                if err.Error() == "permission denied: cannot access other users' files" ||
                        err.Error() == "invalid storage path" ||
                        err.Error() == "path is incomplete" </span><span class="cov0" title="0">{
                        utils.WriteError(w, err.Error(), http.StatusForbidden)
                        return
                }</span>

                <span class="cov0" title="0">utils.WriteError(w, "Failed to generate signed URL", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">response := GetSignedURLResponse{
                URL:       url,
                ExpiresAt: expires.Format(time.RFC3339),
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// PlaceInsightsHandler handles place insights requests
type PlaceInsightsHandler struct {
        placeInsightsService *services.PlaceInsightsService
        logger               *zap.Logger
}

// NewPlaceInsightsHandler creates a new place insights handler
func NewPlaceInsightsHandler(
        placeInsightsService *services.PlaceInsightsService,
        logger *zap.Logger,
) *PlaceInsightsHandler <span class="cov8" title="1">{
        return &amp;PlaceInsightsHandler{
                placeInsightsService: placeInsightsService,
                logger:               logger,
        }
}</span>

// GenerateInsightsRequest represents the request to generate place insights
type GenerateInsightsRequest struct {
        DestinationName string `json:"destinationName"`
        Country         string `json:"country,omitempty"`
}

// GenerateInsightsResponse represents the response with place insights
type GenerateInsightsResponse struct {
        Result *services.PlaceInsights `json:"result"`
}

// GenerateInsights handles POST /api/place-insights
func (h *PlaceInsightsHandler) GenerateInsights(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req GenerateInsightsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Trim and validate
        <span class="cov0" title="0">destinationName := trimString(req.DestinationName)
        country := trimString(req.Country)

        if destinationName == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "destinationName is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Generating place insights",
                zap.String("uid", userID),
                zap.String("destination", destinationName),
                zap.String("country", country),
        )

        insights, err := h.placeInsightsService.GeneratePlaceInsights(ctx, destinationName, country)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to generate place insights",
                        zap.String("uid", userID),
                        zap.String("destination", destinationName),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to generate place insights", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := GenerateInsightsResponse{
                Result: insights,
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}

// trimString trims whitespace from a string
func trimString(s string) string <span class="cov0" title="0">{
        // Simple trim implementation
        start := 0
        end := len(s)

        for start &lt; end &amp;&amp; (s[start] == ' ' || s[start] == '\t' || s[start] == '\n' || s[start] == '\r') </span><span class="cov0" title="0">{
                start++
        }</span>

        <span class="cov0" title="0">for end &gt; start &amp;&amp; (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') </span><span class="cov0" title="0">{
                end--
        }</span>

        <span class="cov0" title="0">return s[start:end]</span>
}

// VisaHandler handles visa requirements requests
type VisaHandler struct {
        visaService *services.VisaService
        logger      *zap.Logger
}

// NewVisaHandler creates a new visa handler
func NewVisaHandler(visaService *services.VisaService, logger *zap.Logger) *VisaHandler <span class="cov8" title="1">{
        return &amp;VisaHandler{
                visaService: visaService,
                logger:      logger,
        }
}</span>

// GetVisaRequirementsResponse represents the response with visa requirements
type GetVisaRequirementsResponse struct {
        Success      bool                       `json:"success"`
        Count        int                        `json:"count"`
        Requirements []services.VisaRequirement `json:"requirements"`
}

// GetVisaRequirements handles GET /api/visa-requirements
func (h *VisaHandler) GetVisaRequirements(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        // Get nationality from query parameter
        nationality := r.URL.Query().Get("nationality")

        if nationality == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "nationality query parameter is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Getting visa requirements",
                zap.String("nationality", nationality),
        )

        requirements, err := h.visaService.GetVisaRequirements(ctx, nationality)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get visa requirements",
                        zap.String("nationality", nationality),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to get visa requirements", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := GetVisaRequirementsResponse{
                Success:      true,
                Count:        len(requirements),
                Requirements: requirements,
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "io"
        "net/http"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// PlaidHandler handles Plaid banking requests
type PlaidHandler struct {
        plaidService *services.PlaidService
        logger       *zap.Logger
}

// NewPlaidHandler creates a new Plaid handler
func NewPlaidHandler(plaidService *services.PlaidService, logger *zap.Logger) *PlaidHandler <span class="cov8" title="1">{
        return &amp;PlaidHandler{
                plaidService: plaidService,
                logger:       logger,
        }
}</span>

// CreateLinkToken creates a Plaid Link token for new connections
// POST /api/plaid/create-link-token
func (h *PlaidHandler) CreateLinkToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)
        email := ctx.Value("email").(string)

        var req struct {
                Platform    string `json:"platform"`
                RedirectURI string `json:"redirectUri"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.RespondError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Default platform to web
        <span class="cov0" title="0">if req.Platform == "" </span><span class="cov0" title="0">{
                req.Platform = "web"
        }</span>

        <span class="cov0" title="0">h.logger.Debug("CreateLinkToken request",
                zap.String("uid", uid),
                zap.String("platform", req.Platform),
        )

        result, err := h.plaidService.CreateLinkToken(ctx, services.CreateLinkTokenRequest{
                UID:         uid,
                Email:       email,
                Platform:    req.Platform,
                RedirectURI: req.RedirectURI,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create link token", zap.Error(err))
                utils.RespondError(w, "Failed to create link token", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, result, "Link token created")</span>
}

// ExchangePublicToken exchanges a public token for an access token
// POST /api/plaid/exchange-public-token
func (h *PlaidHandler) ExchangePublicToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        var req struct {
                PublicToken string `json:"public_token"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.RespondError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.PublicToken == "" </span><span class="cov0" title="0">{
                utils.RespondError(w, "public_token is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("ExchangePublicToken request",
                zap.String("uid", uid),
        )

        result, err := h.plaidService.ExchangePublicToken(ctx, services.ExchangePublicTokenRequest{
                UID:         uid,
                PublicToken: req.PublicToken,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to exchange public token", zap.Error(err))
                utils.RespondError(w, "Failed to exchange public token", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, result, "Public token exchanged")</span>
}

// CreateRelinkToken creates a link token for updating/relinking an existing item
// POST /api/plaid/create-relink-token
func (h *PlaidHandler) CreateRelinkToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)
        email := ctx.Value("email").(string)

        var req struct {
                ItemID   string `json:"itemId"`
                Platform string `json:"platform"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.RespondError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ItemID == "" </span><span class="cov0" title="0">{
                utils.RespondError(w, "itemId is required", http.StatusBadRequest)
                return
        }</span>

        // Default platform to web
        <span class="cov0" title="0">if req.Platform == "" </span><span class="cov0" title="0">{
                req.Platform = "web"
        }</span>

        <span class="cov0" title="0">h.logger.Debug("CreateRelinkToken request",
                zap.String("uid", uid),
                zap.String("itemId", req.ItemID),
        )

        result, err := h.plaidService.CreateRelinkToken(ctx, services.CreateRelinkTokenRequest{
                UID:      uid,
                Email:    email,
                ItemID:   req.ItemID,
                Platform: req.Platform,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create relink token", zap.Error(err))
                utils.RespondError(w, "Failed to create relink token", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, result, "Relink token created")</span>
}

// MarkRelinking marks an item as successfully relinked
// POST /api/plaid/mark-relinking
func (h *PlaidHandler) MarkRelinking(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        var req struct {
                ItemID string `json:"itemId"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.RespondError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ItemID == "" </span><span class="cov0" title="0">{
                utils.RespondError(w, "itemId is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("MarkRelinking request",
                zap.String("uid", uid),
                zap.String("itemId", req.ItemID),
        )

        err := h.plaidService.MarkRelinking(ctx, services.MarkRelinkingRequest{
                UID:    uid,
                ItemID: req.ItemID,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to mark relinking", zap.Error(err))
                utils.RespondError(w, "Failed to mark relinking", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, map[string]interface{}{"ok": true}, "Item marked as relinked")</span>
}

// TriggerSync manually triggers a transaction sync for an item
// POST /api/plaid/trigger-sync
func (h *PlaidHandler) TriggerSync(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        uid := ctx.Value("uid").(string)

        var req struct {
                ItemID string `json:"itemId"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.RespondError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ItemID == "" </span><span class="cov0" title="0">{
                utils.RespondError(w, "itemId is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug("TriggerSync request",
                zap.String("uid", uid),
                zap.String("itemId", req.ItemID),
        )

        result, err := h.plaidService.TriggerSync(ctx, services.TriggerSyncRequest{
                UID:    uid,
                ItemID: req.ItemID,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to trigger sync", zap.Error(err))
                utils.RespondError(w, "Failed to trigger sync", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, result, "Transaction sync completed")</span>
}

// HandleWebhook processes Plaid webhook events
// POST /api/plaid/webhook
func (h *PlaidHandler) HandleWebhook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Read raw body for signature verification
        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to read webhook body", zap.Error(err))
                utils.RespondError(w, "Failed to read request", http.StatusBadRequest)
                return
        }</span>

        // Parse webhook payload
        <span class="cov0" title="0">var webhook struct {
                WebhookType string  `json:"webhook_type"`
                WebhookCode string  `json:"webhook_code"`
                ItemID      string  `json:"item_id"`
                Error       *string `json:"error"`
                ErrorCode   *string `json:"error_code"`
        }

        if err := json.Unmarshal(body, &amp;webhook); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to parse webhook", zap.Error(err))
                utils.RespondError(w, "Invalid webhook payload", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Received Plaid webhook",
                zap.String("type", webhook.WebhookType),
                zap.String("code", webhook.WebhookCode),
                zap.String("itemId", webhook.ItemID),
        )

        // Process webhook (async to return 200 quickly)
        go func() </span><span class="cov0" title="0">{
                processCtx := context.Background()
                if err := h.plaidService.HandleWebhook(
                        processCtx,
                        webhook.WebhookType,
                        webhook.WebhookCode,
                        webhook.ItemID,
                        webhook.ErrorCode,
                ); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to process webhook", zap.Error(err))
                }</span>
        }()

        // Always return 200 to Plaid
        <span class="cov0" title="0">utils.RespondSuccess(w, map[string]interface{}{
                "received": true,
                "type":     webhook.WebhookType,
                "code":     webhook.WebhookCode,
        }, "Webhook received")</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// SpendingHandler handles spending-related requests
type SpendingHandler struct {
        csvProcessingService *services.CSVProcessingService
        logger               *zap.Logger
}

// NewSpendingHandler creates a new spending handler
func NewSpendingHandler(
        csvProcessingService *services.CSVProcessingService,
        logger *zap.Logger,
) *SpendingHandler <span class="cov8" title="1">{
        return &amp;SpendingHandler{
                csvProcessingService: csvProcessingService,
                logger:               logger,
        }
}</span>

// ProcessCSVRequest represents the request to process a CSV file
type ProcessCSVRequest struct {
        FileName    string `json:"fileName"`
        StoragePath string `json:"storagePath"`
}

// ProcessCSVResponse represents the response from CSV processing
type ProcessCSVResponse struct {
        Success        bool   `json:"success"`
        ProcessedCount int    `json:"processedCount"`
        FileName       string `json:"fileName"`
}

// DeleteCSVRequest represents the request to delete a CSV statement
type DeleteCSVRequest struct {
        FileName string `json:"fileName"`
}

// ProcessCSV handles POST /api/spending/process-csv
func (h *SpendingHandler) ProcessCSV(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req ProcessCSVRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.FileName == "" || req.StoragePath == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "fileName and storagePath are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Processing CSV",
                zap.String("uid", userID),
                zap.String("fileName", req.FileName),
        )

        processedCount, err := h.csvProcessingService.ProcessCSVFile(
                ctx,
                userID,
                req.FileName,
                req.StoragePath,
        )

        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to process CSV",
                        zap.String("uid", userID),
                        zap.String("fileName", req.FileName),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to process CSV file", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := ProcessCSVResponse{
                Success:        true,
                ProcessedCount: processedCount,
                FileName:       req.FileName,
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}

// DeleteCSV handles POST /api/spending/delete-csv
func (h *SpendingHandler) DeleteCSV(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req DeleteCSVRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.FileName == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "fileName is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Deleting CSV statement",
                zap.String("uid", userID),
                zap.String("fileName", req.FileName),
        )

        err := h.csvProcessingService.DeleteCSVStatement(ctx, userID, req.FileName)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to delete CSV statement",
                        zap.String("uid", userID),
                        zap.String("fileName", req.FileName),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to delete CSV statement", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, map[string]bool{"success": true}, http.StatusOK)</span>
}

// CategorizeTransactionRequest represents the request to categorize a transaction
type CategorizeTransactionRequest struct {
        TransactionID string   `json:"transactionId"`
        Merchant      string   `json:"merchant"`
        Description   string   `json:"description"`
        PlaidCategory []string `json:"plaidCategory,omitempty"`
}

// CategorizeTransactionResponse represents the categorization result
type CategorizeTransactionResponse struct {
        Success    bool    `json:"success"`
        Level1     string  `json:"level1"`
        Level2     string  `json:"level2,omitempty"`
        Confidence float64 `json:"confidence"`
}

// CategorizeTransaction handles POST /api/spending/categorize
func (h *SpendingHandler) CategorizeTransaction(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req CategorizeTransactionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.TransactionID == "" || req.Merchant == "" || req.Description == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "transactionId, merchant, and description are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Categorizing transaction",
                zap.String("uid", userID),
                zap.String("transactionId", req.TransactionID),
        )

        category, err := h.csvProcessingService.CategorizeTransaction(
                ctx,
                userID,
                req.Merchant,
                req.Description,
                req.PlaidCategory,
        )

        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to categorize transaction",
                        zap.String("uid", userID),
                        zap.String("transactionId", req.TransactionID),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to categorize transaction", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := CategorizeTransactionResponse{
                Success:    true,
                Level1:     category.Level1,
                Level2:     category.Level2,
                Confidence: category.Confidence,
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}

// LinkTransactionToTripRequest represents the request to link a transaction to a trip
type LinkTransactionToTripRequest struct {
        TransactionID string  `json:"transactionId"`
        TripID        string  `json:"tripId"`
        Confidence    float64 `json:"confidence,omitempty"`
        Reasoning     string  `json:"reasoning,omitempty"`
}

// LinkTransactionToTrip handles POST /api/spending/link-trip
func (h *SpendingHandler) LinkTransactionToTrip(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req LinkTransactionToTripRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.TransactionID == "" || req.TripID == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "transactionId and tripId are required", http.StatusBadRequest)
                return
        }</span>

        // Default confidence to 1.0 for manual links
        <span class="cov0" title="0">if req.Confidence == 0 </span><span class="cov0" title="0">{
                req.Confidence = 1.0
        }</span>

        // Default reasoning for manual links
        <span class="cov0" title="0">if req.Reasoning == "" </span><span class="cov0" title="0">{
                req.Reasoning = "Linked manually by user"
        }</span>

        <span class="cov0" title="0">h.logger.Info("Linking transaction to trip",
                zap.String("uid", userID),
                zap.String("transactionId", req.TransactionID),
                zap.String("tripId", req.TripID),
        )

        err := h.csvProcessingService.LinkTransactionToTrip(
                ctx,
                userID,
                req.TransactionID,
                req.TripID,
                req.Confidence,
                req.Reasoning,
        )

        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to link transaction to trip",
                        zap.String("uid", userID),
                        zap.String("transactionId", req.TransactionID),
                        zap.String("tripId", req.TripID),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to link transaction to trip", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, map[string]bool{"success": true}, http.StatusOK)</span>
}

// DeleteAllTransactionsResponse represents the response from deleting all transactions
type DeleteAllTransactionsResponse struct {
        Success                   bool `json:"success"`
        TransactionsDeleted       int  `json:"transactionsDeleted"`
        ProcessingStatusesDeleted int  `json:"processingStatusesDeleted"`
        StatementsDeleted         int  `json:"statementsDeleted"`
        QueuedJobsDeleted         int  `json:"queuedJobsDeleted"`
}

// DeleteAllTransactions handles POST /api/spending/delete-all
func (h *SpendingHandler) DeleteAllTransactions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        h.logger.Info("Deleting all transactions for user", zap.String("uid", userID))

        summary, err := h.csvProcessingService.DeleteAllTransactions(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to delete all transactions",
                        zap.String("uid", userID),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to delete all transactions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := DeleteAllTransactionsResponse{
                Success:                   true,
                TransactionsDeleted:       summary.TransactionsDeleted,
                ProcessingStatusesDeleted: summary.ProcessingStatusesDeleted,
                StatementsDeleted:         summary.StatementsDeleted,
                QueuedJobsDeleted:         summary.QueuedJobsDeleted,
        }

        utils.WriteJSON(w, response, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// StockHandler handles stock-related requests
type StockHandler struct {
        stockService      *services.StockService
        predictionService *services.InvestmentPredictionService
        logger            *zap.Logger
}

// NewStockHandler creates a new stock handler
func NewStockHandler(
        stockService *services.StockService,
        predictionService *services.InvestmentPredictionService,
        logger *zap.Logger,
) *StockHandler <span class="cov8" title="1">{
        return &amp;StockHandler{
                stockService:      stockService,
                predictionService: predictionService,
                logger:            logger,
        }
}</span>

// GetStockPriceRequest represents the request to get a stock price
type GetStockPriceRequest struct {
        Ticker string `json:"ticker"`
}

// GetStockHistoryRequest represents the request to get stock history
type GetStockHistoryRequest struct {
        Ticker string `json:"ticker"`
        Days   int    `json:"days"`
}

// GetStockPrice handles POST /api/stock-price
func (h *StockHandler) GetStockPrice(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req GetStockPriceRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Ticker == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "Ticker is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Getting stock price",
                zap.String("uid", userID),
                zap.String("ticker", req.Ticker),
        )

        quote, err := h.stockService.GetStockPrice(ctx, userID, req.Ticker)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get stock price",
                        zap.String("uid", userID),
                        zap.String("ticker", req.Ticker),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to fetch stock price", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, quote, http.StatusOK)</span>
}

// GetStockHistory handles POST /api/stock-history
func (h *StockHandler) GetStockHistory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req GetStockHistoryRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Ticker == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "Ticker is required", http.StatusBadRequest)
                return
        }</span>

        // Default to 90 days if not specified
        <span class="cov0" title="0">if req.Days &lt;= 0 </span><span class="cov0" title="0">{
                req.Days = 90
        }</span>

        // Limit to 5 years (1825 days)
        <span class="cov0" title="0">if req.Days &gt; 1825 </span><span class="cov0" title="0">{
                req.Days = 1825
        }</span>

        <span class="cov0" title="0">h.logger.Info("Getting stock history",
                zap.String("uid", userID),
                zap.String("ticker", req.Ticker),
                zap.Int("days", req.Days),
        )

        history, err := h.stockService.GetStockHistory(ctx, userID, req.Ticker, req.Days)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get stock history",
                        zap.String("uid", userID),
                        zap.String("ticker", req.Ticker),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to fetch stock history", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, history, http.StatusOK)</span>
}

// PredictInvestmentRequest represents the request for investment prediction
type PredictInvestmentRequest struct {
        Symbol         string                         `json:"symbol"`
        HistoricalData []services.HistoricalDataPoint `json:"historicalData"`
        Model          string                         `json:"model,omitempty"`
}

// PredictInvestment handles POST /api/predict-investment
func (h *StockHandler) PredictInvestment(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        userID := ctx.Value("userID").(string)

        var req PredictInvestmentRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("Invalid request body", zap.Error(err))
                utils.WriteError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if req.Symbol == "" </span><span class="cov0" title="0">{
                utils.WriteError(w, "Symbol is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(req.HistoricalData) &lt; 30 </span><span class="cov0" title="0">{
                utils.WriteError(w, "Need at least 30 days of historical data for predictions", http.StatusBadRequest)
                return
        }</span>

        // Check if prediction service is available
        <span class="cov0" title="0">if h.predictionService == nil </span><span class="cov0" title="0">{
                utils.WriteError(w, "Investment prediction service not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Generating investment prediction",
                zap.String("uid", userID),
                zap.String("symbol", req.Symbol),
                zap.Int("dataPoints", len(req.HistoricalData)),
                zap.String("model", req.Model),
        )

        prediction, err := h.predictionService.PredictInvestment(
                ctx,
                req.Symbol,
                req.HistoricalData,
                req.Model,
        )
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to generate prediction",
                        zap.String("uid", userID),
                        zap.String("symbol", req.Symbol),
                        zap.Error(err),
                )
                utils.WriteError(w, "Failed to generate investment prediction", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSON(w, prediction, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "fmt"
        "io"
        "net/http"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// StripeHandler handles Stripe billing requests
type StripeHandler struct {
        stripeClient     *clients.StripeClient
        stripeBillingSvc *services.StripeBillingService
        logger           *zap.Logger
}

// NewStripeHandler creates a new Stripe handler
func NewStripeHandler(
        stripeClient *clients.StripeClient,
        stripeBillingSvc *services.StripeBillingService,
        logger *zap.Logger,
) *StripeHandler <span class="cov8" title="1">{
        return &amp;StripeHandler{
                stripeClient:     stripeClient,
                stripeBillingSvc: stripeBillingSvc,
                logger:           logger,
        }
}</span>

// CreateCheckoutSession handles POST /api/stripe/create-checkout-session
func (h *StripeHandler) CreateCheckoutSession(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        uid := r.Context().Value("uid").(string)

        // Parse request
        var req struct {
                SuccessURL string `json:"successUrl"`
                CancelURL  string `json:"cancelUrl"`
        }
        if err := utils.ParseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, fmt.Sprintf("Invalid request: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Creating checkout session",
                zap.String("uid", uid),
        )

        // Get user email from token (if available)
        userEmail := ""
        if decodedToken, ok := r.Context().Value("decodedToken").(interface{}); ok </span><span class="cov0" title="0">{
                if claims, ok := decodedToken.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if email, ok := claims["email"].(string); ok </span><span class="cov0" title="0">{
                                userEmail = email
                        }</span>
                }
        }

        // Create checkout session
        <span class="cov0" title="0">sessionURL, err := h.stripeBillingSvc.CreateCheckoutSession(
                r.Context(),
                uid,
                userEmail,
                req.SuccessURL,
                req.CancelURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create checkout session",
                        zap.Error(err),
                        zap.String("uid", uid),
                )
                utils.RespondError(w, fmt.Sprintf("Failed to create checkout session: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, map[string]interface{}{
                "url": sessionURL,
        }, "Checkout session created")</span>
}

// CreatePortalSession handles POST /api/stripe/create-portal-session
func (h *StripeHandler) CreatePortalSession(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        uid := r.Context().Value("uid").(string)

        // Parse request
        var req struct {
                ReturnURL string `json:"returnUrl"`
        }
        if err := utils.ParseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, fmt.Sprintf("Invalid request: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Creating portal session",
                zap.String("uid", uid),
        )

        // Create portal session
        sessionURL, err := h.stripeBillingSvc.CreatePortalSession(
                r.Context(),
                uid,
                req.ReturnURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create portal session",
                        zap.Error(err),
                        zap.String("uid", uid),
                )
                utils.RespondError(w, fmt.Sprintf("Failed to create portal session: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, map[string]interface{}{
                "url": sessionURL,
        }, "Portal session created")</span>
}

// HandleWebhook handles POST /api/stripe/webhook
func (h *StripeHandler) HandleWebhook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Read request body
        payload, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to read webhook payload", zap.Error(err))
                utils.RespondError(w, "Failed to read request", http.StatusBadRequest)
                return
        }</span>

        // Get Stripe signature
        <span class="cov0" title="0">signature := r.Header.Get("Stripe-Signature")
        if signature == "" </span><span class="cov0" title="0">{
                h.logger.Warn("Missing Stripe signature")
                utils.RespondError(w, "Missing signature", http.StatusBadRequest)
                return
        }</span>

        // Verify and construct event
        <span class="cov0" title="0">event, err := h.stripeClient.ConstructWebhookEvent(payload, signature)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to verify webhook", zap.Error(err))
                utils.RespondError(w, "Invalid signature", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Processing webhook event",
                zap.String("type", string(event.Type)),
                zap.String("eventId", event.ID),
        )

        // Process event
        err = h.stripeBillingSvc.HandleWebhookEvent(r.Context(), event)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to process webhook event",
                        zap.Error(err),
                        zap.String("type", string(event.Type)),
                        zap.String("eventId", event.ID),
                )
                // Still return 200 to Stripe to acknowledge receipt
                // Log the error but don't fail the webhook
        }</span>

        // Return 200 to acknowledge receipt
        <span class="cov0" title="0">utils.RespondSuccess(w, map[string]interface{}{
                "received": true,
                "eventId":  event.ID,
        }, "Webhook processed")</span>
}

// GetInvoices handles GET /api/stripe/invoices
func (h *StripeHandler) GetInvoices(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        uid := r.Context().Value("uid").(string)

        h.logger.Info("Fetching invoices", zap.String("uid", uid))

        // Get customer ID from subscription service
        // This is a simplified version - in production you'd want to use the subscription service
        // For now, return a placeholder
        utils.RespondSuccess(w, map[string]interface{}{
                "invoices": []interface{}{},
        }, "Invoices retrieved")
}</span>

// GetPaymentMethod handles GET /api/stripe/payment-method
func (h *StripeHandler) GetPaymentMethod(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        uid := r.Context().Value("uid").(string)

        h.logger.Info("Fetching payment method", zap.String("uid", uid))

        // Get customer ID from subscription service
        // This is a simplified version - in production you'd want to use the subscription service
        // For now, return a placeholder
        utils.RespondSuccess(w, map[string]interface{}{
                "paymentMethod": nil,
        }, "Payment method retrieved")
}</span>

// ReactivateSubscription handles POST /api/stripe/reactivate-subscription
func (h *StripeHandler) ReactivateSubscription(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        uid := r.Context().Value("uid").(string)

        h.logger.Info("Reactivating subscription", zap.String("uid", uid))

        // Parse request
        var req struct {
                SubscriptionID string `json:"subscriptionId"`
        }
        if err := utils.ParseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, fmt.Sprintf("Invalid request: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.SubscriptionID == "" </span><span class="cov0" title="0">{
                utils.RespondError(w, "subscriptionId is required", http.StatusBadRequest)
                return
        }</span>

        // Reactivate subscription
        <span class="cov0" title="0">subscription, err := h.stripeClient.ReactivateSubscription(req.SubscriptionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to reactivate subscription",
                        zap.Error(err),
                        zap.String("uid", uid),
                        zap.String("subscriptionId", req.SubscriptionID),
                )
                utils.RespondError(w, fmt.Sprintf("Failed to reactivate subscription: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, map[string]interface{}{
                "subscription": map[string]interface{}{
                        "id":                subscription.ID,
                        "status":            string(subscription.Status),
                        "cancelAtPeriodEnd": subscription.CancelAtPeriodEnd,
                },
        }, "Subscription reactivated")</span>
}

// GetUsageStats handles GET /api/stripe/usage-stats
func (h *StripeHandler) GetUsageStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        uid := r.Context().Value("uid").(string)

        h.logger.Info("Fetching usage stats", zap.String("uid", uid))

        // TODO: Implement usage stats retrieval from Firestore
        // For now, return placeholder data
        utils.RespondSuccess(w, map[string]interface{}{
                "totalRequests":   0,
                "totalTokens":     0,
                "monthlyRequests": 0,
                "monthlyTokens":   0,
        }, "Usage stats retrieved")
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package handlers

import (
        "fmt"
        "net/http"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/services"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// ThoughtHandler handles thought processing requests
type ThoughtHandler struct {
        thoughtProcessingSvc *services.ThoughtProcessingService
        logger               *zap.Logger
}

// NewThoughtHandler creates a new thought handler
func NewThoughtHandler(thoughtProcessingSvc *services.ThoughtProcessingService, logger *zap.Logger) *ThoughtHandler <span class="cov8" title="1">{
        return &amp;ThoughtHandler{
                thoughtProcessingSvc: thoughtProcessingSvc,
                logger:               logger,
        }
}</span>

// ProcessThought handles POST /api/process-thought
func (h *ThoughtHandler) ProcessThought(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse request
        var req models.ThoughtProcessingRequest
        if err := utils.ParseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, fmt.Sprintf("Invalid request: %v", err), http.StatusBadRequest)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if req.ThoughtID == "" &amp;&amp; req.Thought == nil </span><span class="cov0" title="0">{
                utils.RespondError(w, "thoughtId or thought is required", http.StatusBadRequest)
                return
        }</span>

        // Get user context
        <span class="cov0" title="0">uid := r.Context().Value("uid").(string)

        h.logger.Info("Processing thought request",
                zap.String("uid", uid),
                zap.String("thoughtId", req.ThoughtID),
                zap.String("model", req.Model),
        )

        // Get thought data
        thoughtID := req.ThoughtID
        thought := req.Thought

        // If thought data is embedded, use it directly
        if thought == nil </span><span class="cov0" title="0">{
                utils.RespondError(w, "thought data is required", http.StatusBadRequest)
                return
        }</span>

        // Process thought
        <span class="cov0" title="0">err := h.thoughtProcessingSvc.ProcessThought(r.Context(), thoughtID, thought, req.Model)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to process thought",
                        zap.Error(err),
                        zap.String("uid", uid),
                        zap.String("thoughtId", thoughtID),
                )
                utils.RespondError(w, fmt.Sprintf("Failed to process thought: %v", err), http.StatusInternalServerError)
                return
        }</span>

        // Success response
        <span class="cov0" title="0">utils.RespondSuccess(w, map[string]interface{}{
                "thoughtId": thoughtID,
                "processed": true,
        }, "Thought processed successfully")</span>
}

// ReprocessThought handles POST /api/reprocess-thought
func (h *ThoughtHandler) ReprocessThought(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse request
        var req models.ThoughtProcessingRequest
        if err := utils.ParseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, fmt.Sprintf("Invalid request: %v", err), http.StatusBadRequest)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if req.ThoughtID == "" &amp;&amp; req.Thought == nil </span><span class="cov0" title="0">{
                utils.RespondError(w, "thoughtId or thought is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">uid := r.Context().Value("uid").(string)

        h.logger.Info("Reprocessing thought request",
                zap.String("uid", uid),
                zap.String("thoughtId", req.ThoughtID),
        )

        thoughtID := req.ThoughtID
        thought := req.Thought

        if thought == nil </span><span class="cov0" title="0">{
                utils.RespondError(w, "thought data is required", http.StatusBadRequest)
                return
        }</span>

        // Remove "processed" tag to allow reprocessing
        <span class="cov0" title="0">if tags, ok := thought["tags"].([]interface{}); ok </span><span class="cov0" title="0">{
                var newTags []interface{}
                for _, tag := range tags </span><span class="cov0" title="0">{
                        if tag != "processed" </span><span class="cov0" title="0">{
                                newTags = append(newTags, tag)
                        }</span>
                }
                <span class="cov0" title="0">thought["tags"] = newTags</span>
        }

        // Process thought
        <span class="cov0" title="0">err := h.thoughtProcessingSvc.ProcessThought(r.Context(), thoughtID, thought, req.Model)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to reprocess thought",
                        zap.Error(err),
                        zap.String("uid", uid),
                        zap.String("thoughtId", thoughtID),
                )
                utils.RespondError(w, fmt.Sprintf("Failed to reprocess thought: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">utils.RespondSuccess(w, map[string]interface{}{
                "thoughtId":   thoughtID,
                "reprocessed": true,
        }, "Thought reprocessed successfully")</span>
}

// RevertThoughtProcessing handles POST /api/revert-thought-processing
func (h *ThoughtHandler) RevertThoughtProcessing(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse request
        var req struct {
                ThoughtID string `json:"thoughtId"`
        }
        if err := utils.ParseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.RespondError(w, fmt.Sprintf("Invalid request: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ThoughtID == "" </span><span class="cov0" title="0">{
                utils.RespondError(w, "thoughtId is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">uid := r.Context().Value("uid").(string)

        h.logger.Info("Reverting thought processing",
                zap.String("uid", uid),
                zap.String("thoughtId", req.ThoughtID),
        )

        // TODO: Implement revert logic
        // This would involve:
        // 1. Removing the "processed" tag
        // 2. Deleting AI-created tasks/projects/relationships
        // 3. Clearing aiMetadata
        // 4. Resetting aiProcessingStatus

        utils.RespondSuccess(w, map[string]interface{}{
                "thoughtId": req.ThoughtID,
                "reverted":  true,
        }, "Thought processing reverted (feature coming soon)")</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "cloud.google.com/go/firestore"
        "firebase.google.com/go/v4/auth"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

const (
        AnonymousSessionCollection = "anonymousSessions"
)

// AuthMiddleware verifies Firebase ID tokens
// Matches verifyAiRequest from src/lib/server/verifyAiRequest.ts
type AuthMiddleware struct {
        authClient      *auth.Client
        firestoreClient *firestore.Client
        overrideKey     string
}

// NewAuthMiddleware creates a new auth middleware
func NewAuthMiddleware(authClient *auth.Client, firestoreClient *firestore.Client, overrideKey string) *AuthMiddleware <span class="cov8" title="1">{
        return &amp;AuthMiddleware{
                authClient:      authClient,
                firestoreClient: firestoreClient,
                overrideKey:     overrideKey,
        }
}</span>

// Authenticate middleware verifies the Firebase ID token
func (m *AuthMiddleware) Authenticate(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Get authorization header
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov8" title="1">{
                        utils.RespondError(w, "Missing authorization token", http.StatusUnauthorized)
                        return
                }</span>

                // Extract token
                <span class="cov8" title="1">token := strings.TrimPrefix(authHeader, "Bearer ")
                token = strings.TrimSpace(token)
                if token == "" </span><span class="cov8" title="1">{
                        utils.RespondError(w, "Missing authorization token", http.StatusUnauthorized)
                        return
                }</span>

                // Verify token with Firebase
                <span class="cov0" title="0">decodedToken, err := m.authClient.VerifyIDToken(r.Context(), token)
                if err != nil </span><span class="cov0" title="0">{
                        utils.RespondError(w, fmt.Sprintf("Invalid authentication token: %v", err), http.StatusUnauthorized)
                        return
                }</span>

                // Extract user info
                <span class="cov0" title="0">uid := decodedToken.UID
                signInProvider := getSignInProvider(decodedToken)
                isAnonymous := signInProvider == "anonymous"

                // Add to context
                ctx := context.WithValue(r.Context(), "uid", uid)
                ctx = context.WithValue(ctx, "isAnonymous", isAnonymous)
                ctx = context.WithValue(ctx, "decodedToken", decodedToken)

                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// RequireAI middleware checks if user has AI access
func (m *AuthMiddleware) RequireAI(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                uid, ok := r.Context().Value("uid").(string)
                if !ok </span><span class="cov8" title="1">{
                        utils.RespondError(w, "Missing user ID", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">isAnonymous, ok := r.Context().Value("isAnonymous").(bool)
                if !ok </span><span class="cov0" title="0">{
                        utils.RespondError(w, "Missing anonymous flag", http.StatusUnauthorized)
                        return
                }</span>

                // Non-anonymous users always have access (checked by subscription middleware)
                <span class="cov0" title="0">if !isAnonymous </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Check anonymous AI access
                <span class="cov0" title="0">allowed, err := m.checkAnonymousAIAccess(r.Context(), uid)
                if err != nil </span><span class="cov0" title="0">{
                        utils.RespondError(w, fmt.Sprintf("Failed to check AI access: %v", err), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                        utils.RespondError(w, "Anonymous sessions cannot access AI features", http.StatusForbidden)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// RequireSubscription middleware checks if user has active Pro subscription
func (m *AuthMiddleware) RequireSubscription(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                uid, ok := r.Context().Value("uid").(string)
                if !ok </span><span class="cov8" title="1">{
                        utils.RespondError(w, "Missing user ID", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">isAnonymous, ok := r.Context().Value("isAnonymous").(bool)
                if !ok </span><span class="cov0" title="0">{
                        utils.RespondError(w, "Missing anonymous flag", http.StatusUnauthorized)
                        return
                }</span>

                // Anonymous users are handled by RequireAI middleware
                <span class="cov0" title="0">if isAnonymous </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Check subscription status
                <span class="cov0" title="0">statusPath := fmt.Sprintf("users/%s/subscriptionStatus/current", uid)
                doc, err := m.firestoreClient.Doc(statusPath).Get(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        utils.RespondError(w, "Pro subscription required", http.StatusForbidden)
                        return
                }</span>

                <span class="cov0" title="0">var status models.SubscriptionStatus
                if err := doc.DataTo(&amp;status); err != nil </span><span class="cov0" title="0">{
                        utils.RespondError(w, "Failed to read subscription status", http.StatusInternalServerError)
                        return
                }</span>

                // Check tier and entitlements
                <span class="cov0" title="0">if status.Tier != "pro" </span><span class="cov0" title="0">{
                        utils.RespondError(w, "Pro subscription required", http.StatusForbidden)
                        return
                }</span>

                <span class="cov0" title="0">if status.Entitlements == nil || !status.Entitlements.AiProcessing </span><span class="cov0" title="0">{
                        utils.RespondError(w, "AI processing not enabled in subscription", http.StatusForbidden)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// checkAnonymousAIAccess checks if anonymous user has AI access
// Matches logic from src/lib/server/verifyAiRequest.ts:48-72
func (m *AuthMiddleware) checkAnonymousAIAccess(ctx context.Context, uid string) (bool, error) <span class="cov0" title="0">{
        sessionPath := fmt.Sprintf("%s/%s", AnonymousSessionCollection, uid)
        doc, err := m.firestoreClient.Doc(sessionPath).Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil // Session doesn't exist
        }</span>

        <span class="cov0" title="0">var session models.AnonymousSession
        if err := doc.DataTo(&amp;session); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check allowAi flag
        <span class="cov0" title="0">if !session.AllowAi </span><span class="cov0" title="0">{
                // Check override key
                if m.overrideKey != "" &amp;&amp; session.CiOverrideKey != nil &amp;&amp; *session.CiOverrideKey == m.overrideKey </span>{<span class="cov0" title="0">
                        // Override allows access
                }</span> else<span class="cov0" title="0"> {
                        return false, nil
                }</span>
        }

        // Check cleanup pending
        <span class="cov0" title="0">if session.CleanupPending </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Check expiry
        <span class="cov0" title="0">if session.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                // Mark as expired
                _, err := m.firestoreClient.Doc(sessionPath).Set(ctx, map[string]interface{}{
                        "status":         "expired",
                        "cleanupPending": true,
                        "expiredAt":      time.Now(),
                        "updatedAt":      time.Now(),
                }, firestore.MergeAll)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// getSignInProvider extracts the sign-in provider from the token
func getSignInProvider(token *auth.Token) string <span class="cov8" title="1">{
        if firebase, ok := token.Claims["firebase"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if provider, ok := firebase["sign_in_provider"].(string); ok </span><span class="cov8" title="1">{
                        return provider
                }</span>
        }
        <span class="cov8" title="1">return "unknown"</span>
}

// OptionalAuth is like Authenticate but doesn't fail if no token present
func (m *AuthMiddleware) OptionalAuth(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov8" title="1">{
                        // No auth, continue with empty context
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")
                token = strings.TrimSpace(token)
                if token == "" </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">decodedToken, err := m.authClient.VerifyIDToken(r.Context(), token)
                if err != nil </span><span class="cov0" title="0">{
                        // Invalid token, but don't fail - just continue without auth
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">uid := decodedToken.UID
                signInProvider := getSignInProvider(decodedToken)
                isAnonymous := signInProvider == "anonymous"

                ctx := context.WithValue(r.Context(), "uid", uid)
                ctx = context.WithValue(ctx, "isAnonymous", isAnonymous)
                ctx = context.WithValue(ctx, "decodedToken", decodedToken)

                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/config"
)

// CORS middleware handles Cross-Origin Resource Sharing
func CORS(cfg *config.CORSConfig) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        if !cfg.Enabled </span><span class="cov8" title="1">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov8" title="1">origin := r.Header.Get("Origin")

                        // Check if origin is allowed
                        if origin != "" &amp;&amp; isOriginAllowed(origin, cfg.AllowedOrigins) </span><span class="cov8" title="1">{
                                w.Header().Set("Access-Control-Allow-Origin", origin)
                        }</span>

                        // Set other CORS headers
                        <span class="cov8" title="1">if len(cfg.AllowedMethods) &gt; 0 </span><span class="cov8" title="1">{
                                w.Header().Set("Access-Control-Allow-Methods", strings.Join(cfg.AllowedMethods, ", "))
                        }</span>

                        <span class="cov8" title="1">if len(cfg.AllowedHeaders) &gt; 0 </span><span class="cov8" title="1">{
                                w.Header().Set("Access-Control-Allow-Headers", strings.Join(cfg.AllowedHeaders, ", "))
                        }</span>

                        <span class="cov8" title="1">if len(cfg.ExposeHeaders) &gt; 0 </span><span class="cov8" title="1">{
                                w.Header().Set("Access-Control-Expose-Headers", strings.Join(cfg.ExposeHeaders, ", "))
                        }</span>

                        <span class="cov8" title="1">if cfg.AllowCredentials </span><span class="cov8" title="1">{
                                w.Header().Set("Access-Control-Allow-Credentials", "true")
                        }</span>

                        <span class="cov8" title="1">if cfg.MaxAge &gt; 0 </span><span class="cov8" title="1">{
                                w.Header().Set("Access-Control-Max-Age", strconv.Itoa(cfg.MaxAge))
                        }</span>

                        // Handle preflight OPTIONS request
                        <span class="cov8" title="1">if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                                w.WriteHeader(http.StatusOK)
                                return
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// isOriginAllowed checks if the origin is in the allowed list
func isOriginAllowed(origin string, allowed []string) bool <span class="cov8" title="1">{
        for _, o := range allowed </span><span class="cov8" title="1">{
                if o == "*" || o == origin </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package middleware

import (
        "net/http"
        "time"

        "go.uber.org/zap"
)

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
        written    int64
}

func newResponseWriter(w http.ResponseWriter) *responseWriter <span class="cov8" title="1">{
        return &amp;responseWriter{
                ResponseWriter: w,
                statusCode:     http.StatusOK,
        }
}</span>

func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        n, err := rw.ResponseWriter.Write(b)
        rw.written += int64(n)
        return n, err
}</span>

// Logging middleware logs HTTP requests
func Logging(logger *zap.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        start := time.Now()

                        // Wrap response writer to capture status
                        wrapped := newResponseWriter(w)

                        // Process request
                        next.ServeHTTP(wrapped, r)

                        // Log after request completes
                        duration := time.Since(start)

                        fields := []zap.Field{
                                zap.String("method", r.Method),
                                zap.String("path", r.URL.Path),
                                zap.String("query", r.URL.RawQuery),
                                zap.Int("status", wrapped.statusCode),
                                zap.Duration("duration", duration),
                                zap.Int64("bytes", wrapped.written),
                                zap.String("remote_addr", r.RemoteAddr),
                                zap.String("user_agent", r.UserAgent()),
                        }

                        // Add user ID if authenticated
                        if uid, ok := r.Context().Value("uid").(string); ok </span><span class="cov0" title="0">{
                                fields = append(fields, zap.String("uid", uid))
                        }</span>

                        // Log level based on status code
                        <span class="cov8" title="1">if wrapped.statusCode &gt;= 500 </span><span class="cov8" title="1">{
                                logger.Error("HTTP request", fields...)
                        }</span> else<span class="cov8" title="1"> if wrapped.statusCode &gt;= 400 </span><span class="cov8" title="1">{
                                logger.Warn("HTTP request", fields...)
                        }</span> else<span class="cov8" title="1"> {
                                logger.Info("HTTP request", fields...)
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package middleware

import (
        "net/http"
        "runtime/debug"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

// Recovery middleware recovers from panics
func Recovery(logger *zap.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if err := recover(); err != nil </span><span class="cov8" title="1">{
                                        // Log the panic with stack trace
                                        logger.Error("Panic recovered",
                                                zap.Any("error", err),
                                                zap.String("path", r.URL.Path),
                                                zap.String("method", r.Method),
                                                zap.String("stack", string(debug.Stack())),
                                        )

                                        // Respond with 500
                                        utils.RespondError(w, "Internal server error", http.StatusInternalServerError)
                                }</span>
                        }()

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "context"
        "fmt"
        "time"

        "cloud.google.com/go/firestore"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// Ensure FirestoreRepository implements interfaces.Repository
var _ interfaces.Repository = (*FirestoreRepository)(nil)

// FirestoreRepository handles Firestore CRUD operations
type FirestoreRepository struct {
        client *firestore.Client
}

// NewFirestoreRepository creates a new Firestore repository
func NewFirestoreRepository(client *firestore.Client) *FirestoreRepository <span class="cov8" title="1">{
        return &amp;FirestoreRepository{
                client: client,
        }
}</span>

// Client returns the underlying Firestore client
func (r *FirestoreRepository) Client() *firestore.Client <span class="cov8" title="1">{
        return r.client
}</span>

// Collection returns a collection reference
func (r *FirestoreRepository) Collection(path string) *firestore.CollectionRef <span class="cov0" title="0">{
        return r.client.Collection(path)
}</span>

// Batch returns a new write batch
func (r *FirestoreRepository) Batch() *firestore.WriteBatch <span class="cov0" title="0">{
        return r.client.Batch()
}</span>

// Get retrieves a document and returns its data as a map
func (r *FirestoreRepository) Get(ctx context.Context, path string) (map[string]interface{}, error) <span class="cov0" title="0">{
        ref := r.client.Doc(path)
        snap, err := ref.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document at %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return snap.Data(), nil</span>
}

// Create creates a new document (alias for CreateDocument)
func (r *FirestoreRepository) Create(ctx context.Context, path string, data map[string]interface{}) error <span class="cov0" title="0">{
        return r.CreateDocument(ctx, path, data)
}</span>

// Update updates a document (alias for UpdateDocument)
func (r *FirestoreRepository) Update(ctx context.Context, path string, data map[string]interface{}) error <span class="cov0" title="0">{
        return r.UpdateDocument(ctx, path, data)
}</span>

// Delete deletes a document (alias for DeleteDocument)
func (r *FirestoreRepository) Delete(ctx context.Context, path string) error <span class="cov0" title="0">{
        return r.DeleteDocument(ctx, path)
}</span>

// List retrieves documents from a collection with optional limit
func (r *FirestoreRepository) List(ctx context.Context, collectionPath string, limit int) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := r.client.Collection(collectionPath).Query
        if limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(limit)
        }</span>

        <span class="cov0" title="0">docs, err := query.Documents(ctx).GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list collection %s: %w", collectionPath, err)
        }</span>

        <span class="cov0" title="0">result := make([]map[string]interface{}, len(docs))
        for i, doc := range docs </span><span class="cov0" title="0">{
                result[i] = doc.Data()
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// CreateDocument creates a new document with metadata
// Matches createAt() from src/lib/data/gateway.ts:59-68
func (r *FirestoreRepository) CreateDocument(ctx context.Context, path string, data map[string]interface{}) error <span class="cov0" title="0">{
        uid := GetUIDFromContext(ctx)

        // Add metadata
        now := time.Now()
        data["createdAt"] = now
        data["updatedAt"] = now
        data["updatedBy"] = uid
        data["version"] = 1

        // Remove undefined values
        cleanData := RemoveUndefinedValues(data)

        ref := r.client.Doc(path)
        _, err := ref.Set(ctx, cleanData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document at %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetDocument sets/merges a document with metadata
// Matches setAt() from src/lib/data/gateway.ts:74-86
func (r *FirestoreRepository) SetDocument(ctx context.Context, path string, data map[string]interface{}) error <span class="cov0" title="0">{
        uid := GetUIDFromContext(ctx)

        // Add metadata
        data["updatedAt"] = time.Now()
        data["updatedBy"] = uid
        data["version"] = firestore.Increment(1)

        cleanData := RemoveUndefinedValues(data)

        ref := r.client.Doc(path)
        _, err := ref.Set(ctx, cleanData, firestore.MergeAll)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set document at %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateDocument updates specific fields in a document
// Matches updateAt() from src/lib/data/gateway.ts:92-100
func (r *FirestoreRepository) UpdateDocument(ctx context.Context, path string, updates map[string]interface{}) error <span class="cov0" title="0">{
        uid := GetUIDFromContext(ctx)

        // Add metadata
        updates["updatedAt"] = time.Now()
        updates["updatedBy"] = uid
        updates["version"] = firestore.Increment(1)

        cleanUpdates := RemoveUndefinedValues(updates)

        // Convert to []firestore.Update
        var fieldUpdates []firestore.Update
        cleanMap, ok := cleanUpdates.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert updates to map")
        }</span>
        <span class="cov0" title="0">for key, value := range cleanMap </span><span class="cov0" title="0">{
                fieldUpdates = append(fieldUpdates, firestore.Update{
                        Path:  key,
                        Value: value,
                })
        }</span>

        <span class="cov0" title="0">ref := r.client.Doc(path)
        _, err := ref.Update(ctx, fieldUpdates)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document at %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteDocument deletes a document
// Matches deleteAt() from src/lib/data/gateway.ts:105-108
func (r *FirestoreRepository) DeleteDocument(ctx context.Context, path string) error <span class="cov0" title="0">{
        ref := r.client.Doc(path)
        _, err := ref.Delete(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document at %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocument retrieves a single document
func (r *FirestoreRepository) GetDocument(ctx context.Context, path string) (*firestore.DocumentSnapshot, error) <span class="cov0" title="0">{
        ref := r.client.Doc(path)
        snap, err := ref.Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document at %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return snap, nil</span>
}

// QueryCollection queries a collection with optional filters
func (r *FirestoreRepository) QueryCollection(ctx context.Context, collectionPath string, opts ...interfaces.QueryOption) ([]*firestore.DocumentSnapshot, error) <span class="cov0" title="0">{
        query := r.client.Collection(collectionPath).Query

        // Apply options
        for _, opt := range opts </span><span class="cov0" title="0">{
                query = opt(query)
        }</span>

        <span class="cov0" title="0">docs, err := query.Documents(ctx).GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query collection %s: %w", collectionPath, err)
        }</span>

        <span class="cov0" title="0">return docs, nil</span>
}

// GetCollection retrieves all documents in a collection
func (r *FirestoreRepository) GetCollection(ctx context.Context, collectionPath string) ([]*firestore.DocumentSnapshot, error) <span class="cov0" title="0">{
        return r.QueryCollection(ctx, collectionPath)
}</span>

// QueryOption is a function that modifies a Firestore query (alias for interfaces.QueryOption)
type QueryOption = interfaces.QueryOption

// Where adds a where clause to the query
func Where(field string, op string, value interface{}) QueryOption <span class="cov0" title="0">{
        return func(q firestore.Query) firestore.Query </span><span class="cov0" title="0">{
                return q.Where(field, op, value)
        }</span>
}

// OrderBy adds ordering to the query
func OrderBy(field string, direction firestore.Direction) QueryOption <span class="cov0" title="0">{
        return func(q firestore.Query) firestore.Query </span><span class="cov0" title="0">{
                return q.OrderBy(field, direction)
        }</span>
}

// Limit limits the number of results
func Limit(n int) QueryOption <span class="cov0" title="0">{
        return func(q firestore.Query) firestore.Query </span><span class="cov0" title="0">{
                return q.Limit(n)
        }</span>
}

// GetUIDFromContext extracts the user ID from context
func GetUIDFromContext(ctx context.Context) string <span class="cov8" title="1">{
        if uid, ok := ctx.Value("uid").(string); ok </span><span class="cov8" title="1">{
                return uid
        }</span>
        <span class="cov8" title="1">return "anon"</span>
}

// RemoveUndefinedValues recursively removes nil values from maps
// Matches removeUndefined() from src/lib/data/gateway.ts:15-53
func RemoveUndefinedValues(obj interface{}) interface{} <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                cleaned := make(map[string]interface{})
                for key, value := range v </span><span class="cov8" title="1">{
                        if value != nil </span><span class="cov8" title="1">{
                                cleanedValue := RemoveUndefinedValues(value)
                                if cleanedValue != nil </span><span class="cov8" title="1">{
                                        cleaned[key] = cleanedValue
                                }</span>
                        }
                }
                <span class="cov8" title="1">return cleaned</span>

        case []interface{}:<span class="cov0" title="0">
                var cleaned []interface{}
                for _, item := range v </span><span class="cov0" title="0">{
                        if item != nil </span><span class="cov0" title="0">{
                                cleanedItem := RemoveUndefinedValues(item)
                                if cleanedItem != nil </span><span class="cov0" title="0">{
                                        cleaned = append(cleaned, cleanedItem)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return cleaned</span>

        default:<span class="cov8" title="1">
                return obj</span>
        }
}

// BatchWrite provides batch write operations
type BatchWrite struct {
        batch *firestore.WriteBatch
        count int
}

// NewBatchWrite creates a new batch write
func (r *FirestoreRepository) NewBatchWrite(ctx context.Context) *BatchWrite <span class="cov0" title="0">{
        return &amp;BatchWrite{
                batch: r.client.Batch(),
                count: 0,
        }
}</span>

// Create adds a create operation to the batch
func (b *BatchWrite) Create(ref *firestore.DocumentRef, data map[string]interface{}) <span class="cov0" title="0">{
        b.batch.Create(ref, data)
        b.count++
}</span>

// Update adds an update operation to the batch
func (b *BatchWrite) Update(ref *firestore.DocumentRef, updates []firestore.Update) <span class="cov0" title="0">{
        b.batch.Update(ref, updates)
        b.count++
}</span>

// Delete adds a delete operation to the batch
func (b *BatchWrite) Delete(ref *firestore.DocumentRef) <span class="cov0" title="0">{
        b.batch.Delete(ref)
        b.count++
}</span>

// Commit commits the batch
func (b *BatchWrite) Commit(ctx context.Context) error <span class="cov0" title="0">{
        _, err := b.batch.Commit(ctx)
        return err
}</span>

// Count returns the number of operations in the batch
func (b *BatchWrite) Count() int <span class="cov0" title="0">{
        return b.count
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package mocks

import (
        "context"
        "strings"

        "cloud.google.com/go/firestore"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// MockRepository is a mock implementation of Repository for testing
type MockRepository struct {
        // Storage for mock data
        Documents map[string]map[string]interface{} // path -&gt; data
        Client_   *firestore.Client
}

// Ensure MockRepository implements interfaces.Repository
var _ interfaces.Repository = (*MockRepository)(nil)

// NewMockRepository creates a new mock repository
func NewMockRepository() *MockRepository <span class="cov8" title="1">{
        return &amp;MockRepository{
                Documents: make(map[string]map[string]interface{}),
        }
}</span>

// Client returns the Firestore client
func (m *MockRepository) Client() *firestore.Client <span class="cov8" title="1">{
        return m.Client_
}</span>

// Collection returns a collection reference
func (m *MockRepository) Collection(path string) *firestore.CollectionRef <span class="cov8" title="1">{
        if m.Client_ != nil </span><span class="cov0" title="0">{
                return m.Client_.Collection(path)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Batch returns a new write batch
func (m *MockRepository) Batch() *firestore.WriteBatch <span class="cov8" title="1">{
        if m.Client_ != nil </span><span class="cov0" title="0">{
                return m.Client_.Batch()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Get retrieves a document data
func (m *MockRepository) Get(ctx context.Context, path string) (map[string]interface{}, error) <span class="cov8" title="1">{
        if data, ok := m.Documents[path]; ok </span><span class="cov8" title="1">{
                return data, nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

// Create creates a new document
func (m *MockRepository) Create(ctx context.Context, path string, data map[string]interface{}) error <span class="cov8" title="1">{
        m.Documents[path] = data
        return nil
}</span>

// Update updates a document
func (m *MockRepository) Update(ctx context.Context, path string, data map[string]interface{}) error <span class="cov8" title="1">{
        if existing, ok := m.Documents[path]; ok </span><span class="cov8" title="1">{
                for k, v := range data </span><span class="cov8" title="1">{
                        existing[k] = v
                }</span>
        } else<span class="cov8" title="1"> {
                m.Documents[path] = data
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete deletes a document
func (m *MockRepository) Delete(ctx context.Context, path string) error <span class="cov8" title="1">{
        delete(m.Documents, path)
        return nil
}</span>

// List retrieves documents from a collection
func (m *MockRepository) List(ctx context.Context, collectionPath string, limit int) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var results []map[string]interface{}
        for path, data := range m.Documents </span><span class="cov8" title="1">{
                if len(path) &gt; len(collectionPath) &amp;&amp; path[:len(collectionPath)] == collectionPath </span><span class="cov8" title="1">{
                        results = append(results, data)
                        if limit &gt; 0 &amp;&amp; len(results) &gt;= limit </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return results, nil</span>
}

// GetDocument retrieves a document snapshot
func (m *MockRepository) GetDocument(ctx context.Context, path string) (*firestore.DocumentSnapshot, error) <span class="cov0" title="0">{
        // For mock purposes, return nil - tests should use Get() instead
        return nil, nil
}</span>

// SetDocument sets a document with merge
func (m *MockRepository) SetDocument(ctx context.Context, path string, data map[string]interface{}) error <span class="cov8" title="1">{
        return m.Update(ctx, path, data)
}</span>

// UpdateDocument updates specific fields
func (m *MockRepository) UpdateDocument(ctx context.Context, path string, updates map[string]interface{}) error <span class="cov8" title="1">{
        return m.Update(ctx, path, updates)
}</span>

// DeleteDocument deletes a document
func (m *MockRepository) DeleteDocument(ctx context.Context, path string) error <span class="cov8" title="1">{
        return m.Delete(ctx, path)
}</span>

// CreateDocument creates a new document with metadata
func (m *MockRepository) CreateDocument(ctx context.Context, path string, data map[string]interface{}) error <span class="cov8" title="1">{
        return m.Create(ctx, path, data)
}</span>

// QueryCollection queries a collection
func (m *MockRepository) QueryCollection(ctx context.Context, collectionPath string, opts ...interfaces.QueryOption) ([]*firestore.DocumentSnapshot, error) <span class="cov8" title="1">{
        // For mock purposes, return empty slice
        return []*firestore.DocumentSnapshot{}, nil
}</span>

// AddDocument is a helper for tests to add mock data
func (m *MockRepository) AddDocument(path string, data map[string]interface{}) <span class="cov8" title="1">{
        m.Documents[path] = data
}</span>

// GetCollectionDocuments retrieves documents matching a collection path pattern
func (m *MockRepository) GetCollectionDocuments(collectionPath string) []map[string]interface{} <span class="cov8" title="1">{
        var results []map[string]interface{}
        for path, data := range m.Documents </span><span class="cov8" title="1">{
                if len(path) &gt; len(collectionPath) &amp;&amp; path[:len(collectionPath)] == collectionPath </span><span class="cov8" title="1">{
                        // Add the document with its ID
                        docData := make(map[string]interface{})
                        for k, v := range data </span><span class="cov8" title="1">{
                                docData[k] = v
                        }</span>
                        // Extract ID from path (last segment)
                        <span class="cov8" title="1">parts := strings.Split(path, "/")
                        if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                                docData["id"] = parts[len(parts)-1]
                        }</span>
                        <span class="cov8" title="1">results = append(results, docData)</span>
                }
        }
        <span class="cov8" title="1">return results</span>
}

// GetCollectionDocumentsFiltered retrieves documents matching filters
func (m *MockRepository) GetCollectionDocumentsFiltered(collectionPath string, filters map[string]interface{}, order string) []map[string]interface{} <span class="cov8" title="1">{
        docs := m.GetCollectionDocuments(collectionPath)

        // Apply filters
        filtered := []map[string]interface{}{}
        for _, doc := range docs </span><span class="cov8" title="1">{
                match := true
                for key, filterValue := range filters </span><span class="cov8" title="1">{
                        if docValue, ok := doc[key]; !ok || docValue != filterValue </span><span class="cov8" title="1">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        filtered = append(filtered, doc)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository"
)

// ActionProcessor executes AI-suggested actions
type ActionProcessor struct {
        repo   *repository.FirestoreRepository
        logger *zap.Logger
}

// NewActionProcessor creates a new action processor
func NewActionProcessor(repo *repository.FirestoreRepository, logger *zap.Logger) *ActionProcessor <span class="cov8" title="1">{
        return &amp;ActionProcessor{
                repo:   repo,
                logger: logger,
        }
}</span>

// ExecuteAction executes a single AI action
func (a *ActionProcessor) ExecuteAction(ctx context.Context, uid, thoughtID string, action models.AIAction) error <span class="cov0" title="0">{
        a.logger.Debug("Executing action",
                zap.String("uid", uid),
                zap.String("thoughtId", thoughtID),
                zap.String("actionType", action.Type),
                zap.Int("confidence", action.Confidence),
        )

        switch action.Type </span>{
        case "createTask":<span class="cov0" title="0">
                return a.createTask(ctx, uid, thoughtID, action.Data)</span>
        case "createProject":<span class="cov0" title="0">
                return a.createProject(ctx, uid, thoughtID, action.Data)</span>
        case "createGoal":<span class="cov0" title="0">
                return a.createGoal(ctx, uid, thoughtID, action.Data)</span>
        case "createMood":<span class="cov0" title="0">
                return a.createMood(ctx, uid, thoughtID, action.Data)</span>
        case "createRelationship":<span class="cov0" title="0">
                return a.createRelationship(ctx, uid, thoughtID, action.Data)</span>
        case "enhanceTask":<span class="cov0" title="0">
                return a.enhanceTask(ctx, uid, thoughtID, action.Data)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown action type: %s", action.Type)</span>
        }
}

// createTask creates a new task
func (a *ActionProcessor) createTask(ctx context.Context, uid, thoughtID string, data map[string]interface{}) error <span class="cov0" title="0">{
        // Generate task ID
        taskID := generateID()
        taskPath := fmt.Sprintf("users/%s/tasks/%s", uid, taskID)

        // Build task data
        taskData := map[string]interface{}{
                "id":     taskID,
                "title":  getStringFieldFromMap(data, "title"),
                "done":   false,
                "status": "active",
        }

        // Optional fields
        if category := getStringFieldFromMap(data, "category"); category != "" </span><span class="cov0" title="0">{
                taskData["category"] = category
        }</span>
        <span class="cov0" title="0">if priority := getStringFieldFromMap(data, "priority"); priority != "" </span><span class="cov0" title="0">{
                taskData["priority"] = priority
        }</span>
        <span class="cov0" title="0">if notes := getStringFieldFromMap(data, "notes"); notes != "" </span><span class="cov0" title="0">{
                taskData["notes"] = notes
        }</span>

        // Link to thought
        <span class="cov0" title="0">taskData["thoughtId"] = thoughtID
        taskData["createdBy"] = "ai"

        // Create task
        err := a.repo.CreateDocument(ctx, taskPath, taskData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create task: %w", err)
        }</span>

        <span class="cov0" title="0">a.logger.Info("Task created",
                zap.String("uid", uid),
                zap.String("taskId", taskID),
                zap.String("thoughtId", thoughtID),
        )

        return nil</span>
}

// createProject creates a new project
func (a *ActionProcessor) createProject(ctx context.Context, uid, thoughtID string, data map[string]interface{}) error <span class="cov0" title="0">{
        projectID := generateID()
        projectPath := fmt.Sprintf("users/%s/projects/%s", uid, projectID)

        projectData := map[string]interface{}{
                "id":          projectID,
                "title":       getStringFieldFromMap(data, "title"),
                "description": getStringFieldFromMap(data, "description"),
                "status":      "active",
                "thoughtId":   thoughtID,
                "createdBy":   "ai",
        }

        err := a.repo.CreateDocument(ctx, projectPath, projectData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create project: %w", err)
        }</span>

        <span class="cov0" title="0">a.logger.Info("Project created",
                zap.String("uid", uid),
                zap.String("projectId", projectID),
                zap.String("thoughtId", thoughtID),
        )

        return nil</span>
}

// createGoal creates a new goal
func (a *ActionProcessor) createGoal(ctx context.Context, uid, thoughtID string, data map[string]interface{}) error <span class="cov0" title="0">{
        goalID := generateID()
        goalPath := fmt.Sprintf("users/%s/goals/%s", uid, goalID)

        goalData := map[string]interface{}{
                "id":        goalID,
                "title":     getStringFieldFromMap(data, "title"),
                "objective": getStringFieldFromMap(data, "objective"),
                "status":    "active",
                "thoughtId": thoughtID,
                "createdBy": "ai",
        }

        err := a.repo.CreateDocument(ctx, goalPath, goalData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create goal: %w", err)
        }</span>

        <span class="cov0" title="0">a.logger.Info("Goal created",
                zap.String("uid", uid),
                zap.String("goalId", goalID),
                zap.String("thoughtId", thoughtID),
        )

        return nil</span>
}

// createMood creates a mood entry
func (a *ActionProcessor) createMood(ctx context.Context, uid, thoughtID string, data map[string]interface{}) error <span class="cov0" title="0">{
        moodID := generateID()
        moodPath := fmt.Sprintf("users/%s/moods/%s", uid, moodID)

        moodData := map[string]interface{}{
                "id":        moodID,
                "value":     getIntFieldFromMap(data, "value"),
                "note":      getStringFieldFromMap(data, "note"),
                "thoughtId": thoughtID,
                "createdBy": "ai",
        }

        err := a.repo.CreateDocument(ctx, moodPath, moodData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create mood: %w", err)
        }</span>

        <span class="cov0" title="0">a.logger.Info("Mood created",
                zap.String("uid", uid),
                zap.String("moodId", moodID),
                zap.String("thoughtId", thoughtID),
        )

        return nil</span>
}

// createRelationship creates a relationship in the entity graph
func (a *ActionProcessor) createRelationship(ctx context.Context, uid, thoughtID string, data map[string]interface{}) error <span class="cov0" title="0">{
        relationshipID := generateID()
        relationshipPath := fmt.Sprintf("users/%s/entity_graph/%s", uid, relationshipID)

        relationshipData := map[string]interface{}{
                "id":               relationshipID,
                "sourceType":       "thought",
                "sourceId":         thoughtID,
                "targetType":       getStringFieldFromMap(data, "targetType"),
                "targetId":         getStringFieldFromMap(data, "targetId"),
                "relationshipType": getStringFieldFromMap(data, "relationshipType"),
                "reasoning":        getStringFieldFromMap(data, "reasoning"),
                "createdBy":        "ai",
        }

        err := a.repo.CreateDocument(ctx, relationshipPath, relationshipData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create relationship: %w", err)
        }</span>

        <span class="cov0" title="0">a.logger.Info("Relationship created",
                zap.String("uid", uid),
                zap.String("relationshipId", relationshipID),
                zap.String("thoughtId", thoughtID),
                zap.String("targetType", getStringFieldFromMap(data, "targetType")),
                zap.String("targetId", getStringFieldFromMap(data, "targetId")),
        )

        return nil</span>
}

// enhanceTask enhances an existing task with information from the thought
func (a *ActionProcessor) enhanceTask(ctx context.Context, uid, thoughtID string, data map[string]interface{}) error <span class="cov0" title="0">{
        taskID := getStringFieldFromMap(data, "taskId")
        if taskID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("taskId is required for enhanceTask action")
        }</span>

        <span class="cov0" title="0">taskPath := fmt.Sprintf("users/%s/tasks/%s", uid, taskID)

        // Build updates
        updates := make(map[string]interface{})

        if notes := getStringFieldFromMap(data, "notes"); notes != "" </span><span class="cov0" title="0">{
                updates["notes"] = notes
        }</span>
        <span class="cov0" title="0">if priority := getStringFieldFromMap(data, "priority"); priority != "" </span><span class="cov0" title="0">{
                updates["priority"] = priority
        }</span>
        <span class="cov0" title="0">if category := getStringFieldFromMap(data, "category"); category != "" </span><span class="cov0" title="0">{
                updates["category"] = category
        }</span>

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no updates provided for enhanceTask")
        }</span>

        // Add AI metadata
        <span class="cov0" title="0">updates["aiEnhanced"] = true
        updates["enhancedFromThoughtId"] = thoughtID

        err := a.repo.UpdateDocument(ctx, taskPath, updates)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to enhance task: %w", err)
        }</span>

        <span class="cov0" title="0">a.logger.Info("Task enhanced",
                zap.String("uid", uid),
                zap.String("taskId", taskID),
                zap.String("thoughtId", thoughtID),
        )

        return nil</span>
}

// Helper functions
func getStringFieldFromMap(m map[string]interface{}, key string) string <span class="cov8" title="1">{
        if val, ok := m[key].(string); ok </span><span class="cov8" title="1">{
                return val
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func getIntFieldFromMap(m map[string]interface{}, key string) int <span class="cov8" title="1">{
        if val, ok := m[key].(float64); ok </span><span class="cov8" title="1">{
                return int(val)
        }</span>
        <span class="cov8" title="1">if val, ok := m[key].(int); ok </span><span class="cov8" title="1">{
                return val
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// generateID generates a unique ID (similar to Firestore auto-ID)
func generateID() string <span class="cov8" title="1">{
        // Use timestamp + random component
        return fmt.Sprintf("%d-%d", time.Now().UnixNano(), time.Now().Unix()%1000000)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "context"
        "fmt"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
)

// ChatService handles AI chat conversations
type ChatService struct {
        openaiClient    *clients.OpenAIClient
        anthropicClient *clients.AnthropicClient
        logger          *zap.Logger
}

// NewChatService creates a new chat service
func NewChatService(
        openaiClient *clients.OpenAIClient,
        anthropicClient *clients.AnthropicClient,
        logger *zap.Logger,
) *ChatService <span class="cov8" title="1">{
        return &amp;ChatService{
                openaiClient:    openaiClient,
                anthropicClient: anthropicClient,
                logger:          logger,
        }
}</span>

// ChatMessage represents a single message in a conversation
type ChatMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// ChatResponse represents the response from a chat completion
type ChatResponse struct {
        Message      ChatMessage `json:"message"`
        Model        string      `json:"model"`
        TokensUsed   int         `json:"tokensUsed,omitempty"`
        FinishReason string      `json:"finishReason,omitempty"`
}

// Chat processes a chat conversation and returns a response
func (s *ChatService) Chat(
        ctx context.Context,
        messages []ChatMessage,
        model string,
        temperature float32,
) (*ChatResponse, error) <span class="cov8" title="1">{
        if len(messages) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("messages array cannot be empty")
        }</span>

        // Default to GPT-4o if no model specified
        <span class="cov8" title="1">if model == "" </span><span class="cov8" title="1">{
                model = "gpt-4o"
        }</span>

        <span class="cov8" title="1">s.logger.Info("Processing chat request",
                zap.String("model", model),
                zap.Int("messageCount", len(messages)),
        )

        // Route to appropriate AI provider based on model
        if isOpenAIModel(model) </span><span class="cov8" title="1">{
                return s.chatWithOpenAI(ctx, messages, model, temperature)
        }</span> else<span class="cov8" title="1"> if isAnthropicModel(model) </span><span class="cov8" title="1">{
                return s.chatWithAnthropic(ctx, messages, model, temperature)
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("unsupported model: %s", model)</span>
}

// chatWithOpenAI handles chat using OpenAI
func (s *ChatService) chatWithOpenAI(
        ctx context.Context,
        messages []ChatMessage,
        model string,
        temperature float32,
) (*ChatResponse, error) <span class="cov8" title="1">{
        if s.openaiClient == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("OpenAI client not configured")
        }</span>

        // Convert messages to OpenAI format
        <span class="cov0" title="0">openaiMessages := make([]clients.ChatMessage, len(messages))
        for i, msg := range messages </span><span class="cov0" title="0">{
                openaiMessages[i] = clients.ChatMessage{
                        Role:    msg.Role,
                        Content: msg.Content,
                }
        }</span>

        // Make request to OpenAI
        <span class="cov0" title="0">response, err := s.openaiClient.ChatCompletion(ctx, clients.ChatCompletionRequest{
                Model:       model,
                Messages:    openaiMessages,
                Temperature: temperature,
                MaxTokens:   2000, // Allow longer responses for chat
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OpenAI API error: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ChatResponse{
                Message: ChatMessage{
                        Role:    "assistant",
                        Content: response.Content,
                },
                Model:        response.Model,
                TokensUsed:   response.TokensUsed,
                FinishReason: response.FinishReason,
        }, nil</span>
}

// chatWithAnthropic handles chat using Anthropic Claude
func (s *ChatService) chatWithAnthropic(
        ctx context.Context,
        messages []ChatMessage,
        model string,
        temperature float32,
) (*ChatResponse, error) <span class="cov8" title="1">{
        if s.anthropicClient == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Anthropic client not configured")
        }</span>

        // Anthropic requires at least one message and the first message must be from the user
        <span class="cov0" title="0">if len(messages) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("messages array cannot be empty")
        }</span>

        // Convert messages to Anthropic format (using the shared ChatMessage type)
        <span class="cov0" title="0">anthropicMessages := make([]clients.ChatMessage, 0, len(messages))
        for _, msg := range messages </span><span class="cov0" title="0">{
                anthropicMessages = append(anthropicMessages, clients.ChatMessage{
                        Role:    msg.Role,
                        Content: msg.Content,
                })
        }</span>

        // Make request to Anthropic using ChatCompletion (same interface as OpenAI)
        <span class="cov0" title="0">response, err := s.anthropicClient.ChatCompletion(ctx, clients.ChatCompletionRequest{
                Model:       model,
                Messages:    anthropicMessages,
                MaxTokens:   2000,
                Temperature: temperature,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Anthropic API error: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ChatResponse{
                Message: ChatMessage{
                        Role:    "assistant",
                        Content: response.Content,
                },
                Model:        response.Model,
                TokensUsed:   response.TokensUsed,
                FinishReason: response.FinishReason,
        }, nil</span>
}

// isOpenAIModel checks if the model is an OpenAI model
func isOpenAIModel(model string) bool <span class="cov8" title="1">{
        openaiModels := map[string]bool{
                "gpt-4o":             true,
                "gpt-4o-mini":        true,
                "gpt-4":              true,
                "gpt-4-turbo":        true,
                "gpt-3.5-turbo":      true,
                "gpt-4-1106-preview": true,
                "gpt-4-0125-preview": true,
        }
        return openaiModels[model]
}</span>

// isAnthropicModel checks if the model is an Anthropic model
func isAnthropicModel(model string) bool <span class="cov8" title="1">{
        anthropicModels := map[string]bool{
                "claude-3-5-sonnet-20241022": true,
                "claude-3-5-haiku-20241022":  true,
                "claude-3-opus-20240229":     true,
                "claude-3-sonnet-20240229":   true,
                "claude-3-haiku-20240307":    true,
                "claude-2.1":                 true,
                "claude-2.0":                 true,
        }
        return anthropicModels[model]
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "context"
        "fmt"

        "cloud.google.com/go/firestore"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository"
)

// ContextGathererService gathers user context for AI processing
// Matches contextGatherer.ts from Firebase Functions
type ContextGathererService struct {
        repo   *repository.FirestoreRepository
        logger *zap.Logger
}

// NewContextGathererService creates a new context gatherer service
func NewContextGathererService(repo *repository.FirestoreRepository, logger *zap.Logger) *ContextGathererService <span class="cov0" title="0">{
        return &amp;ContextGathererService{
                repo:   repo,
                logger: logger,
        }
}</span>

// GatherContext gathers user's goals, tasks, projects, etc. for AI context
func (s *ContextGathererService) GatherContext(ctx context.Context, uid string) (*models.UserContext, error) <span class="cov0" title="0">{
        s.logger.Debug("Gathering user context", zap.String("uid", uid))

        userContext := &amp;models.UserContext{
                Goals:         []map[string]interface{}{},
                Projects:      []map[string]interface{}{},
                Tasks:         []map[string]interface{}{},
                Moods:         []map[string]interface{}{},
                Relationships: []map[string]interface{}{},
                Notes:         []map[string]interface{}{},
                Errands:       []map[string]interface{}{},
        }

        // Gather goals
        goals, err := s.getCollection(ctx, fmt.Sprintf("users/%s/goals", uid), 20)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to fetch goals", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                userContext.Goals = goals
        }</span>

        // Gather projects
        <span class="cov0" title="0">projects, err := s.getCollection(ctx, fmt.Sprintf("users/%s/projects", uid), 20)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to fetch projects", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                userContext.Projects = projects
        }</span>

        // Gather active tasks
        <span class="cov0" title="0">tasks, err := s.getActiveTasks(ctx, uid)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to fetch tasks", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                userContext.Tasks = tasks
        }</span>

        // Gather recent moods
        <span class="cov0" title="0">moods, err := s.getRecentMoods(ctx, uid)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to fetch moods", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                userContext.Moods = moods
        }</span>

        // Gather relationships
        <span class="cov0" title="0">relationships, err := s.getCollection(ctx, fmt.Sprintf("users/%s/people", uid), 20)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to fetch relationships", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                userContext.Relationships = relationships
        }</span>

        // Gather recent notes
        <span class="cov0" title="0">notes, err := s.getCollection(ctx, fmt.Sprintf("users/%s/notes", uid), 10)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to fetch notes", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                userContext.Notes = notes
        }</span>

        // Gather active errands
        <span class="cov0" title="0">errands, err := s.getActiveErrands(ctx, uid)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to fetch errands", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                userContext.Errands = errands
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Context gathered",
                zap.String("uid", uid),
                zap.Int("goals", len(userContext.Goals)),
                zap.Int("projects", len(userContext.Projects)),
                zap.Int("tasks", len(userContext.Tasks)),
                zap.Int("moods", len(userContext.Moods)),
        )

        return userContext, nil</span>
}

// getCollection fetches documents from a collection
func (s *ContextGathererService) getCollection(ctx context.Context, collectionPath string, limit int) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        docs, err := s.repo.QueryCollection(ctx, collectionPath,
                repository.OrderBy("createdAt", firestore.Desc),
                repository.Limit(limit),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var results []map[string]interface{}
        for _, doc := range docs </span><span class="cov0" title="0">{
                data := doc.Data()
                data["id"] = doc.Ref.ID
                results = append(results, data)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// getActiveTasks fetches active tasks (not completed or archived)
func (s *ContextGathererService) getActiveTasks(ctx context.Context, uid string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        collectionPath := fmt.Sprintf("users/%s/tasks", uid)

        docs, err := s.repo.QueryCollection(ctx, collectionPath,
                repository.Where("status", "==", "active"),
                repository.OrderBy("priority", firestore.Desc),
                repository.Limit(20),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var results []map[string]interface{}
        for _, doc := range docs </span><span class="cov0" title="0">{
                data := doc.Data()
                data["id"] = doc.Ref.ID
                results = append(results, data)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// getRecentMoods fetches recent mood entries
func (s *ContextGathererService) getRecentMoods(ctx context.Context, uid string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        collectionPath := fmt.Sprintf("users/%s/moods", uid)

        docs, err := s.repo.QueryCollection(ctx, collectionPath,
                repository.OrderBy("createdAt", firestore.Desc),
                repository.Limit(10),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var results []map[string]interface{}
        for _, doc := range docs </span><span class="cov0" title="0">{
                data := doc.Data()
                data["id"] = doc.Ref.ID
                results = append(results, data)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// getActiveErrands fetches active errands (not completed)
func (s *ContextGathererService) getActiveErrands(ctx context.Context, uid string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        collectionPath := fmt.Sprintf("users/%s/errands", uid)

        docs, err := s.repo.QueryCollection(ctx, collectionPath,
                repository.Where("completed", "==", false),
                repository.OrderBy("createdAt", firestore.Desc),
                repository.Limit(15),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var results []map[string]interface{}
        for _, doc := range docs </span><span class="cov0" title="0">{
                data := doc.Data()
                data["id"] = doc.Ref.ID
                results = append(results, data)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "context"
        "fmt"
        "io"
        "time"

        "cloud.google.com/go/storage"
        "github.com/google/uuid"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/utils"
)

const (
        CSVBatchSize        = 50  // Process 50 transactions at a time
        FirestoreBatchLimit = 450 // Firestore batch limit is 500, use 450 for safety
)

// CSVProcessingService handles CSV file processing
type CSVProcessingService struct {
        repo              interfaces.Repository
        storageClient     *storage.Client
        categorizationSvc *TransactionCategorizationService
        logger            *zap.Logger
        bucketName        string
}

// NewCSVProcessingService creates a new CSV processing service
func NewCSVProcessingService(
        repo interfaces.Repository,
        storageClient *storage.Client,
        categorizationSvc *TransactionCategorizationService,
        bucketName string,
        logger *zap.Logger,
) *CSVProcessingService <span class="cov0" title="0">{
        return &amp;CSVProcessingService{
                repo:              repo,
                storageClient:     storageClient,
                categorizationSvc: categorizationSvc,
                bucketName:        bucketName,
                logger:            logger,
        }
}</span>

// ProcessCSVFile processes an uploaded CSV file
func (s *CSVProcessingService) ProcessCSVFile(
        ctx context.Context,
        userID string,
        fileName string,
        storagePath string,
) (int, error) <span class="cov0" title="0">{
        s.logger.Info("Processing CSV file",
                zap.String("uid", userID),
                zap.String("fileName", fileName),
                zap.String("storagePath", storagePath),
        )

        // Download CSV from storage
        csvContent, err := s.downloadFile(ctx, storagePath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to download CSV: %w", err)
        }</span>

        // Parse CSV
        <span class="cov0" title="0">transactions, err := utils.ParseCSV(csvContent)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse CSV: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Parsed CSV",
                zap.Int("transactionCount", len(transactions)),
        )

        if len(transactions) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("no valid transactions found in CSV")
        }</span>

        // Process in batches
        <span class="cov0" title="0">totalProcessed := 0
        for i := 0; i &lt; len(transactions); i += CSVBatchSize </span><span class="cov0" title="0">{
                end := i + CSVBatchSize
                if end &gt; len(transactions) </span><span class="cov0" title="0">{
                        end = len(transactions)
                }</span>

                <span class="cov0" title="0">batch := transactions[i:end]

                // Enhance with AI
                enhanced, err := s.categorizationSvc.EnhanceTransactions(ctx, batch)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to enhance batch",
                                zap.Int("batchStart", i),
                                zap.Int("batchSize", len(batch)),
                                zap.Error(err),
                        )
                        continue</span> // Continue with next batch even if this one fails
                }

                // Save to Firestore
                <span class="cov0" title="0">saved, err := s.saveTransactions(ctx, userID, fileName, batch, enhanced.Transactions)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to save batch",
                                zap.Int("batchStart", i),
                                zap.Int("batchSize", len(batch)),
                                zap.Error(err),
                        )
                        continue</span>
                }

                <span class="cov0" title="0">totalProcessed += saved
                s.logger.Info("Processed batch",
                        zap.Int("batchStart", i),
                        zap.Int("saved", saved),
                        zap.Int("totalProcessed", totalProcessed),
                )</span>
        }

        // Update statement record
        <span class="cov0" title="0">if err := s.updateStatement(ctx, userID, fileName, storagePath, "completed", totalProcessed, ""); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to update statement",
                        zap.Error(err),
                )
        }</span>

        <span class="cov0" title="0">s.logger.Info("CSV processing completed",
                zap.String("uid", userID),
                zap.String("fileName", fileName),
                zap.Int("totalProcessed", totalProcessed),
        )

        return totalProcessed, nil</span>
}

// DeleteCSVStatement deletes a CSV statement and its transactions
func (s *CSVProcessingService) DeleteCSVStatement(
        ctx context.Context,
        userID string,
        fileName string,
) error <span class="cov0" title="0">{
        s.logger.Info("Deleting CSV statement",
                zap.String("uid", userID),
                zap.String("fileName", fileName),
        )

        // TODO: Delete associated transactions
        // For now, just delete the statement record

        // Delete statement record
        path := fmt.Sprintf("users/%s/statements/%s", userID, fileName)
        if err := s.repo.Delete(ctx, path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete statement: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// downloadFile downloads a file from Cloud Storage
func (s *CSVProcessingService) downloadFile(ctx context.Context, objectPath string) (string, error) <span class="cov0" title="0">{
        bucket := s.storageClient.Bucket(s.bucketName)
        obj := bucket.Object(objectPath)

        reader, err := obj.NewReader(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create reader: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = reader.Close() }</span>()

        <span class="cov0" title="0">data, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov0" title="0">return string(data), nil</span>
}

// saveTransactions saves transactions to Firestore in batches
func (s *CSVProcessingService) saveTransactions(
        ctx context.Context,
        userID string,
        fileName string,
        rawTransactions []models.CSVTransaction,
        enhancedTransactions []models.EnhancedTransaction,
) (int, error) <span class="cov0" title="0">{
        if len(rawTransactions) != len(enhancedTransactions) </span><span class="cov0" title="0">{
                s.logger.Warn("Mismatch between raw and enhanced transaction counts",
                        zap.Int("raw", len(rawTransactions)),
                        zap.Int("enhanced", len(enhancedTransactions)),
                )
        }</span>

        <span class="cov0" title="0">count := 0
        batchData := make([]map[string]interface{}, 0, FirestoreBatchLimit)
        batchPaths := make([]string, 0, FirestoreBatchLimit)

        for i := 0; i &lt; len(rawTransactions); i++ </span><span class="cov0" title="0">{
                raw := rawTransactions[i]

                // Get enhanced data if available
                var enhanced *models.EnhancedTransaction
                if i &lt; len(enhancedTransactions) </span><span class="cov0" title="0">{
                        enhanced = &amp;enhancedTransactions[i]
                }</span>

                <span class="cov0" title="0">transactionID := uuid.New().String()
                path := fmt.Sprintf("users/%s/transactions/%s", userID, transactionID)

                // Build transaction data
                txData := map[string]interface{}{
                        "id":          transactionID,
                        "accountId":   "csv-upload",
                        "csvFileName": fileName,
                        "date":        raw.Date,
                        "description": raw.Description,
                        "amount":      raw.Amount,
                        "source":      "csv-upload",
                        "enhanced":    enhanced != nil,
                        "createdAt":   time.Now().UTC().Format(time.RFC3339),
                }

                // Add enhanced fields if available
                if enhanced != nil </span><span class="cov0" title="0">{
                        txData["merchant"] = enhanced.MerchantName
                        txData["category"] = enhanced.Category
                        txData["notes"] = enhanced.Notes
                        if enhanced.IsSubscription </span><span class="cov0" title="0">{
                                txData["tags"] = []string{"subscription"}
                        }</span> else<span class="cov0" title="0"> {
                                txData["tags"] = []string{}
                        }</span>
                }

                <span class="cov0" title="0">batchData = append(batchData, txData)
                batchPaths = append(batchPaths, path)
                count++

                // Commit batch when reaching limit
                if len(batchData) &gt;= FirestoreBatchLimit </span><span class="cov0" title="0">{
                        if err := s.writeBatch(ctx, batchPaths, batchData); err != nil </span><span class="cov0" title="0">{
                                return count - len(batchData), err
                        }</span>
                        <span class="cov0" title="0">batchData = batchData[:0]
                        batchPaths = batchPaths[:0]</span>
                }
        }

        // Commit remaining transactions
        <span class="cov0" title="0">if len(batchData) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.writeBatch(ctx, batchPaths, batchData); err != nil </span><span class="cov0" title="0">{
                        return count - len(batchData), err
                }</span>
        }

        <span class="cov0" title="0">return count, nil</span>
}

// writeBatch writes a batch of documents to Firestore
func (s *CSVProcessingService) writeBatch(ctx context.Context, paths []string, data []map[string]interface{}) error <span class="cov0" title="0">{
        for i, path := range paths </span><span class="cov0" title="0">{
                if err := s.repo.Create(ctx, path, data[i]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write transaction %d: %w", i, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// updateStatement updates or creates a statement record
func (s *CSVProcessingService) updateStatement(
        ctx context.Context,
        userID string,
        fileName string,
        storagePath string,
        status string,
        processedCount int,
        errorMsg string,
) error <span class="cov0" title="0">{
        path := fmt.Sprintf("users/%s/statements/%s", userID, fileName)

        data := map[string]interface{}{
                "id":             fileName,
                "fileName":       fileName,
                "storagePath":    storagePath,
                "status":         status,
                "source":         "csv-upload",
                "processedCount": processedCount,
                "uploadedAt":     time.Now().UTC().Format(time.RFC3339),
                "updatedAt":      time.Now().UTC().Format(time.RFC3339),
        }

        if errorMsg != "" </span><span class="cov0" title="0">{
                data["error"] = errorMsg
        }</span>

        <span class="cov0" title="0">return s.repo.Create(ctx, path, data)</span>
}

// CategoryMapping represents a transaction category with confidence
type CategoryMapping struct {
        Level1     string
        Level2     string
        Confidence float64
}

// CategorizeTransaction categorizes a single transaction
func (s *CSVProcessingService) CategorizeTransaction(
        ctx context.Context,
        userID string,
        merchant string,
        description string,
        plaidCategories []string,
) (*CategoryMapping, error) <span class="cov0" title="0">{
        s.logger.Info("Categorizing transaction",
                zap.String("uid", userID),
                zap.String("merchant", merchant),
        )

        // Use the categorization service to categorize
        // For now, use the enhanced transaction method with a single item
        csvTx := []models.CSVTransaction{
                {
                        Date:        time.Now().Format("2006-01-02"),
                        Description: description,
                        Amount:      0, // Amount not needed for categorization
                },
        }

        result, err := s.categorizationSvc.EnhanceTransactions(ctx, csvTx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to categorize: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result.Transactions) == 0 </span><span class="cov0" title="0">{
                return &amp;CategoryMapping{
                        Level1:     "Other",
                        Level2:     "",
                        Confidence: 0.5,
                }, nil
        }</span>

        <span class="cov0" title="0">enhanced := result.Transactions[0]

        // Map category to level1/level2 structure
        // The category from categorization service is already in the right format
        return &amp;CategoryMapping{
                Level1:     enhanced.Category,
                Level2:     "", // We don't have level2 in our current implementation
                Confidence: 0.85,
        }, nil</span>
}

// LinkTransactionToTrip manually links a transaction to a trip
func (s *CSVProcessingService) LinkTransactionToTrip(
        ctx context.Context,
        userID string,
        transactionID string,
        tripID string,
        confidence float64,
        reasoning string,
) error <span class="cov0" title="0">{
        s.logger.Info("Linking transaction to trip",
                zap.String("uid", userID),
                zap.String("transactionId", transactionID),
                zap.String("tripId", tripID),
        )

        // Get trip details
        tripPath := fmt.Sprintf("users/%s/trips/%s", userID, tripID)
        tripData, err := s.repo.Get(ctx, tripPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("trip not found: %w", err)
        }</span>

        <span class="cov0" title="0">tripName, _ := tripData["name"].(string)
        tripDestination, _ := tripData["destination"].(string)

        // Update transaction
        txPath := fmt.Sprintf("users/%s/transactions/%s", userID, transactionID)

        updateData := map[string]interface{}{
                "tripLinkStatus":    "linked",
                "tripLinkUpdatedAt": time.Now().UnixMilli(),
                "tripLink": map[string]interface{}{
                        "tripId":          tripID,
                        "tripName":        tripName,
                        "tripDestination": tripDestination,
                        "confidence":      confidence,
                        "method":          "manual",
                        "reasoning":       reasoning,
                        "linkedAt":        time.Now().UnixMilli(),
                },
        }

        if err := s.repo.Update(ctx, txPath, updateData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteAllTransactionsSummary summarizes deletion results
type DeleteAllTransactionsSummary struct {
        TransactionsDeleted       int
        ProcessingStatusesDeleted int
        StatementsDeleted         int
        QueuedJobsDeleted         int
}

// DeleteAllTransactions deletes all transactions and related data for a user
func (s *CSVProcessingService) DeleteAllTransactions(
        ctx context.Context,
        userID string,
) (*DeleteAllTransactionsSummary, error) <span class="cov0" title="0">{
        s.logger.Info("Deleting all transactions for user", zap.String("uid", userID))

        summary := &amp;DeleteAllTransactionsSummary{}

        // Delete transactions
        transactionsDeleted, err := s.deleteCollectionInBatches(
                ctx,
                fmt.Sprintf("users/%s/transactions", userID),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete transactions: %w", err)
        }</span>
        <span class="cov0" title="0">summary.TransactionsDeleted = transactionsDeleted

        // Delete CSV processing status
        statusDeleted, err := s.deleteCollectionInBatches(
                ctx,
                fmt.Sprintf("users/%s/csvProcessingStatus", userID),
        )
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to delete CSV processing status", zap.Error(err))
        }</span>
        <span class="cov0" title="0">summary.ProcessingStatusesDeleted = statusDeleted

        // Delete statements
        statementsDeleted, err := s.deleteCollectionInBatches(
                ctx,
                fmt.Sprintf("users/%s/statements", userID),
        )
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to delete statements", zap.Error(err))
        }</span>
        <span class="cov0" title="0">summary.StatementsDeleted = statementsDeleted

        // TODO: Delete queued CSV batch jobs
        // This would require querying a global collection with userID filter
        // For now, we'll skip this

        s.logger.Info("Deleted all transactions",
                zap.String("uid", userID),
                zap.Int("transactions", transactionsDeleted),
                zap.Int("statements", statementsDeleted),
        )

        return summary, nil</span>
}

// deleteCollectionInBatches deletes all documents in a collection path
func (s *CSVProcessingService) deleteCollectionInBatches(
        ctx context.Context,
        collectionPath string,
) (int, error) <span class="cov0" title="0">{
        deleted := 0
        batchSize := FirestoreBatchLimit

        for </span><span class="cov0" title="0">{
                // List documents in the collection
                docs, err := s.repo.List(ctx, collectionPath, batchSize)
                if err != nil </span><span class="cov0" title="0">{
                        return deleted, fmt.Errorf("failed to list documents: %w", err)
                }</span>

                <span class="cov0" title="0">if len(docs) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Delete in batch
                <span class="cov0" title="0">for _, doc := range docs </span><span class="cov0" title="0">{
                        if id, ok := doc["id"].(string); ok </span><span class="cov0" title="0">{
                                path := fmt.Sprintf("%s/%s", collectionPath, id)
                                if err := s.repo.Delete(ctx, path); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn("Failed to delete document",
                                                zap.String("path", path),
                                                zap.Error(err),
                                        )
                                        continue</span>
                                }
                                <span class="cov0" title="0">deleted++</span>
                        }
                }

                // If we got fewer documents than batch size, we're done
                <span class="cov0" title="0">if len(docs) &lt; batchSize </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return deleted, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package services

import (
        "context"
        "fmt"
        "math"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// DashboardAnalyticsService handles dashboard analytics computations
type DashboardAnalyticsService struct {
        repo   interfaces.Repository
        logger *zap.Logger
}

// NewDashboardAnalyticsService creates a new dashboard analytics service
func NewDashboardAnalyticsService(repo interfaces.Repository, logger *zap.Logger) *DashboardAnalyticsService <span class="cov8" title="1">{
        return &amp;DashboardAnalyticsService{
                repo:   repo,
                logger: logger,
        }
}</span>

// SummaryPeriod represents the time period for analytics
type SummaryPeriod string

const (
        PeriodToday SummaryPeriod = "today"
        PeriodWeek  SummaryPeriod = "week"
        PeriodMonth SummaryPeriod = "month"
)

// TimeOfDayStats holds statistics for a time period
type TimeOfDayStats struct {
        Sessions       int     `json:"sessions"`
        TotalTime      int     `json:"totalTime"` // in seconds
        CompletedTasks int     `json:"completedTasks"`
        AvgCompletion  float64 `json:"avgCompletion"` // percentage
}

// DashboardAnalytics holds the complete analytics response
type DashboardAnalytics struct {
        FocusData     []map[string]interface{}  `json:"focusData"`
        TaskData      []map[string]interface{}  `json:"taskData"`
        CategoryData  []map[string]interface{}  `json:"categoryData"`
        TimeOfDayData map[string]TimeOfDayStats `json:"timeOfDayData"`
        Stats         struct {
                TotalFocusTime int     `json:"totalFocusTime"` // in minutes
                TotalSessions  int     `json:"totalSessions"`
                CompletedTasks int     `json:"completedTasks"`
                MasteryTasks   int     `json:"masteryTasks"`
                PleasureTasks  int     `json:"pleasureTasks"`
                CurrentStreak  int     `json:"currentStreak"`
                CompletionRate float64 `json:"completionRate"` // percentage
        } `json:"stats"`
        Comparison *struct {
                FocusTime float64 `json:"focusTime"` // percentage change
                Tasks     float64 `json:"tasks"`     // percentage change
        } `json:"comparison"`
        Goals struct {
                Total     int                    `json:"total"`
                Active    int                    `json:"active"`
                Completed int                    `json:"completed"`
                Progress  float64                `json:"progress"` // percentage
                TopGoal   map[string]interface{} `json:"topGoal"`
        } `json:"goals"`
        Projects struct {
                Total     int     `json:"total"`
                Active    int     `json:"active"`
                Completed int     `json:"completed"`
                Progress  float64 `json:"progress"` // percentage
        } `json:"projects"`
        Period string `json:"period"`
        Days   int    `json:"days"`
}

// ComputeAnalytics computes dashboard analytics for a user
func (s *DashboardAnalyticsService) ComputeAnalytics(ctx context.Context, uid string, period SummaryPeriod) (*DashboardAnalytics, error) <span class="cov8" title="1">{
        s.logger.Debug("Computing dashboard analytics",
                zap.String("uid", uid),
                zap.String("period", string(period)),
        )

        // Determine date range
        startDate, endDate, days := s.resolvePeriodRange(period, time.Now())

        // Fetch data in parallel
        tasksCh := make(chan []map[string]interface{}, 1)
        sessionsCh := make(chan []map[string]interface{}, 1)
        goalsCh := make(chan []map[string]interface{}, 1)
        projectsCh := make(chan []map[string]interface{}, 1)
        errCh := make(chan error, 4)

        // Fetch tasks
        go func() </span><span class="cov8" title="1">{
                tasks, err := s.fetchTasks(ctx, uid, startDate, endDate)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">tasksCh &lt;- tasks</span>
        }()

        // Fetch sessions
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                sessions, err := s.fetchSessions(ctx, uid, startDate, endDate)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">sessionsCh &lt;- sessions</span>
        }()

        // Fetch goals
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                goals, err := s.fetchGoals(ctx, uid)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">goalsCh &lt;- goals</span>
        }()

        // Fetch projects
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                projects, err := s.fetchProjects(ctx, uid)
                if err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">projectsCh &lt;- projects</span>
        }()

        // Wait for all fetches
        <span class="cov8" title="1">var tasks, sessions, goals, projects []map[string]interface{}
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                select </span>{
                case err := &lt;-errCh:<span class="cov0" title="0">
                        return nil, err</span>
                case tasks = &lt;-tasksCh:<span class="cov8" title="1"></span>
                case sessions = &lt;-sessionsCh:<span class="cov8" title="1"></span>
                case goals = &lt;-goalsCh:<span class="cov8" title="1"></span>
                case projects = &lt;-projectsCh:<span class="cov8" title="1"></span>
                }
        }

        // Compute analytics
        <span class="cov8" title="1">analytics := &amp;DashboardAnalytics{
                Period: string(period),
                Days:   days,
        }

        // Build date offsets for the period
        dateOffsets := s.buildDateOffsets(startDate, days)

        // Filter completed tasks in range
        completedTasks := s.filterCompletedTasks(tasks, startDate, endDate)

        // Group data by date
        tasksByDate := s.groupTasksByDate(completedTasks)
        sessionsByDate := s.groupSessionsByDate(sessions)

        // Compute focus data (minutes per day)
        analytics.FocusData = s.computeFocusData(dateOffsets, sessionsByDate)

        // Compute task data (tasks per day by category)
        analytics.TaskData = s.computeTaskData(dateOffsets, tasksByDate)

        // Compute category data (mastery vs pleasure)
        analytics.CategoryData = s.computeCategoryData(dateOffsets, tasksByDate)

        // Compute time of day statistics
        analytics.TimeOfDayData = s.computeTimeOfDayData(sessions)

        // Compute overall stats
        analytics.Stats.TotalFocusTime = s.sumSessionTime(sessions) / 60 // convert to minutes
        analytics.Stats.TotalSessions = len(sessions)
        analytics.Stats.CompletedTasks = len(completedTasks)

        categoryTotals := s.countTasksByCategory(completedTasks)
        analytics.Stats.MasteryTasks = categoryTotals["mastery"]
        analytics.Stats.PleasureTasks = categoryTotals["pleasure"]

        analytics.Stats.CurrentStreak = s.calculateStreak(ctx, uid, time.Now())

        // Completion rate (all tasks vs completed)
        allTasksCount, _ := s.countAllTasks(ctx, uid)
        completedCount := s.countCompletedTasks(tasks)
        if allTasksCount &gt; 0 </span><span class="cov0" title="0">{
                analytics.Stats.CompletionRate = float64(completedCount) / float64(allTasksCount) * 100
        }</span>

        // Compute comparison with previous period
        <span class="cov8" title="1">analytics.Comparison = s.calculateComparison(ctx, uid, period, startDate, endDate, sessions, completedTasks)

        // Compute goal stats
        analytics.Goals = s.calculateGoalStats(goals)

        // Compute project stats
        analytics.Projects = s.calculateProjectStats(projects)

        s.logger.Info("Dashboard analytics computed",
                zap.String("uid", uid),
                zap.String("period", string(period)),
                zap.Int("sessions", analytics.Stats.TotalSessions),
                zap.Int("tasks", analytics.Stats.CompletedTasks),
        )

        return analytics, nil</span>
}

// resolvePeriodRange determines the date range for a period
func (s *DashboardAnalyticsService) resolvePeriodRange(period SummaryPeriod, ref time.Time) (startDate, endDate time.Time, days int) <span class="cov8" title="1">{
        switch period </span>{
        case PeriodToday:<span class="cov8" title="1">
                startDate = s.startOfDay(ref)
                endDate = s.endOfDay(ref)
                days = 1</span>
        case PeriodWeek:<span class="cov8" title="1">
                startDate = s.startOfWeek(ref)
                endDate = s.endOfWeek(ref)
                days = 7</span>
        case PeriodMonth:<span class="cov8" title="1">
                startDate = s.startOfMonth(ref)
                endDate = s.endOfMonth(ref)
                days = int(math.Round(endDate.Sub(startDate).Hours()/24)) + 1</span>
        default:<span class="cov0" title="0">
                startDate = s.startOfDay(ref)
                endDate = s.endOfDay(ref)
                days = 1</span>
        }
        <span class="cov8" title="1">return</span>
}

// fetchTasks fetches tasks for a user
func (s *DashboardAnalyticsService) fetchTasks(ctx context.Context, uid string, startDate, endDate time.Time) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        collectionPath := fmt.Sprintf("users/%s/tasks", uid)

        // Use the repository's List method instead of direct Firestore client access
        tasks, err := s.repo.List(ctx, collectionPath, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return tasks, nil</span>
}

// fetchSessions fetches focus sessions for a user in date range
func (s *DashboardAnalyticsService) fetchSessions(ctx context.Context, uid string, startDate, endDate time.Time) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        collectionPath := fmt.Sprintf("users/%s/focusSessions", uid)

        // Use the repository's List method instead of direct Firestore client access
        allSessions, err := s.repo.List(ctx, collectionPath, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter by date range client-side
        <span class="cov8" title="1">var sessions []map[string]interface{}
        for _, session := range allSessions </span><span class="cov0" title="0">{
                // Check if session has startTime field
                if startTimeVal, ok := session["startTime"]; ok </span><span class="cov0" title="0">{
                        // Convert to time.Time for comparison
                        var sessionTime time.Time
                        switch v := startTimeVal.(type) </span>{
                        case time.Time:<span class="cov0" title="0">
                                sessionTime = v</span>
                        default:<span class="cov0" title="0">
                                // Skip if can't convert to time
                                continue</span>
                        }

                        // Include if within date range
                        <span class="cov0" title="0">if !sessionTime.Before(startDate) &amp;&amp; !sessionTime.After(endDate) </span><span class="cov0" title="0">{
                                sessions = append(sessions, session)
                        }</span>
                }
        }

        <span class="cov8" title="1">return sessions, nil</span>
}

// fetchGoals fetches all goals for a user
func (s *DashboardAnalyticsService) fetchGoals(ctx context.Context, uid string) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        collectionPath := fmt.Sprintf("users/%s/goals", uid)

        // Use the repository's List method instead of direct Firestore client access
        goals, err := s.repo.List(ctx, collectionPath, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return goals, nil</span>
}

// fetchProjects fetches all projects for a user
func (s *DashboardAnalyticsService) fetchProjects(ctx context.Context, uid string) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        collectionPath := fmt.Sprintf("users/%s/projects", uid)

        // Use the repository's List method instead of direct Firestore client access
        projects, err := s.repo.List(ctx, collectionPath, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return projects, nil</span>
}

// buildDateOffsets creates an array of dates for the period
func (s *DashboardAnalyticsService) buildDateOffsets(startDate time.Time, days int) []time.Time <span class="cov8" title="1">{
        offsets := make([]time.Time, days)
        for i := 0; i &lt; days; i++ </span><span class="cov8" title="1">{
                offsets[i] = startDate.AddDate(0, 0, i)
        }</span>
        <span class="cov8" title="1">return offsets</span>
}

// filterCompletedTasks filters tasks completed in the date range
func (s *DashboardAnalyticsService) filterCompletedTasks(tasks []map[string]interface{}, startDate, endDate time.Time) []map[string]interface{} <span class="cov8" title="1">{
        var completed []map[string]interface{}
        for _, task := range tasks </span><span class="cov0" title="0">{
                if completedAt, ok := task["completedAt"].(time.Time); ok </span><span class="cov0" title="0">{
                        if !completedAt.Before(startDate) &amp;&amp; !completedAt.After(endDate) </span><span class="cov0" title="0">{
                                completed = append(completed, task)
                        }</span>
                }
        }
        <span class="cov8" title="1">return completed</span>
}

// groupTasksByDate groups tasks by date string
func (s *DashboardAnalyticsService) groupTasksByDate(tasks []map[string]interface{}) map[string][]map[string]interface{} <span class="cov8" title="1">{
        grouped := make(map[string][]map[string]interface{})
        for _, task := range tasks </span><span class="cov0" title="0">{
                if completedAt, ok := task["completedAt"].(time.Time); ok </span><span class="cov0" title="0">{
                        dateStr := s.startOfDay(completedAt).Format("Mon Jan 02 2006")
                        grouped[dateStr] = append(grouped[dateStr], task)
                }</span>
        }
        <span class="cov8" title="1">return grouped</span>
}

// groupSessionsByDate groups sessions by date string
func (s *DashboardAnalyticsService) groupSessionsByDate(sessions []map[string]interface{}) map[string][]map[string]interface{} <span class="cov8" title="1">{
        grouped := make(map[string][]map[string]interface{})
        for _, session := range sessions </span><span class="cov0" title="0">{
                if startTime, ok := session["startTime"].(time.Time); ok </span><span class="cov0" title="0">{
                        dateStr := s.startOfDay(startTime).Format("Mon Jan 02 2006")
                        grouped[dateStr] = append(grouped[dateStr], session)
                }</span>
        }
        <span class="cov8" title="1">return grouped</span>
}

// computeFocusData computes focus minutes per day
func (s *DashboardAnalyticsService) computeFocusData(dateOffsets []time.Time, sessionsByDate map[string][]map[string]interface{}) []map[string]interface{} <span class="cov8" title="1">{
        focusData := make([]map[string]interface{}, len(dateOffsets))
        for i, date := range dateOffsets </span><span class="cov8" title="1">{
                dateStr := date.Format("Mon Jan 02 2006")
                sessions := sessionsByDate[dateStr]

                totalMinutes := s.sumSessionTime(sessions) / 60 // convert to minutes

                focusData[i] = map[string]interface{}{
                        "date":    date.Format(time.RFC3339),
                        "minutes": totalMinutes,
                }
        }</span>
        <span class="cov8" title="1">return focusData</span>
}

// computeTaskData computes task counts per day
func (s *DashboardAnalyticsService) computeTaskData(dateOffsets []time.Time, tasksByDate map[string][]map[string]interface{}) []map[string]interface{} <span class="cov8" title="1">{
        taskData := make([]map[string]interface{}, len(dateOffsets))
        for i, date := range dateOffsets </span><span class="cov8" title="1">{
                dateStr := date.Format("Mon Jan 02 2006")
                tasks := tasksByDate[dateStr]

                categories := s.countTasksByCategory(tasks)

                taskData[i] = map[string]interface{}{
                        "date":     date.Format(time.RFC3339),
                        "total":    len(tasks),
                        "mastery":  categories["mastery"],
                        "pleasure": categories["pleasure"],
                }
        }</span>
        <span class="cov8" title="1">return taskData</span>
}

// computeCategoryData computes category distribution per day
func (s *DashboardAnalyticsService) computeCategoryData(dateOffsets []time.Time, tasksByDate map[string][]map[string]interface{}) []map[string]interface{} <span class="cov8" title="1">{
        categoryData := make([]map[string]interface{}, len(dateOffsets))
        for i, date := range dateOffsets </span><span class="cov8" title="1">{
                dateStr := date.Format("Mon Jan 02 2006")
                tasks := tasksByDate[dateStr]

                categories := s.countTasksByCategory(tasks)

                categoryData[i] = map[string]interface{}{
                        "date":     date.Format(time.RFC3339),
                        "mastery":  categories["mastery"],
                        "pleasure": categories["pleasure"],
                }
        }</span>
        <span class="cov8" title="1">return categoryData</span>
}

// sumSessionTime sums the time spent in sessions
func (s *DashboardAnalyticsService) sumSessionTime(sessions []map[string]interface{}) int <span class="cov8" title="1">{
        total := 0
        for _, session := range sessions </span><span class="cov0" title="0">{
                if tasks, ok := session["tasks"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, task := range tasks </span><span class="cov0" title="0">{
                                if taskMap, ok := task.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if timeSpent, ok := taskMap["timeSpent"].(int64); ok </span><span class="cov0" title="0">{
                                                total += int(timeSpent)
                                        }</span> else<span class="cov0" title="0"> if timeSpent, ok := taskMap["timeSpent"].(float64); ok </span><span class="cov0" title="0">{
                                                total += int(timeSpent)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return total</span>
}

// countTasksByCategory counts tasks by mastery/pleasure category
func (s *DashboardAnalyticsService) countTasksByCategory(tasks []map[string]interface{}) map[string]int <span class="cov8" title="1">{
        counts := map[string]int{"mastery": 0, "pleasure": 0}
        for _, task := range tasks </span><span class="cov0" title="0">{
                category := "mastery" // default
                if cat, ok := task["category"].(string); ok </span><span class="cov0" title="0">{
                        category = cat
                }</span>
                <span class="cov0" title="0">if category == "mastery" || category == "pleasure" </span><span class="cov0" title="0">{
                        counts[category]++
                }</span>
        }
        <span class="cov8" title="1">return counts</span>
}

// computeTimeOfDayData computes statistics by time of day
func (s *DashboardAnalyticsService) computeTimeOfDayData(sessions []map[string]interface{}) map[string]TimeOfDayStats <span class="cov8" title="1">{
        timeOfDay := map[string]TimeOfDayStats{
                "morning":   {Sessions: 0, TotalTime: 0, CompletedTasks: 0, AvgCompletion: 0},
                "afternoon": {Sessions: 0, TotalTime: 0, CompletedTasks: 0, AvgCompletion: 0},
                "evening":   {Sessions: 0, TotalTime: 0, CompletedTasks: 0, AvgCompletion: 0},
                "night":     {Sessions: 0, TotalTime: 0, CompletedTasks: 0, AvgCompletion: 0},
        }

        totalTasksByPeriod := map[string]int{
                "morning": 0, "afternoon": 0, "evening": 0, "night": 0,
        }

        for _, session := range sessions </span><span class="cov0" title="0">{
                startTime, ok := session["startTime"].(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">period := s.getTimeOfDayCategory(startTime)
                stats := timeOfDay[period]

                // Count session
                stats.Sessions++

                // Sum time
                if tasks, ok := session["tasks"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, task := range tasks </span><span class="cov0" title="0">{
                                if taskMap, ok := task.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if timeSpent, ok := taskMap["timeSpent"].(int64); ok </span><span class="cov0" title="0">{
                                                stats.TotalTime += int(timeSpent)
                                        }</span> else<span class="cov0" title="0"> if timeSpent, ok := taskMap["timeSpent"].(float64); ok </span><span class="cov0" title="0">{
                                                stats.TotalTime += int(timeSpent)
                                        }</span>

                                        // Count completed tasks
                                        <span class="cov0" title="0">if completed, ok := taskMap["completed"].(bool); ok &amp;&amp; completed </span><span class="cov0" title="0">{
                                                stats.CompletedTasks++
                                        }</span>

                                        <span class="cov0" title="0">totalTasksByPeriod[period]++</span>
                                }
                        }
                }

                <span class="cov0" title="0">timeOfDay[period] = stats</span>
        }

        // Calculate average completion percentage
        <span class="cov8" title="1">for period, stats := range timeOfDay </span><span class="cov8" title="1">{
                totalTasks := totalTasksByPeriod[period]
                if totalTasks &gt; 0 </span><span class="cov0" title="0">{
                        stats.AvgCompletion = float64(stats.CompletedTasks) / float64(totalTasks) * 100
                        timeOfDay[period] = stats
                }</span>
        }

        <span class="cov8" title="1">return timeOfDay</span>
}

// getTimeOfDayCategory categorizes time into morning/afternoon/evening/night
func (s *DashboardAnalyticsService) getTimeOfDayCategory(t time.Time) string <span class="cov0" title="0">{
        hour := t.Hour()
        if hour &gt;= 5 &amp;&amp; hour &lt; 12 </span><span class="cov0" title="0">{
                return "morning"
        }</span> else<span class="cov0" title="0"> if hour &gt;= 12 &amp;&amp; hour &lt; 17 </span><span class="cov0" title="0">{
                return "afternoon"
        }</span> else<span class="cov0" title="0"> if hour &gt;= 17 &amp;&amp; hour &lt; 21 </span><span class="cov0" title="0">{
                return "evening"
        }</span>
        <span class="cov0" title="0">return "night"</span>
}

// calculateStreak calculates consecutive days with focus sessions
func (s *DashboardAnalyticsService) calculateStreak(ctx context.Context, uid string, referenceDate time.Time) int <span class="cov8" title="1">{
        // Fetch ALL sessions to calculate streak (we need historical data)
        collectionPath := fmt.Sprintf("users/%s/focusSessions", uid)
        sessions, err := s.repo.List(ctx, collectionPath, 0)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Error fetching sessions for streak", zap.Error(err))
                return 0
        }</span>

        <span class="cov8" title="1">sessionsByDate := make(map[string]bool)
        for _, session := range sessions </span><span class="cov8" title="1">{
                if startTimeVal, ok := session["startTime"]; ok </span><span class="cov8" title="1">{
                        if startTime, ok := startTimeVal.(time.Time); ok </span><span class="cov8" title="1">{
                                dateStr := s.startOfDay(startTime).Format("2006-01-02")
                                sessionsByDate[dateStr] = true
                        }</span>
                }
        }

        // Count backwards from reference date
        <span class="cov8" title="1">streak := 0
        currentDate := s.startOfDay(referenceDate)
        for </span><span class="cov8" title="1">{
                dateStr := currentDate.Format("2006-01-02")
                if sessionsByDate[dateStr] </span><span class="cov8" title="1">{
                        streak++
                        currentDate = currentDate.AddDate(0, 0, -1)
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">return streak</span>
}

// countAllTasks counts all tasks (for completion rate)
func (s *DashboardAnalyticsService) countAllTasks(ctx context.Context, uid string) (int, error) <span class="cov8" title="1">{
        collectionPath := fmt.Sprintf("users/%s/tasks", uid)
        tasks, err := s.repo.List(ctx, collectionPath, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return len(tasks), nil</span>
}

// countCompletedTasks counts completed tasks
func (s *DashboardAnalyticsService) countCompletedTasks(tasks []map[string]interface{}) int <span class="cov8" title="1">{
        count := 0
        for _, task := range tasks </span><span class="cov0" title="0">{
                if done, ok := task["done"].(bool); ok &amp;&amp; done </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// calculateComparison computes comparison with previous period
func (s *DashboardAnalyticsService) calculateComparison(ctx context.Context, uid string, period SummaryPeriod, startDate, endDate time.Time, currentSessions []map[string]interface{}, currentTasks []map[string]interface{}) *struct {
        FocusTime float64 `json:"focusTime"`
        Tasks     float64 `json:"tasks"`
} <span class="cov8" title="1">{
        var prevStart, prevEnd time.Time

        switch period </span>{
        case PeriodToday:<span class="cov8" title="1">
                prevStart = startDate.AddDate(0, 0, -1)
                prevEnd = endDate.AddDate(0, 0, -1)</span>
        case PeriodWeek:<span class="cov8" title="1">
                prevStart = startDate.AddDate(0, 0, -7)
                prevEnd = endDate.AddDate(0, 0, -7)</span>
        case PeriodMonth:<span class="cov8" title="1">
                prevStart = s.startOfMonth(startDate.AddDate(0, -1, 0))
                prevEnd = s.endOfMonth(prevStart)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }

        // Fetch previous period data
        <span class="cov8" title="1">prevSessions, err := s.fetchSessions(ctx, uid, prevStart, prevEnd)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Error fetching previous sessions", zap.Error(err))
                return nil
        }</span>

        <span class="cov8" title="1">prevTasks, err := s.fetchTasks(ctx, uid, prevStart, prevEnd)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Error fetching previous tasks", zap.Error(err))
                return nil
        }</span>

        <span class="cov8" title="1">prevCompletedTasks := s.filterCompletedTasks(prevTasks, prevStart, prevEnd)

        // Calculate focus time
        currFocusTime := float64(s.sumSessionTime(currentSessions) / 60)
        prevFocusTime := float64(s.sumSessionTime(prevSessions) / 60)

        focusTimeChange := 0.0
        if prevFocusTime &gt; 0 </span><span class="cov0" title="0">{
                focusTimeChange = ((currFocusTime - prevFocusTime) / prevFocusTime) * 100
        }</span>

        // Calculate task count
        <span class="cov8" title="1">currTaskCount := float64(len(currentTasks))
        prevTaskCount := float64(len(prevCompletedTasks))

        taskChange := 0.0
        if prevTaskCount &gt; 0 </span><span class="cov0" title="0">{
                taskChange = ((currTaskCount - prevTaskCount) / prevTaskCount) * 100
        }</span>

        <span class="cov8" title="1">return &amp;struct {
                FocusTime float64 `json:"focusTime"`
                Tasks     float64 `json:"tasks"`
        }{
                FocusTime: focusTimeChange,
                Tasks:     taskChange,
        }</span>
}

// calculateGoalStats computes goal statistics
func (s *DashboardAnalyticsService) calculateGoalStats(goals []map[string]interface{}) struct {
        Total     int                    `json:"total"`
        Active    int                    `json:"active"`
        Completed int                    `json:"completed"`
        Progress  float64                `json:"progress"`
        TopGoal   map[string]interface{} `json:"topGoal"`
} <span class="cov8" title="1">{
        total := len(goals)
        active := 0
        completed := 0
        var topGoal map[string]interface{}

        for _, goal := range goals </span><span class="cov0" title="0">{
                if status, ok := goal["status"].(string); ok </span><span class="cov0" title="0">{
                        if status == "active" </span><span class="cov0" title="0">{
                                active++
                                if topGoal == nil </span><span class="cov0" title="0">{
                                        topGoal = goal
                                }</span>
                        } else<span class="cov0" title="0"> if status == "completed" </span><span class="cov0" title="0">{
                                completed++
                        }</span>
                }
        }

        <span class="cov8" title="1">progress := 0.0
        if total &gt; 0 </span><span class="cov0" title="0">{
                progress = float64(completed) / float64(total) * 100
        }</span>

        <span class="cov8" title="1">return struct {
                Total     int                    `json:"total"`
                Active    int                    `json:"active"`
                Completed int                    `json:"completed"`
                Progress  float64                `json:"progress"`
                TopGoal   map[string]interface{} `json:"topGoal"`
        }{
                Total:     total,
                Active:    active,
                Completed: completed,
                Progress:  progress,
                TopGoal:   topGoal,
        }</span>
}

// calculateProjectStats computes project statistics
func (s *DashboardAnalyticsService) calculateProjectStats(projects []map[string]interface{}) struct {
        Total     int     `json:"total"`
        Active    int     `json:"active"`
        Completed int     `json:"completed"`
        Progress  float64 `json:"progress"`
} <span class="cov8" title="1">{
        total := len(projects)
        active := 0
        completed := 0

        for _, project := range projects </span><span class="cov0" title="0">{
                if status, ok := project["status"].(string); ok </span><span class="cov0" title="0">{
                        if status == "active" || status == "on-hold" </span><span class="cov0" title="0">{
                                active++
                        }</span> else<span class="cov0" title="0"> if status == "completed" </span><span class="cov0" title="0">{
                                completed++
                        }</span>
                }
        }

        <span class="cov8" title="1">progress := 0.0
        if total &gt; 0 </span><span class="cov0" title="0">{
                progress = float64(completed) / float64(total) * 100
        }</span>

        <span class="cov8" title="1">return struct {
                Total     int     `json:"total"`
                Active    int     `json:"active"`
                Completed int     `json:"completed"`
                Progress  float64 `json:"progress"`
        }{
                Total:     total,
                Active:    active,
                Completed: completed,
                Progress:  progress,
        }</span>
}

// Date utility functions

func (s *DashboardAnalyticsService) startOfDay(t time.Time) time.Time <span class="cov8" title="1">{
        year, month, day := t.Date()
        return time.Date(year, month, day, 0, 0, 0, 0, t.Location())
}</span>

func (s *DashboardAnalyticsService) endOfDay(t time.Time) time.Time <span class="cov8" title="1">{
        year, month, day := t.Date()
        return time.Date(year, month, day, 23, 59, 59, 999999999, t.Location())
}</span>

func (s *DashboardAnalyticsService) startOfWeek(t time.Time) time.Time <span class="cov8" title="1">{
        // Go weeks start on Sunday (0), we want Monday (1)
        weekday := int(t.Weekday())
        if weekday == 0 </span><span class="cov0" title="0">{
                weekday = 7 // Sunday becomes 7
        }</span>
        <span class="cov8" title="1">daysToSubtract := weekday - 1
        return s.startOfDay(t.AddDate(0, 0, -daysToSubtract))</span>
}

func (s *DashboardAnalyticsService) endOfWeek(t time.Time) time.Time <span class="cov8" title="1">{
        return s.endOfDay(s.startOfWeek(t).AddDate(0, 0, 6))
}</span>

func (s *DashboardAnalyticsService) startOfMonth(t time.Time) time.Time <span class="cov8" title="1">{
        year, month, _ := t.Date()
        return time.Date(year, month, 1, 0, 0, 0, 0, t.Location())
}</span>

func (s *DashboardAnalyticsService) endOfMonth(t time.Time) time.Time <span class="cov8" title="1">{
        return s.endOfDay(s.startOfMonth(t).AddDate(0, 1, -1))
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// EntityGraphService handles entity graph operations
type EntityGraphService struct {
        repo   interfaces.Repository
        logger *zap.Logger
}

// NewEntityGraphService creates a new entity graph service
func NewEntityGraphService(repo interfaces.Repository, logger *zap.Logger) *EntityGraphService <span class="cov8" title="1">{
        return &amp;EntityGraphService{
                repo:   repo,
                logger: logger,
        }
}</span>

// EntityType represents the type of entity in the graph
type EntityType string

const (
        EntityTypeThought EntityType = "thought"
        EntityTypeTask    EntityType = "task"
        EntityTypeProject EntityType = "project"
        EntityTypeGoal    EntityType = "goal"
        EntityTypeMood    EntityType = "mood"
        EntityTypeTool    EntityType = "tool"
        EntityTypePerson  EntityType = "person"

        // Plural aliases for collection names (used by import/export)
        EntityTypeTasks         EntityType = "tasks"
        EntityTypeProjects      EntityType = "projects"
        EntityTypeGoals         EntityType = "goals"
        EntityTypeThoughts      EntityType = "thoughts"
        EntityTypeMoods         EntityType = "moods"
        EntityTypeFocusSessions EntityType = "focusSessions"
        EntityTypePeople        EntityType = "people"
        EntityTypePortfolios    EntityType = "portfolios"
        EntityTypeSpending      EntityType = "spending"
        EntityTypeRelationships EntityType = "relationships"
        EntityTypeLLMLogs       EntityType = "llmLogs"
)

// RelationshipType represents the type of relationship
type RelationshipType string

const (
        RelationshipTypeCreatedFrom    RelationshipType = "created-from"
        RelationshipTypeLinkedTo       RelationshipType = "linked-to"
        RelationshipTypeRelatedTo      RelationshipType = "related-to"
        RelationshipTypeDependsOn      RelationshipType = "depends-on"
        RelationshipTypeToolProcessing RelationshipType = "tool-processing"
        RelationshipTypeToolPending    RelationshipType = "tool-pending"
        RelationshipTypeToolProcessed  RelationshipType = "tool-processed"
)

// RelationshipFilters represents filters for querying relationships
type RelationshipFilters struct {
        SourceType       *EntityType       `json:"sourceType,omitempty"`
        SourceID         *string           `json:"sourceId,omitempty"`
        TargetType       *EntityType       `json:"targetType,omitempty"`
        TargetID         *string           `json:"targetId,omitempty"`
        RelationshipType *RelationshipType `json:"relationshipType,omitempty"`
        Status           *string           `json:"status,omitempty"`    // active, archived, rejected
        CreatedBy        *string           `json:"createdBy,omitempty"` // ai, user
        MinStrength      *int              `json:"minStrength,omitempty"`
        MaxStrength      *int              `json:"maxStrength,omitempty"`
        Limit            int               `json:"limit,omitempty"`
        Offset           int               `json:"offset,omitempty"`
        SortBy           string            `json:"sortBy,omitempty"`    // createdAt, strength
        SortOrder        string            `json:"sortOrder,omitempty"` // asc, desc
}

// LinkedEntitiesResponse represents linked entities for a given entity
type LinkedEntitiesResponse struct {
        Tasks    []map[string]interface{} `json:"tasks"`
        Projects []map[string]interface{} `json:"projects"`
        Goals    []map[string]interface{} `json:"goals"`
        Thoughts []map[string]interface{} `json:"thoughts"`
        People   []map[string]interface{} `json:"people"`
        Count    struct {
                Tasks    int `json:"tasks"`
                Projects int `json:"projects"`
                Goals    int `json:"goals"`
                Thoughts int `json:"thoughts"`
                People   int `json:"people"`
                Total    int `json:"total"`
        } `json:"count"`
}

// ToolRelationshipsResponse represents tool-related relationships
type ToolRelationshipsResponse struct {
        Pending   []map[string]interface{} `json:"pending"`
        Processed []map[string]interface{} `json:"processed"`
        Count     struct {
                Pending   int `json:"pending"`
                Processed int `json:"processed"`
                Total     int `json:"total"`
        } `json:"count"`
}

// RelationshipStats represents statistics about relationships
type RelationshipStats struct {
        TotalRelationships int                      `json:"totalRelationships"`
        ByType             map[string]int           `json:"byType"`
        BySourceType       map[string]int           `json:"bySourceType"`
        ByTargetType       map[string]int           `json:"byTargetType"`
        ByStatus           map[string]int           `json:"byStatus"`
        ByCreator          map[string]int           `json:"byCreator"`
        AverageStrength    float64                  `json:"averageStrength"`
        ToolUsage          map[string]ToolUsageStat `json:"toolUsage"`
}

// ToolUsageStat represents usage statistics for a specific tool
type ToolUsageStat struct {
        ProcessedCount int       `json:"processedCount"`
        PendingCount   int       `json:"pendingCount"`
        LastProcessed  time.Time `json:"lastProcessed"`
}

// QueryRelationships queries relationships with filters
func (s *EntityGraphService) QueryRelationships(
        ctx context.Context,
        uid string,
        filters RelationshipFilters,
) ([]map[string]interface{}, int, error) <span class="cov8" title="1">{
        // Fetch all relationships for the user
        allRelationships, err := s.repo.List(ctx, "entityRelationships", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Apply all filters client-side
        <span class="cov8" title="1">allResults := []map[string]interface{}{}
        for _, relationship := range allRelationships </span><span class="cov8" title="1">{
                // Filter by uid
                if relUID, ok := relationship["uid"].(string); !ok || relUID != uid </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Apply filters
                <span class="cov8" title="1">if filters.SourceType != nil </span><span class="cov8" title="1">{
                        if sourceType, ok := relationship["sourceType"].(string); !ok || sourceType != string(*filters.SourceType) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if filters.SourceID != nil </span><span class="cov0" title="0">{
                        if sourceID, ok := relationship["sourceId"].(string); !ok || sourceID != *filters.SourceID </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if filters.TargetType != nil </span><span class="cov0" title="0">{
                        if targetType, ok := relationship["targetType"].(string); !ok || targetType != string(*filters.TargetType) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if filters.TargetID != nil </span><span class="cov0" title="0">{
                        if targetID, ok := relationship["targetId"].(string); !ok || targetID != *filters.TargetID </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if filters.RelationshipType != nil </span><span class="cov0" title="0">{
                        if relType, ok := relationship["relationshipType"].(string); !ok || relType != string(*filters.RelationshipType) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if filters.Status != nil </span><span class="cov8" title="1">{
                        if status, ok := relationship["status"].(string); !ok || status != *filters.Status </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if filters.CreatedBy != nil </span><span class="cov8" title="1">{
                        if createdBy, ok := relationship["createdBy"].(string); !ok || createdBy != *filters.CreatedBy </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }

                // Apply strength filters (client-side)
                <span class="cov8" title="1">if filters.MinStrength != nil || filters.MaxStrength != nil </span><span class="cov8" title="1">{
                        strength := int(s.getFloatFromMap(relationship, "strength", 0))
                        if filters.MinStrength != nil &amp;&amp; strength &lt; *filters.MinStrength </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if filters.MaxStrength != nil &amp;&amp; strength &gt; *filters.MaxStrength </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">allResults = append(allResults, relationship)</span>
        }

        <span class="cov8" title="1">totalCount := len(allResults)

        // Apply pagination
        limit := filters.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100 // Default limit
        }</span>
        <span class="cov8" title="1">offset := filters.Offset
        if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // Calculate slice bounds
        <span class="cov8" title="1">start := offset
        if start &gt; len(allResults) </span><span class="cov0" title="0">{
                start = len(allResults)
        }</span>
        <span class="cov8" title="1">end := start + limit
        if end &gt; len(allResults) </span><span class="cov8" title="1">{
                end = len(allResults)
        }</span>

        <span class="cov8" title="1">paginatedResults := allResults[start:end]

        return paginatedResults, totalCount, nil</span>
}

// GetLinkedEntities gets all entities linked to a specific entity
func (s *EntityGraphService) GetLinkedEntities(
        ctx context.Context,
        uid string,
        entityType EntityType,
        entityID string,
) (*LinkedEntitiesResponse, error) <span class="cov8" title="1">{
        response := &amp;LinkedEntitiesResponse{
                Tasks:    []map[string]interface{}{},
                Projects: []map[string]interface{}{},
                Goals:    []map[string]interface{}{},
                Thoughts: []map[string]interface{}{},
                People:   []map[string]interface{}{},
        }

        // Fetch all relationships for the user
        allRelationships, err := s.repo.List(ctx, "entityRelationships", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Collect all linked entity IDs by type
        <span class="cov8" title="1">linkedIDs := map[EntityType]map[string]bool{
                EntityTypeTask:    {},
                EntityTypeProject: {},
                EntityTypeGoal:    {},
                EntityTypeThought: {},
                EntityTypePerson:  {},
        }

        // Process relationships (both as source and target)
        for _, rel := range allRelationships </span><span class="cov8" title="1">{
                // Filter by uid and status
                if relUID, ok := rel["uid"].(string); !ok || relUID != uid </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if status, ok := rel["status"].(string); !ok || status != "active" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if this entity is the source
                <span class="cov8" title="1">if sourceType, ok := rel["sourceType"].(string); ok &amp;&amp; sourceType == string(entityType) </span><span class="cov8" title="1">{
                        if sourceID, ok := rel["sourceId"].(string); ok &amp;&amp; sourceID == entityID </span><span class="cov8" title="1">{
                                // Add target entity to linkedIDs
                                if targetType, ok := rel["targetType"].(string); ok </span><span class="cov8" title="1">{
                                        if targetID, ok := rel["targetId"].(string); ok </span><span class="cov8" title="1">{
                                                linkedIDs[EntityType(targetType)][targetID] = true
                                        }</span>
                                }
                        }
                }

                // Check if this entity is the target
                <span class="cov8" title="1">if targetType, ok := rel["targetType"].(string); ok &amp;&amp; targetType == string(entityType) </span><span class="cov0" title="0">{
                        if targetID, ok := rel["targetId"].(string); ok &amp;&amp; targetID == entityID </span><span class="cov0" title="0">{
                                // Add source entity to linkedIDs
                                if sourceType, ok := rel["sourceType"].(string); ok </span><span class="cov0" title="0">{
                                        if sourceID, ok := rel["sourceId"].(string); ok </span><span class="cov0" title="0">{
                                                linkedIDs[EntityType(sourceType)][sourceID] = true
                                        }</span>
                                }
                        }
                }
        }

        // Fetch actual entity data for linked IDs
        <span class="cov8" title="1">response.Tasks = s.fetchEntitiesByIDs(ctx, uid, "tasks", linkedIDs[EntityTypeTask])
        response.Projects = s.fetchEntitiesByIDs(ctx, uid, "projects", linkedIDs[EntityTypeProject])
        response.Goals = s.fetchEntitiesByIDs(ctx, uid, "goals", linkedIDs[EntityTypeGoal])
        response.Thoughts = s.fetchEntitiesByIDs(ctx, uid, "thoughts", linkedIDs[EntityTypeThought])
        response.People = s.fetchEntitiesByIDs(ctx, uid, "people", linkedIDs[EntityTypePerson])

        // Calculate counts
        response.Count.Tasks = len(response.Tasks)
        response.Count.Projects = len(response.Projects)
        response.Count.Goals = len(response.Goals)
        response.Count.Thoughts = len(response.Thoughts)
        response.Count.People = len(response.People)
        response.Count.Total = response.Count.Tasks + response.Count.Projects +
                response.Count.Goals + response.Count.Thoughts + response.Count.People

        return response, nil</span>
}

// fetchEntitiesByIDs fetches entity data for a set of IDs
func (s *EntityGraphService) fetchEntitiesByIDs(
        ctx context.Context,
        uid string,
        collection string,
        ids map[string]bool,
) []map[string]interface{} <span class="cov8" title="1">{
        if len(ids) == 0 </span><span class="cov8" title="1">{
                return []map[string]interface{}{}
        }</span>

        // Fetch all entities for the user from the collection
        <span class="cov8" title="1">userCollectionPath := fmt.Sprintf("users/%s/%s", uid, collection)
        allEntities, err := s.repo.List(ctx, userCollectionPath, 0)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Error fetching entities", zap.Error(err))
                return []map[string]interface{}{}
        }</span>

        // Filter to only include entities with IDs in our set
        <span class="cov8" title="1">results := []map[string]interface{}{}
        for _, entity := range allEntities </span><span class="cov8" title="1">{
                if id, ok := entity["id"].(string); ok &amp;&amp; ids[id] </span><span class="cov8" title="1">{
                        results = append(results, entity)
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}

// GetToolRelationships gets tool-related relationships
func (s *EntityGraphService) GetToolRelationships(
        ctx context.Context,
        uid string,
        toolType *string,
) (*ToolRelationshipsResponse, error) <span class="cov8" title="1">{
        response := &amp;ToolRelationshipsResponse{
                Pending:   []map[string]interface{}{},
                Processed: []map[string]interface{}{},
        }

        // Fetch all relationships for the user
        allRelationships, err := s.repo.List(ctx, "entityRelationships", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter for tool relationships client-side
        <span class="cov8" title="1">for _, rel := range allRelationships </span><span class="cov8" title="1">{
                // Filter by uid and status
                if relUID, ok := rel["uid"].(string); !ok || relUID != uid </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if status, ok := rel["status"].(string); !ok || status != "active" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Filter by relationship type
                <span class="cov8" title="1">relType, ok := rel["relationshipType"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Filter by tool type if provided
                <span class="cov8" title="1">if toolType != nil </span><span class="cov0" title="0">{
                        sourceType, ok := rel["sourceType"].(string)
                        if !ok || sourceType != "tool" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check metadata.createdByTool
                        <span class="cov0" title="0">metadata, ok := rel["metadata"].(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">createdByTool, ok := metadata["createdByTool"].(string)
                        if !ok || createdByTool != *toolType </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Add to appropriate list based on relationship type
                <span class="cov8" title="1">if relType == "tool-pending" </span><span class="cov8" title="1">{
                        response.Pending = append(response.Pending, rel)
                }</span> else<span class="cov8" title="1"> if relType == "tool-processed" </span><span class="cov8" title="1">{
                        response.Processed = append(response.Processed, rel)
                }</span>
        }

        // Calculate counts
        <span class="cov8" title="1">response.Count.Pending = len(response.Pending)
        response.Count.Processed = len(response.Processed)
        response.Count.Total = response.Count.Pending + response.Count.Processed

        return response, nil</span>
}

// GetRelationshipStats calculates statistics about relationships
func (s *EntityGraphService) GetRelationshipStats(ctx context.Context, uid string) (*RelationshipStats, error) <span class="cov8" title="1">{
        stats := &amp;RelationshipStats{
                ByType:       make(map[string]int),
                BySourceType: make(map[string]int),
                ByTargetType: make(map[string]int),
                ByStatus:     make(map[string]int),
                ByCreator:    make(map[string]int),
                ToolUsage:    make(map[string]ToolUsageStat),
        }

        // Fetch all relationships for the user
        allRelationships, err := s.repo.List(ctx, "entityRelationships", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">totalStrength := 0.0
        strengthCount := 0

        for _, relationship := range allRelationships </span><span class="cov8" title="1">{
                // Filter by uid
                if relUID, ok := relationship["uid"].(string); !ok || relUID != uid </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">stats.TotalRelationships++

                // Count by type
                relType := s.getStringFromMap(relationship, "relationshipType", "unknown")
                stats.ByType[relType]++

                // Count by source type
                sourceType := s.getStringFromMap(relationship, "sourceType", "unknown")
                stats.BySourceType[sourceType]++

                // Count by target type
                targetType := s.getStringFromMap(relationship, "targetType", "unknown")
                stats.ByTargetType[targetType]++

                // Count by status
                status := s.getStringFromMap(relationship, "status", "unknown")
                stats.ByStatus[status]++

                // Count by creator
                createdBy := s.getStringFromMap(relationship, "createdBy", "unknown")
                stats.ByCreator[createdBy]++

                // Calculate average strength
                strength := s.getFloatFromMap(relationship, "strength", 0)
                totalStrength += strength
                strengthCount++

                // Track tool usage
                if relType == "tool-processed" || relType == "tool-pending" </span><span class="cov0" title="0">{
                        toolName := s.getStringFromMap(relationship, "metadata.createdByTool", "unknown")
                        toolStat := stats.ToolUsage[toolName]

                        if relType == "tool-processed" </span><span class="cov0" title="0">{
                                toolStat.ProcessedCount++
                                if processedAt := s.getStringFromMap(relationship, "toolProcessingData.processedAt", ""); processedAt != "" </span><span class="cov0" title="0">{
                                        if t, err := time.Parse(time.RFC3339, processedAt); err == nil </span><span class="cov0" title="0">{
                                                if toolStat.LastProcessed.IsZero() || t.After(toolStat.LastProcessed) </span><span class="cov0" title="0">{
                                                        toolStat.LastProcessed = t
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                toolStat.PendingCount++
                        }</span>

                        <span class="cov0" title="0">stats.ToolUsage[toolName] = toolStat</span>
                }
        }

        // Calculate average strength
        <span class="cov8" title="1">if strengthCount &gt; 0 </span><span class="cov8" title="1">{
                stats.AverageStrength = totalStrength / float64(strengthCount)
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// Helper methods
func (s *EntityGraphService) getStringFromMap(m map[string]interface{}, key string, defaultVal string) string <span class="cov8" title="1">{
        if val, ok := m[key]; ok </span><span class="cov8" title="1">{
                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return defaultVal</span>
}

func (s *EntityGraphService) getFloatFromMap(m map[string]interface{}, key string, defaultVal float64) float64 <span class="cov8" title="1">{
        if val, ok := m[key]; ok </span><span class="cov8" title="1">{
                switch v := val.(type) </span>{
                case float64:<span class="cov8" title="1">
                        return v</span>
                case int64:<span class="cov0" title="0">
                        return float64(v)</span>
                case int:<span class="cov0" title="0">
                        return float64(v)</span>
                }
        }
        <span class="cov0" title="0">return defaultVal</span>
}

// toInterfaceSlice converts []string to []interface{}
func toInterfaceSlice(slice []string) []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, len(slice))
        for i, v := range slice </span><span class="cov0" title="0">{
                result[i] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "cloud.google.com/go/firestore"
        "go.uber.org/zap"
        "google.golang.org/api/iterator"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// ImportExportService handles import/export operations
type ImportExportService struct {
        repo   interfaces.Repository
        logger *zap.Logger
}

// NewImportExportService creates a new import/export service
func NewImportExportService(repo interfaces.Repository, logger *zap.Logger) *ImportExportService <span class="cov8" title="1">{
        return &amp;ImportExportService{
                repo:   repo,
                logger: logger,
        }
}</span>

// ImportExportEntityType represents the type of entity being imported/exported
type ImportExportEntityType string

const (
        ImportExportEntityTypeTasks         ImportExportEntityType = "tasks"
        ImportExportEntityTypeProjects      ImportExportEntityType = "projects"
        ImportExportEntityTypeGoals         ImportExportEntityType = "goals"
        ImportExportEntityTypeThoughts      ImportExportEntityType = "thoughts"
        ImportExportEntityTypeMoods         ImportExportEntityType = "moods"
        ImportExportEntityTypeFocusSessions ImportExportEntityType = "focusSessions"
        ImportExportEntityTypePeople        ImportExportEntityType = "people"
        ImportExportEntityTypePortfolios    ImportExportEntityType = "portfolios"
        ImportExportEntityTypeSpending      ImportExportEntityType = "spending"
        ImportExportEntityTypeRelationships ImportExportEntityType = "relationships"
        ImportExportEntityTypeLLMLogs       ImportExportEntityType = "llmLogs"
)

// EntityCollection represents a collection of entities
type EntityCollection struct {
        Tasks         []map[string]interface{} `json:"tasks,omitempty"`
        Projects      []map[string]interface{} `json:"projects,omitempty"`
        Goals         []map[string]interface{} `json:"goals,omitempty"`
        Thoughts      []map[string]interface{} `json:"thoughts,omitempty"`
        Moods         []map[string]interface{} `json:"moods,omitempty"`
        FocusSessions []map[string]interface{} `json:"focusSessions,omitempty"`
        People        []map[string]interface{} `json:"people,omitempty"`
        Portfolios    []map[string]interface{} `json:"portfolios,omitempty"`
        Spending      []map[string]interface{} `json:"spending,omitempty"`
        Relationships []map[string]interface{} `json:"relationships,omitempty"`
        LLMLogs       []map[string]interface{} `json:"llmLogs,omitempty"`
}

// ExportMetadata contains metadata about exported data
type ExportMetadata struct {
        Version     string    `json:"version"`
        ExportedAt  time.Time `json:"exportedAt"`
        ExportedBy  string    `json:"exportedBy,omitempty"`
        TotalItems  int       `json:"totalItems"`
        AppVersion  string    `json:"appVersion,omitempty"`
        Description string    `json:"description,omitempty"`
}

// ImportData represents the structure of import data
type ImportData struct {
        Metadata ExportMetadata   `json:"metadata"`
        Entities EntityCollection `json:"entities"`
}

// ConflictType represents the type of conflict
type ConflictType string

const (
        ConflictTypeDuplicateID     ConflictType = "duplicate_id"
        ConflictTypeBrokenReference ConflictType = "broken_reference"
        ConflictTypeInvalidData     ConflictType = "invalid_data"
)

// Conflict represents a detected conflict
type Conflict struct {
        Type       ConflictType `json:"type"`
        EntityType EntityType   `json:"entityType"`
        EntityID   string       `json:"entityId"`
        Field      string       `json:"field,omitempty"`
        Message    string       `json:"message"`
}

// ValidationResult represents the result of import validation
type ValidationResult struct {
        Valid     bool       `json:"valid"`
        Conflicts []Conflict `json:"conflicts"`
        Summary   struct {
                TotalItems    int                 `json:"totalItems"`
                ItemsPerType  map[EntityType]int  `json:"itemsPerType"`
                ConflictCount int                 `json:"conflictCount"`
                NewItems      int                 `json:"newItems"`
                ExistingItems int                 `json:"existingItems"`
                Dependencies  map[string][]string `json:"dependencies"`
        } `json:"summary"`
        ParsedData ImportData `json:"parsedData"`
}

// ImportOptions represents options for import execution
type ImportOptions struct {
        UpdateReferences   bool                    `json:"updateReferences"`
        SkipConflicts      bool                    `json:"skipConflicts"`
        Selection          map[EntityType][]string `json:"selection"`          // Entity IDs to import per type
        ConflictResolution map[string]string       `json:"conflictResolution"` // Entity ID -&gt; resolution action
}

// ImportResult represents the result of import execution
type ImportResult struct {
        Success       bool               `json:"success"`
        ImportedCount int                `json:"importedCount"`
        SkippedCount  int                `json:"skippedCount"`
        ErrorCount    int                `json:"errorCount"`
        ByType        map[EntityType]int `json:"byType"`
        Errors        []string           `json:"errors,omitempty"`
}

// ExportFilters represents filters for data export
type ExportFilters struct {
        EntityTypes []EntityType `json:"entityTypes,omitempty"` // Empty = all types
        StartDate   *time.Time   `json:"startDate,omitempty"`
        EndDate     *time.Time   `json:"endDate,omitempty"`

        // Task filters
        TaskStatus   []string `json:"taskStatus,omitempty"`
        TaskCategory []string `json:"taskCategory,omitempty"`
        TaskTags     []string `json:"taskTags,omitempty"`

        // Project filters
        ProjectStatus []string `json:"projectStatus,omitempty"`

        // Goal filters
        GoalStatus []string `json:"goalStatus,omitempty"`
}

// ExportSummary represents summary statistics for export preview
type ExportSummary struct {
        Tasks struct {
                Total        int `json:"total"`
                Active       int `json:"active"`
                Completed    int `json:"completed"`
                HighPriority int `json:"highPriority"`
        } `json:"tasks"`
        Projects struct {
                Total     int `json:"total"`
                Active    int `json:"active"`
                Completed int `json:"completed"`
                OnHold    int `json:"onHold"`
        } `json:"projects"`
        Goals struct {
                Total     int `json:"total"`
                ShortTerm int `json:"shortTerm"`
                LongTerm  int `json:"longTerm"`
                Active    int `json:"active"`
        } `json:"goals"`
        Thoughts struct {
                Total           int `json:"total"`
                DeepThoughts    int `json:"deepThoughts"`
                WithSuggestions int `json:"withSuggestions"`
        } `json:"thoughts"`
        Moods struct {
                Total       int     `json:"total"`
                AverageMood float64 `json:"averageMood"`
                ThisMonth   int     `json:"thisMonth"`
        } `json:"moods"`
        FocusSessions struct {
                Total         int     `json:"total"`
                TotalMinutes  int     `json:"totalMinutes"`
                AverageRating float64 `json:"averageRating"`
                ThisWeek      int     `json:"thisWeek"`
        } `json:"focusSessions"`
        People struct {
                Total      int `json:"total"`
                Family     int `json:"family"`
                Friends    int `json:"friends"`
                Colleagues int `json:"colleagues"`
        } `json:"people"`
        Portfolios struct {
                Total            int     `json:"total"`
                TotalInvestments float64 `json:"totalInvestments"`
                Active           int     `json:"active"`
        } `json:"portfolios"`
        Spending struct {
                Total              int     `json:"total"`
                TotalAmount        float64 `json:"totalAmount"`
                ThisMonth          int     `json:"thisMonth"`
                AverageTransaction float64 `json:"averageTransaction"`
        } `json:"spending"`
        Relationships struct {
                Total       int `json:"total"`
                Active      int `json:"active"`
                ToolRelated int `json:"toolRelated"`
                Manual      int `json:"manual"`
        } `json:"relationships"`
        LLMLogs struct {
                Total       int `json:"total"`
                Completed   int `json:"completed"`
                Failed      int `json:"failed"`
                TotalTokens int `json:"totalTokens"`
        } `json:"llmLogs"`
}

// ValidateImport validates import data and detects conflicts
func (s *ImportExportService) ValidateImport(ctx context.Context, uid string, data []byte) (*ValidationResult, error) <span class="cov0" title="0">{
        // Parse JSON
        var importData ImportData
        if err := json.Unmarshal(data, &amp;importData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>

        // Validate metadata
        <span class="cov0" title="0">if importData.Metadata.Version == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing metadata version")
        }</span>

        <span class="cov0" title="0">result := &amp;ValidationResult{
                Valid:      true,
                Conflicts:  []Conflict{},
                ParsedData: importData,
        }

        // Count items per type
        result.Summary.ItemsPerType = make(map[EntityType]int)
        result.Summary.ItemsPerType[EntityTypeTasks] = len(importData.Entities.Tasks)
        result.Summary.ItemsPerType[EntityTypeProjects] = len(importData.Entities.Projects)
        result.Summary.ItemsPerType[EntityTypeGoals] = len(importData.Entities.Goals)
        result.Summary.ItemsPerType[EntityTypeThoughts] = len(importData.Entities.Thoughts)
        result.Summary.ItemsPerType[EntityTypeMoods] = len(importData.Entities.Moods)
        result.Summary.ItemsPerType[EntityTypeFocusSessions] = len(importData.Entities.FocusSessions)
        result.Summary.ItemsPerType[EntityTypePeople] = len(importData.Entities.People)
        result.Summary.ItemsPerType[EntityTypePortfolios] = len(importData.Entities.Portfolios)
        result.Summary.ItemsPerType[EntityTypeSpending] = len(importData.Entities.Spending)
        result.Summary.ItemsPerType[EntityTypeRelationships] = len(importData.Entities.Relationships)
        result.Summary.ItemsPerType[EntityTypeLLMLogs] = len(importData.Entities.LLMLogs)

        result.Summary.TotalItems = 0
        for _, count := range result.Summary.ItemsPerType </span><span class="cov0" title="0">{
                result.Summary.TotalItems += count
        }</span>

        // Validate and detect conflicts for each entity type
        <span class="cov0" title="0">existingIDs := make(map[EntityType]map[string]bool)

        // Fetch existing IDs from Firestore for each collection
        collections := map[EntityType]string{
                EntityTypeTasks:         "tasks",
                EntityTypeProjects:      "projects",
                EntityTypeGoals:         "goals",
                EntityTypeThoughts:      "thoughts",
                EntityTypeMoods:         "moods",
                EntityTypeFocusSessions: "focusSessions",
                EntityTypePeople:        "people",
                EntityTypePortfolios:    "portfolios",
                EntityTypeSpending:      "transactions",
                EntityTypeRelationships: "entityRelationships",
                EntityTypeLLMLogs:       "llmLogs",
        }

        for entityType, collection := range collections </span><span class="cov0" title="0">{
                existingIDs[entityType] = make(map[string]bool)

                // Query existing documents for this user
                query := s.repo.Collection(collection).Where("uid", "==", uid).Select("id")
                iter := query.Documents(ctx)
                defer iter.Stop()

                for </span><span class="cov0" title="0">{
                        doc, err := iter.Next()
                        if err == iterator.Done </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Error fetching existing IDs",
                                        zap.String("collection", collection),
                                        zap.Error(err),
                                )
                                continue</span>
                        }

                        <span class="cov0" title="0">if idVal, ok := doc.Data()["id"]; ok </span><span class="cov0" title="0">{
                                if idStr, ok := idVal.(string); ok </span><span class="cov0" title="0">{
                                        existingIDs[entityType][idStr] = true
                                }</span>
                        }
                }
        }

        // Check for duplicate IDs and validate entities
        <span class="cov0" title="0">s.validateEntities(importData.Entities.Tasks, EntityTypeTasks, existingIDs[EntityTypeTasks], result)
        s.validateEntities(importData.Entities.Projects, EntityTypeProjects, existingIDs[EntityTypeProjects], result)
        s.validateEntities(importData.Entities.Goals, EntityTypeGoals, existingIDs[EntityTypeGoals], result)
        s.validateEntities(importData.Entities.Thoughts, EntityTypeThoughts, existingIDs[EntityTypeThoughts], result)
        s.validateEntities(importData.Entities.Moods, EntityTypeMoods, existingIDs[EntityTypeMoods], result)
        s.validateEntities(importData.Entities.FocusSessions, EntityTypeFocusSessions, existingIDs[EntityTypeFocusSessions], result)
        s.validateEntities(importData.Entities.People, EntityTypePeople, existingIDs[EntityTypePeople], result)
        s.validateEntities(importData.Entities.Portfolios, EntityTypePortfolios, existingIDs[EntityTypePortfolios], result)
        s.validateEntities(importData.Entities.Spending, EntityTypeSpending, existingIDs[EntityTypeSpending], result)
        s.validateEntities(importData.Entities.Relationships, EntityTypeRelationships, existingIDs[EntityTypeRelationships], result)
        s.validateEntities(importData.Entities.LLMLogs, EntityTypeLLMLogs, existingIDs[EntityTypeLLMLogs], result)

        // Detect broken references
        s.detectBrokenReferences(&amp;importData, result)

        // Update summary
        result.Summary.ConflictCount = len(result.Conflicts)
        result.Valid = result.Summary.ConflictCount == 0

        return result, nil</span>
}

// validateEntities validates a list of entities and detects conflicts
func (s *ImportExportService) validateEntities(
        entities []map[string]interface{},
        entityType EntityType,
        existingIDs map[string]bool,
        result *ValidationResult,
) <span class="cov0" title="0">{
        for _, entity := range entities </span><span class="cov0" title="0">{
                // Validate ID field
                idVal, hasID := entity["id"]
                if !hasID </span><span class="cov0" title="0">{
                        result.Conflicts = append(result.Conflicts, Conflict{
                                Type:       ConflictTypeInvalidData,
                                EntityType: entityType,
                                EntityID:   "",
                                Field:      "id",
                                Message:    "Missing id field",
                        })
                        continue</span>
                }

                <span class="cov0" title="0">id, ok := idVal.(string)
                if !ok || id == "" </span><span class="cov0" title="0">{
                        result.Conflicts = append(result.Conflicts, Conflict{
                                Type:       ConflictTypeInvalidData,
                                EntityType: entityType,
                                EntityID:   fmt.Sprintf("%v", idVal),
                                Field:      "id",
                                Message:    "Invalid id field",
                        })
                        continue</span>
                }

                // Check for duplicate ID
                <span class="cov0" title="0">if existingIDs[id] </span><span class="cov0" title="0">{
                        result.Conflicts = append(result.Conflicts, Conflict{
                                Type:       ConflictTypeDuplicateID,
                                EntityType: entityType,
                                EntityID:   id,
                                Message:    fmt.Sprintf("Entity with ID %s already exists", id),
                        })
                        result.Summary.ExistingItems++
                }</span> else<span class="cov0" title="0"> {
                        result.Summary.NewItems++
                }</span>

                // Additional validation based on entity type
                <span class="cov0" title="0">s.validateEntityFields(entity, entityType, id, result)</span>
        }
}

// validateEntityFields validates required fields for each entity type
func (s *ImportExportService) validateEntityFields(
        entity map[string]interface{},
        entityType EntityType,
        id string,
        result *ValidationResult,
) <span class="cov0" title="0">{
        switch entityType </span>{
        case EntityTypeTasks:<span class="cov0" title="0">
                if _, ok := entity["title"]; !ok </span><span class="cov0" title="0">{
                        result.Conflicts = append(result.Conflicts, Conflict{
                                Type:       ConflictTypeInvalidData,
                                EntityType: entityType,
                                EntityID:   id,
                                Field:      "title",
                                Message:    "Missing required field: title",
                        })
                }</span>
        case EntityTypeProjects:<span class="cov0" title="0">
                if _, ok := entity["name"]; !ok </span><span class="cov0" title="0">{
                        result.Conflicts = append(result.Conflicts, Conflict{
                                Type:       ConflictTypeInvalidData,
                                EntityType: entityType,
                                EntityID:   id,
                                Field:      "name",
                                Message:    "Missing required field: name",
                        })
                }</span>
        case EntityTypeGoals:<span class="cov0" title="0">
                if _, ok := entity["title"]; !ok </span><span class="cov0" title="0">{
                        result.Conflicts = append(result.Conflicts, Conflict{
                                Type:       ConflictTypeInvalidData,
                                EntityType: entityType,
                                EntityID:   id,
                                Field:      "title",
                                Message:    "Missing required field: title",
                        })
                }</span>
                // Add more validations as needed
        }
}

// detectBrokenReferences detects broken references between entities
func (s *ImportExportService) detectBrokenReferences(importData *ImportData, result *ValidationResult) <span class="cov0" title="0">{
        // Build a map of all imported entity IDs
        importedIDs := make(map[EntityType]map[string]bool)
        importedIDs[EntityTypeTasks] = s.buildIDMap(importData.Entities.Tasks)
        importedIDs[EntityTypeProjects] = s.buildIDMap(importData.Entities.Projects)
        importedIDs[EntityTypeGoals] = s.buildIDMap(importData.Entities.Goals)
        importedIDs[EntityTypeThoughts] = s.buildIDMap(importData.Entities.Thoughts)
        importedIDs[EntityTypePeople] = s.buildIDMap(importData.Entities.People)

        // Check task references
        for _, task := range importData.Entities.Tasks </span><span class="cov0" title="0">{
                id := s.getString(task, "id")

                // Check project reference
                if projectID := s.getString(task, "projectId"); projectID != "" </span><span class="cov0" title="0">{
                        if !importedIDs[EntityTypeProjects][projectID] </span><span class="cov0" title="0">{
                                result.Conflicts = append(result.Conflicts, Conflict{
                                        Type:       ConflictTypeBrokenReference,
                                        EntityType: EntityTypeTasks,
                                        EntityID:   id,
                                        Field:      "projectId",
                                        Message:    fmt.Sprintf("Referenced project %s not found in import", projectID),
                                })
                        }</span>
                }

                // Check thought references
                <span class="cov0" title="0">if thoughtIDs := s.getStringArray(task, "linkedThoughtIds"); len(thoughtIDs) &gt; 0 </span><span class="cov0" title="0">{
                        for _, thoughtID := range thoughtIDs </span><span class="cov0" title="0">{
                                if !importedIDs[EntityTypeThoughts][thoughtID] </span><span class="cov0" title="0">{
                                        result.Conflicts = append(result.Conflicts, Conflict{
                                                Type:       ConflictTypeBrokenReference,
                                                EntityType: EntityTypeTasks,
                                                EntityID:   id,
                                                Field:      "linkedThoughtIds",
                                                Message:    fmt.Sprintf("Referenced thought %s not found in import", thoughtID),
                                        })
                                }</span>
                        }
                }
        }

        // Check project  goal references
        <span class="cov0" title="0">for _, project := range importData.Entities.Projects </span><span class="cov0" title="0">{
                id := s.getString(project, "id")

                if goalIDs := s.getStringArray(project, "goalIds"); len(goalIDs) &gt; 0 </span><span class="cov0" title="0">{
                        for _, goalID := range goalIDs </span><span class="cov0" title="0">{
                                if !importedIDs[EntityTypeGoals][goalID] </span><span class="cov0" title="0">{
                                        result.Conflicts = append(result.Conflicts, Conflict{
                                                Type:       ConflictTypeBrokenReference,
                                                EntityType: EntityTypeProjects,
                                                EntityID:   id,
                                                Field:      "goalIds",
                                                Message:    fmt.Sprintf("Referenced goal %s not found in import", goalID),
                                        })
                                }</span>
                        }
                }
        }
}

// buildIDMap builds a map of IDs from a list of entities
func (s *ImportExportService) buildIDMap(entities []map[string]interface{}) map[string]bool <span class="cov0" title="0">{
        idMap := make(map[string]bool)
        for _, entity := range entities </span><span class="cov0" title="0">{
                if id := s.getString(entity, "id"); id != "" </span><span class="cov0" title="0">{
                        idMap[id] = true
                }</span>
        }
        <span class="cov0" title="0">return idMap</span>
}

// Helper functions to extract values from map[string]interface{}
func (s *ImportExportService) getString(m map[string]interface{}, key string) string <span class="cov0" title="0">{
        if val, ok := m[key]; ok </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (s *ImportExportService) getStringArray(m map[string]interface{}, key string) []string <span class="cov0" title="0">{
        if val, ok := m[key]; ok </span><span class="cov0" title="0">{
                if arr, ok := val.([]interface{}); ok </span><span class="cov0" title="0">{
                        result := make([]string, 0, len(arr))
                        for _, item := range arr </span><span class="cov0" title="0">{
                                if str, ok := item.(string); ok </span><span class="cov0" title="0">{
                                        result = append(result, str)
                                }</span>
                        }
                        <span class="cov0" title="0">return result</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// ExecuteImport executes the import with the given options
func (s *ImportExportService) ExecuteImport(
        ctx context.Context,
        uid string,
        data *ImportData,
        options ImportOptions,
) (*ImportResult, error) <span class="cov0" title="0">{
        result := &amp;ImportResult{
                Success: true,
                ByType:  make(map[EntityType]int),
                Errors:  []string{},
        }

        // Determine import order based on dependencies
        importOrder := []struct {
                entityType EntityType
                collection string
                entities   []map[string]interface{}
        }{
                {EntityTypeGoals, "goals", data.Entities.Goals},
                {EntityTypeProjects, "projects", data.Entities.Projects},
                {EntityTypeThoughts, "thoughts", data.Entities.Thoughts},
                {EntityTypePeople, "people", data.Entities.People},
                {EntityTypeTasks, "tasks", data.Entities.Tasks}, // Tasks depend on projects/thoughts
                {EntityTypeMoods, "moods", data.Entities.Moods},
                {EntityTypeFocusSessions, "focusSessions", data.Entities.FocusSessions},
                {EntityTypePortfolios, "portfolios", data.Entities.Portfolios},
                {EntityTypeSpending, "transactions", data.Entities.Spending},
                {EntityTypeRelationships, "entityRelationships", data.Entities.Relationships},
                {EntityTypeLLMLogs, "llmLogs", data.Entities.LLMLogs},
        }

        // Import each entity type
        for _, item := range importOrder </span><span class="cov0" title="0">{
                if len(item.entities) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Filter by selection if provided
                <span class="cov0" title="0">entitiesToImport := item.entities
                if options.Selection != nil &amp;&amp; len(options.Selection[item.entityType]) &gt; 0 </span><span class="cov0" title="0">{
                        selected := make(map[string]bool)
                        for _, id := range options.Selection[item.entityType] </span><span class="cov0" title="0">{
                                selected[id] = true
                        }</span>

                        <span class="cov0" title="0">filtered := []map[string]interface{}{}
                        for _, entity := range item.entities </span><span class="cov0" title="0">{
                                if id := s.getString(entity, "id"); id != "" &amp;&amp; selected[id] </span><span class="cov0" title="0">{
                                        filtered = append(filtered, entity)
                                }</span>
                        }
                        <span class="cov0" title="0">entitiesToImport = filtered</span>
                }

                // Import in batches of 500 (Firestore limit)
                <span class="cov0" title="0">batchSize := 500
                for i := 0; i &lt; len(entitiesToImport); i += batchSize </span><span class="cov0" title="0">{
                        end := i + batchSize
                        if end &gt; len(entitiesToImport) </span><span class="cov0" title="0">{
                                end = len(entitiesToImport)
                        }</span>

                        <span class="cov0" title="0">batch := s.repo.Batch()
                        for _, entity := range entitiesToImport[i:end] </span><span class="cov0" title="0">{
                                id := s.getString(entity, "id")
                                if id == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Add uid to entity
                                <span class="cov0" title="0">entity["uid"] = uid

                                // Add timestamps
                                now := time.Now()
                                if _, ok := entity["createdAt"]; !ok </span><span class="cov0" title="0">{
                                        entity["createdAt"] = now
                                }</span>
                                <span class="cov0" title="0">entity["updatedAt"] = now
                                entity["updatedBy"] = uid

                                // Sanitize for Firestore (remove undefined values)
                                sanitized := s.sanitizeForFirestore(entity)

                                // Create document reference
                                docRef := s.repo.Collection(item.collection).Doc(id)
                                batch.Set(docRef, sanitized, firestore.MergeAll)</span>
                        }

                        // Commit batch
                        <span class="cov0" title="0">if _, err := batch.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                                errMsg := fmt.Sprintf("Failed to import %s batch: %v", item.entityType, err)
                                result.Errors = append(result.Errors, errMsg)
                                result.ErrorCount += (end - i)
                                result.Success = false
                                s.logger.Error("Import batch failed",
                                        zap.String("entityType", string(item.entityType)),
                                        zap.Error(err),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                imported := end - i
                                result.ImportedCount += imported
                                result.ByType[item.entityType] += imported
                        }</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// sanitizeForFirestore removes nil/undefined values recursively
func (s *ImportExportService) sanitizeForFirestore(data map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        sanitized := make(map[string]interface{})
        for key, value := range data </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        sanitized[key] = s.sanitizeForFirestore(v)</span>
                case []interface{}:<span class="cov0" title="0">
                        arr := make([]interface{}, 0, len(v))
                        for _, item := range v </span><span class="cov0" title="0">{
                                if item != nil </span><span class="cov0" title="0">{
                                        if m, ok := item.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                arr = append(arr, s.sanitizeForFirestore(m))
                                        }</span> else<span class="cov0" title="0"> {
                                                arr = append(arr, item)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if len(arr) &gt; 0 </span><span class="cov0" title="0">{
                                sanitized[key] = arr
                        }</span>
                default:<span class="cov0" title="0">
                        sanitized[key] = value</span>
                }
        }
        <span class="cov0" title="0">return sanitized</span>
}

// ExportData exports user data with optional filters
func (s *ImportExportService) ExportData(
        ctx context.Context,
        uid string,
        filters ExportFilters,
) (*ImportData, error) <span class="cov0" title="0">{
        exportData := &amp;ImportData{
                Metadata: ExportMetadata{
                        Version:    "1.0",
                        ExportedAt: time.Now(),
                        ExportedBy: uid,
                        AppVersion: "focus-notebook-backend",
                },
                Entities: EntityCollection{},
        }

        // Determine which entity types to export
        typesToExport := filters.EntityTypes
        if len(typesToExport) == 0 </span><span class="cov0" title="0">{
                // Export all types by default
                typesToExport = []EntityType{
                        EntityTypeTasks, EntityTypeProjects, EntityTypeGoals,
                        EntityTypeThoughts, EntityTypeMoods, EntityTypeFocusSessions,
                        EntityTypePeople, EntityTypePortfolios, EntityTypeSpending,
                        EntityTypeRelationships, EntityTypeLLMLogs,
                }
        }</span>

        // Export each entity type
        <span class="cov0" title="0">for _, entityType := range typesToExport </span><span class="cov0" title="0">{
                switch entityType </span>{
                case EntityTypeTasks:<span class="cov0" title="0">
                        exportData.Entities.Tasks = s.exportTasks(ctx, uid, filters)</span>
                case EntityTypeProjects:<span class="cov0" title="0">
                        exportData.Entities.Projects = s.exportProjects(ctx, uid, filters)</span>
                case EntityTypeGoals:<span class="cov0" title="0">
                        exportData.Entities.Goals = s.exportGoals(ctx, uid, filters)</span>
                case EntityTypeThoughts:<span class="cov0" title="0">
                        exportData.Entities.Thoughts = s.exportThoughts(ctx, uid, filters)</span>
                case EntityTypeMoods:<span class="cov0" title="0">
                        exportData.Entities.Moods = s.exportMoods(ctx, uid, filters)</span>
                case EntityTypeFocusSessions:<span class="cov0" title="0">
                        exportData.Entities.FocusSessions = s.exportFocusSessions(ctx, uid, filters)</span>
                case EntityTypePeople:<span class="cov0" title="0">
                        exportData.Entities.People = s.exportPeople(ctx, uid, filters)</span>
                case EntityTypePortfolios:<span class="cov0" title="0">
                        exportData.Entities.Portfolios = s.exportPortfolios(ctx, uid, filters)</span>
                case EntityTypeSpending:<span class="cov0" title="0">
                        exportData.Entities.Spending = s.exportSpending(ctx, uid, filters)</span>
                case EntityTypeRelationships:<span class="cov0" title="0">
                        exportData.Entities.Relationships = s.exportRelationships(ctx, uid, filters)</span>
                case EntityTypeLLMLogs:<span class="cov0" title="0">
                        exportData.Entities.LLMLogs = s.exportLLMLogs(ctx, uid, filters)</span>
                }
        }

        // Calculate total items
        <span class="cov0" title="0">exportData.Metadata.TotalItems = len(exportData.Entities.Tasks) +
                len(exportData.Entities.Projects) + len(exportData.Entities.Goals) +
                len(exportData.Entities.Thoughts) + len(exportData.Entities.Moods) +
                len(exportData.Entities.FocusSessions) + len(exportData.Entities.People) +
                len(exportData.Entities.Portfolios) + len(exportData.Entities.Spending) +
                len(exportData.Entities.Relationships) + len(exportData.Entities.LLMLogs)

        return exportData, nil</span>
}

// Export functions for each entity type
func (s *ImportExportService) exportTasks(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("tasks").Where("uid", "==", uid)

        // Apply filters
        if len(filters.TaskStatus) &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("status", "in", toInterfaceSlice(filters.TaskStatus))
        }</span>
        <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("createdAt", "&gt;=", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("createdAt", "&lt;=", *filters.EndDate)
        }</span>

        <span class="cov0" title="0">return s.queryToMaps(ctx, query)</span>
}

func (s *ImportExportService) exportProjects(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("projects").Where("uid", "==", uid)

        if len(filters.ProjectStatus) &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("status", "in", toInterfaceSlice(filters.ProjectStatus))
        }</span>
        <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("createdAt", "&gt;=", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("createdAt", "&lt;=", *filters.EndDate)
        }</span>

        <span class="cov0" title="0">return s.queryToMaps(ctx, query)</span>
}

func (s *ImportExportService) exportGoals(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("goals").Where("uid", "==", uid)

        if len(filters.GoalStatus) &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("status", "in", toInterfaceSlice(filters.GoalStatus))
        }</span>
        <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("createdAt", "&gt;=", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("createdAt", "&lt;=", *filters.EndDate)
        }</span>

        <span class="cov0" title="0">return s.queryToMaps(ctx, query)</span>
}

func (s *ImportExportService) exportThoughts(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("thoughts").Where("uid", "==", uid)

        if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("createdAt", "&gt;=", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("createdAt", "&lt;=", *filters.EndDate)
        }</span>

        <span class="cov0" title="0">return s.queryToMaps(ctx, query)</span>
}

func (s *ImportExportService) exportMoods(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("moods").Where("uid", "==", uid)

        if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("date", "&gt;=", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("date", "&lt;=", *filters.EndDate)
        }</span>

        <span class="cov0" title="0">return s.queryToMaps(ctx, query)</span>
}

func (s *ImportExportService) exportFocusSessions(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("focusSessions").Where("uid", "==", uid)

        if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("startedAt", "&gt;=", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("startedAt", "&lt;=", *filters.EndDate)
        }</span>

        <span class="cov0" title="0">return s.queryToMaps(ctx, query)</span>
}

func (s *ImportExportService) exportPeople(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("people").Where("uid", "==", uid)
        return s.queryToMaps(ctx, query)
}</span>

func (s *ImportExportService) exportPortfolios(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("portfolios").Where("uid", "==", uid)
        return s.queryToMaps(ctx, query)
}</span>

func (s *ImportExportService) exportSpending(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("transactions").Where("uid", "==", uid)

        if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("date", "&gt;=", filters.StartDate.Format("2006-01-02"))
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("date", "&lt;=", filters.EndDate.Format("2006-01-02"))
        }</span>

        <span class="cov0" title="0">return s.queryToMaps(ctx, query)</span>
}

func (s *ImportExportService) exportRelationships(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("entityRelationships").Where("uid", "==", uid)
        return s.queryToMaps(ctx, query)
}</span>

func (s *ImportExportService) exportLLMLogs(ctx context.Context, uid string, filters ExportFilters) []map[string]interface{} <span class="cov0" title="0">{
        query := s.repo.Collection("llmLogs").Where("uid", "==", uid)

        if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("timestamp", "&gt;=", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("timestamp", "&lt;=", *filters.EndDate)
        }</span>

        <span class="cov0" title="0">return s.queryToMaps(ctx, query)</span>
}

// queryToMaps executes a query and returns results as maps
func (s *ImportExportService) queryToMaps(ctx context.Context, query firestore.Query) []map[string]interface{} <span class="cov0" title="0">{
        iter := query.Documents(ctx)
        defer iter.Stop()

        results := []map[string]interface{}{}
        for </span><span class="cov0" title="0">{
                doc, err := iter.Next()
                if err == iterator.Done </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Error fetching document", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">results = append(results, doc.Data())</span>
        }

        <span class="cov0" title="0">return results</span>
}

// GetExportSummary calculates summary statistics for export preview
func (s *ImportExportService) GetExportSummary(ctx context.Context, uid string) (*ExportSummary, error) <span class="cov0" title="0">{
        summary := &amp;ExportSummary{}

        // Fetch and calculate tasks summary
        tasksQuery := s.repo.Collection("tasks").Where("uid", "==", uid)
        tasks := s.queryToMaps(ctx, tasksQuery)
        summary.Tasks.Total = len(tasks)
        for _, task := range tasks </span><span class="cov0" title="0">{
                status := strings.ToLower(s.getString(task, "status"))
                if status == "active" || status == "in-progress" </span><span class="cov0" title="0">{
                        summary.Tasks.Active++
                }</span>
                <span class="cov0" title="0">if status == "completed" || status == "done" </span><span class="cov0" title="0">{
                        summary.Tasks.Completed++
                }</span>
                <span class="cov0" title="0">if s.getString(task, "priority") == "high" </span><span class="cov0" title="0">{
                        summary.Tasks.HighPriority++
                }</span>
        }

        // Projects summary
        <span class="cov0" title="0">projectsQuery := s.repo.Collection("projects").Where("uid", "==", uid)
        projects := s.queryToMaps(ctx, projectsQuery)
        summary.Projects.Total = len(projects)
        for _, project := range projects </span><span class="cov0" title="0">{
                status := strings.ToLower(s.getString(project, "status"))
                if status == "active" </span><span class="cov0" title="0">{
                        summary.Projects.Active++
                }</span>
                <span class="cov0" title="0">if status == "completed" </span><span class="cov0" title="0">{
                        summary.Projects.Completed++
                }</span>
                <span class="cov0" title="0">if status == "on-hold" || status == "paused" </span><span class="cov0" title="0">{
                        summary.Projects.OnHold++
                }</span>
        }

        // Goals summary
        <span class="cov0" title="0">goalsQuery := s.repo.Collection("goals").Where("uid", "==", uid)
        goals := s.queryToMaps(ctx, goalsQuery)
        summary.Goals.Total = len(goals)
        for _, goal := range goals </span><span class="cov0" title="0">{
                goalType := strings.ToLower(s.getString(goal, "type"))
                if goalType == "short-term" </span><span class="cov0" title="0">{
                        summary.Goals.ShortTerm++
                }</span>
                <span class="cov0" title="0">if goalType == "long-term" </span><span class="cov0" title="0">{
                        summary.Goals.LongTerm++
                }</span>
                <span class="cov0" title="0">status := strings.ToLower(s.getString(goal, "status"))
                if status == "active" </span><span class="cov0" title="0">{
                        summary.Goals.Active++
                }</span>
        }

        // Add other summaries as needed (thoughts, moods, focus sessions, etc.)
        // For brevity, showing pattern for a few types

        <span class="cov0" title="0">return summary, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package services

import (
        "context"
        "fmt"
        "math"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// InvestmentCalculationService handles investment calculation operations
type InvestmentCalculationService struct {
        repo   interfaces.Repository
        logger *zap.Logger
}

// NewInvestmentCalculationService creates a new investment calculation service
func NewInvestmentCalculationService(repo interfaces.Repository, logger *zap.Logger) *InvestmentCalculationService <span class="cov8" title="1">{
        return &amp;InvestmentCalculationService{
                repo:   repo,
                logger: logger,
        }
}</span>

// PortfolioMetrics represents calculated metrics for a portfolio
type PortfolioMetrics struct {
        TotalValue      float64            `json:"totalValue"`
        TotalInvested   float64            `json:"totalInvested"`
        TotalGain       float64            `json:"totalGain"`
        ROI             float64            `json:"roi"`
        InvestmentCount int                `json:"investmentCount"`
        Currency        string             `json:"currency"`
        ByInvestment    []InvestmentMetric `json:"byInvestment"`
}

// InvestmentMetric represents metrics for a single investment
type InvestmentMetric struct {
        ID            string  `json:"id"`
        Ticker        string  `json:"ticker,omitempty"`
        CurrentValue  float64 `json:"currentValue"`
        InitialAmount float64 `json:"initialAmount"`
        Gain          float64 `json:"gain"`
        ROI           float64 `json:"roi"`
        Currency      string  `json:"currency"`
}

// ProjectionPoint represents a point in a projection series
type ProjectionPoint struct {
        Month               int     `json:"month"`
        Year                int     `json:"year"`
        TotalValue          float64 `json:"totalValue"`
        PrincipalValue      float64 `json:"principalValue"`
        ContributionsValue  float64 `json:"contributionsValue"`
        GrowthValue         float64 `json:"growthValue"`
        TotalContributions  float64 `json:"totalContributions"`
        MonthlyContribution float64 `json:"monthlyContribution"`
}

// ProjectionRequest represents a request for projection calculation
type ProjectionRequest struct {
        InitialAmount float64        `json:"initialAmount"`
        AnnualReturn  float64        `json:"annualReturn"`
        Months        int            `json:"months"`
        Contributions []Contribution `json:"contributions"`
}

// Contribution represents a recurring contribution
type Contribution struct {
        Amount    float64 `json:"amount"`
        Frequency string  `json:"frequency"` // monthly, quarterly, yearly
}

// ProjectionResponse represents the projection calculation result
type ProjectionResponse struct {
        Points    []ProjectionPoint `json:"points"`
        FinalYear ProjectionPoint   `json:"finalYear"`
        Summary   struct {
                TotalValue          float64 `json:"totalValue"`
                TotalContributed    float64 `json:"totalContributed"`
                TotalGrowth         float64 `json:"totalGrowth"`
                EffectiveAnnualRate float64 `json:"effectiveAnnualRate"`
        } `json:"summary"`
}

// DashboardSummary represents aggregate summary across all portfolios
type DashboardSummary struct {
        TotalValue       float64                    `json:"totalValue"`
        TotalInvested    float64                    `json:"totalInvested"`
        TotalGain        float64                    `json:"totalGain"`
        OverallROI       float64                    `json:"overallROI"`
        PortfolioCount   int                        `json:"portfolioCount"`
        InvestmentCount  int                        `json:"investmentCount"`
        ByCurrency       map[string]CurrencySummary `json:"byCurrency"`
        TopPerformers    []InvestmentPerformance    `json:"topPerformers"`
        BottomPerformers []InvestmentPerformance    `json:"bottomPerformers"`
}

// CurrencySummary represents summary for a specific currency
type CurrencySummary struct {
        TotalValue    float64 `json:"totalValue"`
        TotalInvested float64 `json:"totalInvested"`
        TotalGain     float64 `json:"totalGain"`
        Count         int     `json:"count"`
}

// InvestmentPerformance represents performance data for sorting
type InvestmentPerformance struct {
        ID           string  `json:"id"`
        PortfolioID  string  `json:"portfolioId"`
        Ticker       string  `json:"ticker,omitempty"`
        CurrentValue float64 `json:"currentValue"`
        Gain         float64 `json:"gain"`
        ROI          float64 `json:"roi"`
        Currency     string  `json:"currency"`
}

// CalculatePortfolioMetrics calculates metrics for a specific portfolio
func (s *InvestmentCalculationService) CalculatePortfolioMetrics(
        ctx context.Context,
        uid string,
        portfolioID string,
) (*PortfolioMetrics, error) <span class="cov8" title="1">{
        // Fetch all portfolios and find the one with matching ID
        allPortfolios, err := s.repo.List(ctx, "portfolios", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch portfolios: %w", err)
        }</span>

        <span class="cov8" title="1">var portfolio map[string]interface{}
        for _, p := range allPortfolios </span><span class="cov8" title="1">{
                if id, ok := p["id"].(string); ok &amp;&amp; id == portfolioID </span><span class="cov8" title="1">{
                        if pUID, ok := p["uid"].(string); ok &amp;&amp; pUID == uid </span><span class="cov8" title="1">{
                                portfolio = p
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if portfolio == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("portfolio not found")
        }</span>

        // Fetch all investments for this portfolio
        <span class="cov8" title="1">allInvestments, err := s.repo.List(ctx, "investments", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch investments: %w", err)
        }</span>

        <span class="cov8" title="1">metrics := &amp;PortfolioMetrics{
                Currency:     s.getStringFromMap(portfolio, "baseCurrency", "USD"),
                ByInvestment: []InvestmentMetric{},
        }

        // Filter investments by uid and portfolioId, then calculate metrics
        for _, investment := range allInvestments </span><span class="cov8" title="1">{
                // Filter by uid and portfolioId
                if invUID, ok := investment["uid"].(string); !ok || invUID != uid </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if portID, ok := investment["portfolioId"].(string); !ok || portID != portfolioID </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">invMetric := s.calculateInvestmentMetric(investment)
                metrics.ByInvestment = append(metrics.ByInvestment, invMetric)

                // Aggregate to portfolio level
                metrics.TotalValue += invMetric.CurrentValue
                metrics.TotalInvested += invMetric.InitialAmount
                metrics.InvestmentCount++</span>
        }

        // Calculate derived metrics
        <span class="cov8" title="1">metrics.TotalGain = metrics.TotalValue - metrics.TotalInvested
        if metrics.TotalInvested &gt; 0 </span><span class="cov8" title="1">{
                metrics.ROI = (metrics.TotalGain / metrics.TotalInvested) * 100
        }</span>

        <span class="cov8" title="1">return metrics, nil</span>
}

// calculateInvestmentMetric calculates metrics for a single investment
func (s *InvestmentCalculationService) calculateInvestmentMetric(investment map[string]interface{}) InvestmentMetric <span class="cov8" title="1">{
        metric := InvestmentMetric{
                ID:            s.getStringFromMap(investment, "id", ""),
                Ticker:        s.getStringFromMap(investment, "ticker", ""),
                CurrentValue:  s.getFloatFromMap(investment, "currentValue", 0),
                InitialAmount: s.getFloatFromMap(investment, "initialAmount", 0),
                Currency:      s.getStringFromMap(investment, "currency", "USD"),
        }

        // Calculate contributions if present
        if contribs, ok := investment["contributions"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, c := range contribs </span><span class="cov0" title="0">{
                        if contrib, ok := c.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                amount := s.getFloatFromMap(contrib, "amount", 0)
                                contribType := s.getStringFromMap(contrib, "type", "")
                                if contribType == "deposit" </span><span class="cov0" title="0">{
                                        metric.InitialAmount += amount
                                }</span> else<span class="cov0" title="0"> if contribType == "withdrawal" </span><span class="cov0" title="0">{
                                        metric.InitialAmount -= amount
                                }</span>
                        }
                }
        }

        // Calculate gain and ROI
        <span class="cov8" title="1">metric.Gain = metric.CurrentValue - metric.InitialAmount
        if metric.InitialAmount &gt; 0 </span><span class="cov8" title="1">{
                metric.ROI = (metric.Gain / metric.InitialAmount) * 100
        }</span>

        <span class="cov8" title="1">return metric</span>
}

// GenerateProjection generates a compound interest projection
func (s *InvestmentCalculationService) GenerateProjection(
        ctx context.Context,
        req ProjectionRequest,
) (*ProjectionResponse, error) <span class="cov8" title="1">{
        // Validate inputs
        if req.Months &lt;= 0 || req.Months &gt; 360 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("months must be between 1 and 360")
        }</span>
        <span class="cov8" title="1">if req.AnnualReturn &lt; -100 || req.AnnualReturn &gt; 100 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("annual return must be between -100 and 100")
        }</span>

        <span class="cov8" title="1">response := &amp;ProjectionResponse{
                Points: make([]ProjectionPoint, 0, req.Months+1),
        }

        // Calculate monthly rate
        monthlyRate := req.AnnualReturn / 100 / 12
        growthFactor := 1 + monthlyRate

        // Initial values
        principalValue := req.InitialAmount
        contributionsValue := 0.0
        totalContributions := 0.0

        // Add initial point (month 0)
        response.Points = append(response.Points, ProjectionPoint{
                Month:               0,
                Year:                0,
                TotalValue:          principalValue,
                PrincipalValue:      principalValue,
                ContributionsValue:  0,
                GrowthValue:         0,
                TotalContributions:  0,
                MonthlyContribution: 0,
        })

        // Calculate each month
        for monthIndex := 1; monthIndex &lt;= req.Months; monthIndex++ </span><span class="cov8" title="1">{
                // Apply growth to existing values
                if monthlyRate != 0 </span><span class="cov8" title="1">{
                        principalValue *= growthFactor
                        contributionsValue *= growthFactor
                }</span>

                // Calculate monthly contribution
                <span class="cov8" title="1">monthlyContribution := 0.0
                for _, contrib := range req.Contributions </span><span class="cov8" title="1">{
                        multiplier := s.frequencyToMonthlyMultiplier(contrib.Frequency)
                        monthlyContribution += contrib.Amount * multiplier
                }</span>

                // Add contribution
                <span class="cov8" title="1">contributionsValue += monthlyContribution
                totalContributions += monthlyContribution

                // Calculate total and growth
                totalValue := principalValue + contributionsValue
                growthValue := totalValue - req.InitialAmount - totalContributions

                // Create projection point
                point := ProjectionPoint{
                        Month:               monthIndex,
                        Year:                monthIndex / 12,
                        TotalValue:          totalValue,
                        PrincipalValue:      principalValue,
                        ContributionsValue:  contributionsValue,
                        GrowthValue:         growthValue,
                        TotalContributions:  totalContributions,
                        MonthlyContribution: monthlyContribution,
                }

                response.Points = append(response.Points, point)</span>
        }

        // Set final year point
        <span class="cov8" title="1">response.FinalYear = response.Points[len(response.Points)-1]

        // Calculate summary
        response.Summary.TotalValue = response.FinalYear.TotalValue
        response.Summary.TotalContributed = req.InitialAmount + totalContributions
        response.Summary.TotalGrowth = response.FinalYear.GrowthValue

        // Calculate effective annual rate
        if req.Months &gt;= 12 &amp;&amp; req.InitialAmount &gt; 0 </span><span class="cov8" title="1">{
                years := float64(req.Months) / 12
                response.Summary.EffectiveAnnualRate = (math.Pow(response.FinalYear.TotalValue/req.InitialAmount, 1/years) - 1) * 100
        }</span>

        <span class="cov8" title="1">return response, nil</span>
}

// frequencyToMonthlyMultiplier converts contribution frequency to monthly multiplier
func (s *InvestmentCalculationService) frequencyToMonthlyMultiplier(frequency string) float64 <span class="cov8" title="1">{
        switch frequency </span>{
        case "monthly":<span class="cov8" title="1">
                return 1.0</span>
        case "quarterly":<span class="cov8" title="1">
                return 1.0 / 3.0</span>
        case "yearly", "annual":<span class="cov8" title="1">
                return 1.0 / 12.0</span>
        case "biweekly":<span class="cov8" title="1">
                return 26.0 / 12.0</span>
        case "weekly":<span class="cov8" title="1">
                return 52.0 / 12.0</span>
        default:<span class="cov8" title="1">
                return 0.0</span>
        }
}

// CalculateDashboardSummary calculates aggregate summary across all portfolios
func (s *InvestmentCalculationService) CalculateDashboardSummary(
        ctx context.Context,
        uid string,
        baseCurrency string,
) (*DashboardSummary, error) <span class="cov8" title="1">{
        summary := &amp;DashboardSummary{
                ByCurrency:       make(map[string]CurrencySummary),
                TopPerformers:    []InvestmentPerformance{},
                BottomPerformers: []InvestmentPerformance{},
        }

        // Fetch all portfolios
        allPortfolios, err := s.repo.List(ctx, "portfolios", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch portfolios: %w", err)
        }</span>

        // Filter portfolios by uid
        <span class="cov8" title="1">for _, p := range allPortfolios </span><span class="cov8" title="1">{
                if pUID, ok := p["uid"].(string); ok &amp;&amp; pUID == uid </span><span class="cov8" title="1">{
                        summary.PortfolioCount++
                }</span>
        }

        // Fetch all investments across all portfolios
        <span class="cov8" title="1">allInvestments, err := s.repo.List(ctx, "investments", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch investments: %w", err)
        }</span>

        <span class="cov8" title="1">allPerformances := []InvestmentPerformance{}

        // Filter investments by uid
        for _, investment := range allInvestments </span><span class="cov8" title="1">{
                if invUID, ok := investment["uid"].(string); !ok || invUID != uid </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">metric := s.calculateInvestmentMetric(investment)

                // Aggregate totals
                summary.TotalValue += metric.CurrentValue
                summary.TotalInvested += metric.InitialAmount
                summary.InvestmentCount++

                // Aggregate by currency
                currency := metric.Currency
                currSummary := summary.ByCurrency[currency]
                currSummary.TotalValue += metric.CurrentValue
                currSummary.TotalInvested += metric.InitialAmount
                currSummary.TotalGain += metric.Gain
                currSummary.Count++
                summary.ByCurrency[currency] = currSummary

                // Track performance for sorting
                allPerformances = append(allPerformances, InvestmentPerformance{
                        ID:           metric.ID,
                        PortfolioID:  s.getStringFromMap(investment, "portfolioId", ""),
                        Ticker:       metric.Ticker,
                        CurrentValue: metric.CurrentValue,
                        Gain:         metric.Gain,
                        ROI:          metric.ROI,
                        Currency:     metric.Currency,
                })</span>
        }

        // Calculate overall metrics
        <span class="cov8" title="1">summary.TotalGain = summary.TotalValue - summary.TotalInvested
        if summary.TotalInvested &gt; 0 </span><span class="cov8" title="1">{
                summary.OverallROI = (summary.TotalGain / summary.TotalInvested) * 100
        }</span>

        // Sort performances and get top/bottom 5
        <span class="cov8" title="1">s.sortPerformancesByROI(allPerformances)

        // Top performers
        topCount := 5
        if len(allPerformances) &lt; topCount </span><span class="cov8" title="1">{
                topCount = len(allPerformances)
        }</span>
        <span class="cov8" title="1">summary.TopPerformers = allPerformances[:topCount]

        // Bottom performers (reverse order)
        bottomCount := 5
        if len(allPerformances) &lt; bottomCount </span><span class="cov8" title="1">{
                bottomCount = len(allPerformances)
        }</span>
        <span class="cov8" title="1">startIdx := len(allPerformances) - bottomCount
        if startIdx &lt; 0 </span><span class="cov0" title="0">{
                startIdx = 0
        }</span>
        <span class="cov8" title="1">summary.BottomPerformers = allPerformances[startIdx:]

        return summary, nil</span>
}

// sortPerformancesByROI sorts performances by ROI descending
func (s *InvestmentCalculationService) sortPerformancesByROI(performances []InvestmentPerformance) <span class="cov8" title="1">{
        // Simple bubble sort (good enough for small lists)
        n := len(performances)
        for i := 0; i &lt; n-1; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; n-i-1; j++ </span><span class="cov8" title="1">{
                        if performances[j].ROI &lt; performances[j+1].ROI </span><span class="cov8" title="1">{
                                performances[j], performances[j+1] = performances[j+1], performances[j]
                        }</span>
                }
        }
}

// GetPortfolioSnapshots retrieves historical snapshots for a portfolio
func (s *InvestmentCalculationService) GetPortfolioSnapshots(
        ctx context.Context,
        uid string,
        portfolioID string,
        startDate *time.Time,
        endDate *time.Time,
) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Fetch all portfolio snapshots
        allSnapshots, err := s.repo.List(ctx, "portfolioSnapshots", 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch snapshots: %w", err)
        }</span>

        <span class="cov0" title="0">snapshots := []map[string]interface{}{}

        // Filter snapshots by uid, portfolioId, and date range
        for _, snapshot := range allSnapshots </span><span class="cov0" title="0">{
                // Filter by uid and portfolioId
                if snapUID, ok := snapshot["uid"].(string); !ok || snapUID != uid </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if snapPortID, ok := snapshot["portfolioId"].(string); !ok || snapPortID != portfolioID </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Filter by date range if provided
                <span class="cov0" title="0">if dateStr, ok := snapshot["date"].(string); ok </span><span class="cov0" title="0">{
                        if startDate != nil &amp;&amp; dateStr &lt; startDate.Format("2006-01-02") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if endDate != nil &amp;&amp; dateStr &gt; endDate.Format("2006-01-02") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">snapshots = append(snapshots, snapshot)</span>
        }

        <span class="cov0" title="0">return snapshots, nil</span>
}

// Helper methods to extract values from map[string]interface{}
func (s *InvestmentCalculationService) getStringFromMap(m map[string]interface{}, key string, defaultVal string) string <span class="cov8" title="1">{
        if val, ok := m[key]; ok </span><span class="cov8" title="1">{
                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return defaultVal</span>
}

func (s *InvestmentCalculationService) getFloatFromMap(m map[string]interface{}, key string, defaultVal float64) float64 <span class="cov8" title="1">{
        if val, ok := m[key]; ok </span><span class="cov8" title="1">{
                switch v := val.(type) </span>{
                case float64:<span class="cov8" title="1">
                        return v</span>
                case int64:<span class="cov0" title="0">
                        return float64(v)</span>
                case int:<span class="cov0" title="0">
                        return float64(v)</span>
                }
        }
        <span class="cov0" title="0">return defaultVal</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
)

// InvestmentPredictionService handles AI-powered investment predictions
type InvestmentPredictionService struct {
        openaiClient *clients.OpenAIClient
        logger       *zap.Logger
}

// NewInvestmentPredictionService creates a new investment prediction service
func NewInvestmentPredictionService(
        openaiClient *clients.OpenAIClient,
        logger *zap.Logger,
) *InvestmentPredictionService <span class="cov0" title="0">{
        return &amp;InvestmentPredictionService{
                openaiClient: openaiClient,
                logger:       logger,
        }
}</span>

// HistoricalDataPoint represents a historical price data point
type HistoricalDataPoint struct {
        Date  string  `json:"date"`
        Price float64 `json:"price"`
}

// PredictionDataPoint represents a predicted price point
type PredictionDataPoint struct {
        Date           string  `json:"date"`
        PredictedPrice float64 `json:"predictedPrice"`
        Confidence     string  `json:"confidence"` // low, medium, high
}

// InvestmentPrediction represents the AI's investment prediction
type InvestmentPrediction struct {
        Predictions       []PredictionDataPoint `json:"predictions"`
        Trend             string                `json:"trend"` // bullish, bearish, neutral
        Summary           string                `json:"summary"`
        Reasoning         string                `json:"reasoning"`
        RiskFactors       []string              `json:"riskFactors"`
        TargetPrice30Days float64               `json:"targetPrice30Days"`
        SupportLevel      float64               `json:"supportLevel"`
        ResistanceLevel   float64               `json:"resistanceLevel"`
}

// PredictInvestment generates AI-powered investment predictions
func (s *InvestmentPredictionService) PredictInvestment(
        ctx context.Context,
        symbol string,
        historicalData []HistoricalDataPoint,
        model string,
) (*InvestmentPrediction, error) <span class="cov0" title="0">{
        // Validate input
        if len(historicalData) &lt; 30 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("need at least 30 days of historical data for predictions")
        }</span>

        <span class="cov0" title="0">s.logger.Info("Generating investment prediction",
                zap.String("symbol", symbol),
                zap.Int("dataPoints", len(historicalData)),
                zap.String("model", model),
        )

        // Calculate statistics
        dataLength := len(historicalData)
        firstPrice := historicalData[0].Price
        lastPrice := historicalData[dataLength-1].Price
        priceChange := lastPrice - firstPrice
        priceChangePercent := (priceChange / firstPrice) * 100

        // Calculate moving averages
        avg7 := calculateAverage(historicalData[max(0, dataLength-7):])
        avg30 := calculateAverage(historicalData[max(0, dataLength-30):])

        // Sample data to reduce token usage (every 3rd day)
        sampledData := make([]HistoricalDataPoint, 0, dataLength/3)
        for i := 0; i &lt; dataLength; i += 3 </span><span class="cov0" title="0">{
                sampledData = append(sampledData, historicalData[i])
        }</span>

        // Format price data for AI
        <span class="cov0" title="0">priceDataString := ""
        for _, d := range sampledData </span><span class="cov0" title="0">{
                priceDataString += fmt.Sprintf("%s: $%.2f\n", d.Date, d.Price)
        }</span>

        // Build prompt
        <span class="cov0" title="0">prompt := fmt.Sprintf(`You are a financial analyst assistant. Analyze the following stock price data and provide a prediction.

Stock Symbol: %s
Data Period: %d days
Start Price: $%.2f
Current Price: $%.2f
Total Change: %.2f%%
7-Day Average: $%.2f
30-Day Average: $%.2f

Historical Prices (sampled):
%s

Based on this data, provide a 30-day forward prediction. Consider:
1. Recent price trends and momentum
2. Moving average crossovers
3. Price volatility
4. Historical patterns

IMPORTANT DISCLAIMERS:
- This is NOT financial advice
- Past performance does not guarantee future results
- Stock markets are unpredictable
- Use for informational purposes only

Respond ONLY with valid JSON (no markdown, no code blocks):
{
  "predictions": [
    {
      "date": "YYYY-MM-DD",
      "predictedPrice": 123.45,
      "confidence": "low|medium|high"
    }
  ],
  "trend": "bullish|bearish|neutral",
  "summary": "Brief analysis summary",
  "reasoning": "Key factors influencing the prediction",
  "riskFactors": ["List of risk factors to consider"],
  "targetPrice30Days": 123.45,
  "supportLevel": 120.00,
  "resistanceLevel": 130.00
}

Generate predictions for the next 30 days (every 3 days for efficiency).`,
                symbol,
                dataLength,
                firstPrice,
                lastPrice,
                priceChangePercent,
                avg7,
                avg30,
                priceDataString,
        )

        // Default to gpt-4o-mini if no model specified
        if model == "" </span><span class="cov0" title="0">{
                model = "gpt-4o-mini"
        }</span>

        // Call OpenAI
        <span class="cov0" title="0">response, err := s.openaiClient.ChatCompletion(ctx, clients.ChatCompletionRequest{
                Model: model,
                Messages: []clients.ChatMessage{
                        {
                                Role:    "user",
                                Content: prompt,
                        },
                },
                Temperature: 0.3, // Lower temperature for more consistent predictions
                MaxTokens:   2000,
                ResponseFormat: &amp;clients.ResponseFormat{
                        Type: "json_object",
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OpenAI API error: %w", err)
        }</span>

        <span class="cov0" title="0">if response.Content == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no response from OpenAI")
        }</span>

        // Parse JSON response
        <span class="cov0" title="0">var prediction InvestmentPrediction
        if err := json.Unmarshal([]byte(response.Content), &amp;prediction); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse AI response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;prediction, nil</span>
}

// calculateAverage calculates the average price from historical data
func calculateAverage(data []HistoricalDataPoint) float64 <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">sum := 0.0
        for _, d := range data </span><span class="cov0" title="0">{
                sum += d.Price
        }</span>
        <span class="cov0" title="0">return sum / float64(len(data))</span>
}

// max returns the maximum of two integers
func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// PackingListService handles packing list operations
type PackingListService struct {
        repo   interfaces.Repository
        logger *zap.Logger
}

// NewPackingListService creates a new packing list service
func NewPackingListService(repo interfaces.Repository, logger *zap.Logger) *PackingListService <span class="cov0" title="0">{
        return &amp;PackingListService{
                repo:   repo,
                logger: logger,
        }
}</span>

// PackingItem represents a single packing item
type PackingItem struct {
        ID          string `json:"id" firestore:"id"`
        Name        string `json:"name" firestore:"name"`
        Description string `json:"description,omitempty" firestore:"description,omitempty"`
        Quantity    string `json:"quantity,omitempty" firestore:"quantity,omitempty"`
        Tip         string `json:"tip,omitempty" firestore:"tip,omitempty"`
        Custom      bool   `json:"custom,omitempty" firestore:"custom,omitempty"`
}

// PackingGroup represents a group of packing items
type PackingGroup struct {
        ID          string        `json:"id" firestore:"id"`
        Title       string        `json:"title" firestore:"title"`
        Icon        string        `json:"icon,omitempty" firestore:"icon,omitempty"`
        Description string        `json:"description,omitempty" firestore:"description,omitempty"`
        Items       []PackingItem `json:"items" firestore:"items"`
}

// PackingSection represents a section of the packing list
type PackingSection struct {
        ID      string         `json:"id" firestore:"id"`
        Title   string         `json:"title" firestore:"title"`
        Emoji   string         `json:"emoji,omitempty" firestore:"emoji,omitempty"`
        Summary string         `json:"summary,omitempty" firestore:"summary,omitempty"`
        Groups  []PackingGroup `json:"groups" firestore:"groups"`
}

// CustomItemsState represents custom items per section
type CustomItemsState map[string][]PackingItem

// PackingList represents the complete packing list
type PackingList struct {
        ID            string            `json:"id" firestore:"-"`
        TripID        string            `json:"tripId" firestore:"tripId"`
        UserID        string            `json:"userId" firestore:"userId"`
        Sections      []PackingSection  `json:"sections" firestore:"sections"`
        PackedItemIDs []string          `json:"packedItemIds" firestore:"packedItemIds"`
        ItemStatuses  map[string]string `json:"itemStatuses" firestore:"itemStatuses"`
        CustomItems   CustomItemsState  `json:"customItems" firestore:"customItems"`
        CreatedAt     time.Time         `json:"createdAt" firestore:"createdAt"`
        UpdatedAt     time.Time         `json:"updatedAt,omitempty" firestore:"updatedAt,omitempty"`
}

// CreatePackingList creates a new packing list for a trip
func (s *PackingListService) CreatePackingList(
        ctx context.Context,
        userID string,
        tripID string,
) (*PackingList, error) <span class="cov0" title="0">{
        // Verify trip ownership
        tripPath := fmt.Sprintf("users/%s/trips/%s", userID, tripID)
        _, err := s.repo.Get(ctx, tripPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("trip not found: %w", err)
        }</span>

        // Check if packing list already exists
        <span class="cov0" title="0">packingListPath := fmt.Sprintf("%s/packingList/data", tripPath)
        existing, err := s.repo.Get(ctx, packingListPath)
        if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                // Parse and return existing
                return parsePackingList(tripID, existing), nil
        }</span>

        // Build base packing list with simplified templates
        <span class="cov0" title="0">sections := buildBaseSections()

        packingList := &amp;PackingList{
                ID:            tripID,
                TripID:        tripID,
                UserID:        userID,
                Sections:      sections,
                PackedItemIDs: []string{},
                ItemStatuses:  make(map[string]string),
                CustomItems:   make(CustomItemsState),
                CreatedAt:     time.Now(),
        }

        // Save to Firestore
        packingListData := packingListToMap(packingList)
        if err := s.repo.Create(ctx, packingListPath, packingListData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create packing list: %w", err)
        }</span>

        <span class="cov0" title="0">return packingList, nil</span>
}

// UpdatePackingList updates packing list data
func (s *PackingListService) UpdatePackingList(
        ctx context.Context,
        userID string,
        tripID string,
        updates map[string]interface{},
) error <span class="cov0" title="0">{
        // Verify trip ownership
        tripPath := fmt.Sprintf("users/%s/trips/%s", userID, tripID)
        if _, err := s.repo.Get(ctx, tripPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("trip not found: %w", err)
        }</span>

        // Update packing list
        <span class="cov0" title="0">packingListPath := fmt.Sprintf("%s/packingList/data", tripPath)
        if _, err := s.repo.Get(ctx, packingListPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("packing list not found: %w", err)
        }</span>

        <span class="cov0" title="0">updates["updatedAt"] = time.Now()
        if err := s.repo.Update(ctx, packingListPath, updates); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update packing list: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetItemStatus sets the packing status of an item
func (s *PackingListService) SetItemStatus(
        ctx context.Context,
        userID string,
        tripID string,
        itemID string,
        status string,
) error <span class="cov0" title="0">{
        // Validate status
        validStatuses := map[string]bool{
                "unpacked": true,
                "packed":   true,
                "later":    true,
                "no-need":  true,
        }
        if !validStatuses[status] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid status: must be one of unpacked, packed, later, no-need")
        }</span>

        // Verify trip ownership
        <span class="cov0" title="0">tripPath := fmt.Sprintf("users/%s/trips/%s", userID, tripID)
        if _, err := s.repo.Get(ctx, tripPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("trip not found: %w", err)
        }</span>

        // Get packing list
        <span class="cov0" title="0">packingListPath := fmt.Sprintf("%s/packingList/data", tripPath)
        data, err := s.repo.Get(ctx, packingListPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("packing list not found: %w", err)
        }</span>

        // Update item statuses
        <span class="cov0" title="0">itemStatuses := make(map[string]string)
        if statusesRaw, ok := data["itemStatuses"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for k, v := range statusesRaw </span><span class="cov0" title="0">{
                        if vStr, ok := v.(string); ok </span><span class="cov0" title="0">{
                                itemStatuses[k] = vStr
                        }</span>
                }
        }
        <span class="cov0" title="0">itemStatuses[itemID] = status

        // For backward compatibility, also update packedItemIds
        packedItemIDs := []string{}
        if idsRaw, ok := data["packedItemIds"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, id := range idsRaw </span><span class="cov0" title="0">{
                        if idStr, ok := id.(string); ok </span><span class="cov0" title="0">{
                                packedItemIDs = append(packedItemIDs, idStr)
                        }</span>
                }
        }

        <span class="cov0" title="0">if status == "packed" </span><span class="cov0" title="0">{
                // Add to packed
                found := false
                for _, id := range packedItemIDs </span><span class="cov0" title="0">{
                        if id == itemID </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        packedItemIDs = append(packedItemIDs, itemID)
                }</span>
        } else<span class="cov0" title="0"> {
                // Remove from packed
                newPacked := []string{}
                for _, id := range packedItemIDs </span><span class="cov0" title="0">{
                        if id != itemID </span><span class="cov0" title="0">{
                                newPacked = append(newPacked, id)
                        }</span>
                }
                <span class="cov0" title="0">packedItemIDs = newPacked</span>
        }

        // Update
        <span class="cov0" title="0">updates := map[string]interface{}{
                "itemStatuses":  itemStatuses,
                "packedItemIds": packedItemIDs,
                "updatedAt":     time.Now(),
        }

        if err := s.repo.Update(ctx, packingListPath, updates); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update item status: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// buildBaseSections creates base packing list sections
func buildBaseSections() []PackingSection <span class="cov0" title="0">{
        return []PackingSection{
                {
                        ID:      "essentials",
                        Title:   "Travel Essentials",
                        Emoji:   "",
                        Summary: "Documents, health items, and day-of travel basics.",
                        Groups: []PackingGroup{
                                {
                                        ID:          "documents",
                                        Title:       "Documents &amp; Access",
                                        Icon:        "",
                                        Description: "Everything you need to get out the door.",
                                        Items: []PackingItem{
                                                {ID: "essentials-passport", Name: "Passport / ID", Tip: "Store with travel wallet for easy reach."},
                                                {ID: "essentials-driving-license", Name: "Driving license", Description: "Required for car rentals and additional ID."},
                                                {ID: "essentials-itinerary", Name: "Itinerary + confirmations", Description: "Addresses, reservation codes, and tickets."},
                                                {ID: "essentials-insurance", Name: "Travel insurance info", Description: "Policy number, emergency contacts, coverage details."},
                                        },
                                },
                                {
                                        ID:          "money-financial",
                                        Title:       "Money &amp; Financial Prep",
                                        Icon:        "",
                                        Description: "Currency and payment preparation.",
                                        Items: []PackingItem{
                                                {ID: "essentials-credit-cards", Name: "Credit cards", Tip: "Primary card plus backup card stored separately."},
                                                {ID: "essentials-local-currency", Name: "Get local currency from bank"},
                                                {ID: "essentials-notify-cards", Name: "Notify credit card companies", Tip: "Inform banks of international travel dates."},
                                        },
                                },
                                {
                                        ID:          "daily",
                                        Title:       "Carry-on Daily Kit",
                                        Icon:        "",
                                        Description: "Comfort and essentials for the journey itself.",
                                        Items: []PackingItem{
                                                {ID: "essentials-keys", Name: "Keys", Description: "House keys and any other essential keys."},
                                                {ID: "essentials-snacks", Name: "Snacks &amp; hydration", Description: "Reusable bottle, protein snack, gum."},
                                                {ID: "essentials-comfort", Name: "Comfort items", Tip: "Neck pillow, sleep mask, or cozy scarf."},
                                                {ID: "essentials-health", Name: "Health essentials", Description: "Meds, supplements, motion sickness aids."},
                                        },
                                },
                        },
                },
                {
                        ID:      "clothing",
                        Title:   "Clothing &amp; Layers",
                        Emoji:   "",
                        Summary: "Build a flexible capsule wardrobe for the trip length.",
                        Groups: []PackingGroup{
                                {
                                        ID:          "wardrobe",
                                        Title:       "Core Wardrobe",
                                        Icon:        "",
                                        Description: "Mix-and-match outfits for day to night.",
                                        Items: []PackingItem{
                                                {ID: "clothing-tops", Name: "Tops", Quantity: "4-6", Tip: "Blend breathable and dressier options."},
                                                {ID: "clothing-bottoms", Name: "Bottoms", Quantity: "2-3", Description: "Casual + polished pairings."},
                                                {ID: "clothing-dressy", Name: "Elevated outfit", Quantity: "1", Tip: "Pack one piece that instantly dresses up."},
                                        },
                                },
                                {
                                        ID:          "footwear",
                                        Title:       "Footwear",
                                        Icon:        "",
                                        Description: "Comfortable shoes for all activities.",
                                        Items: []PackingItem{
                                                {ID: "clothing-white-sneakers", Name: "White sneakers (daily wear)", Tip: "Versatile and comfortable."},
                                                {ID: "clothing-sandals", Name: "Sandals / Beach shoes"},
                                                {ID: "clothing-hiking-shoes", Name: "Lightweight hiking or walking shoes"},
                                        },
                                },
                                {
                                        ID:          "foundations",
                                        Title:       "Foundations",
                                        Icon:        "",
                                        Description: "Underlayers that keep you comfortable.",
                                        Items: []PackingItem{
                                                {ID: "clothing-underwear", Name: "Underwear", Quantity: "7+ days", Tip: "Quick-dry fabric."},
                                                {ID: "clothing-socks", Name: "Socks", Quantity: "3-5 pairs"},
                                                {ID: "clothing-sleep", Name: "Sleepwear", Quantity: "1-2 sets"},
                                        },
                                },
                        },
                },
                {
                        ID:      "personal",
                        Title:   "Personal Care",
                        Emoji:   "",
                        Summary: "Toiletries, wellness, and day-to-day routines.",
                        Groups: []PackingGroup{
                                {
                                        ID:          "toiletries",
                                        Title:       "Toiletry Kit (Travel-Size)",
                                        Icon:        "",
                                        Description: "Mini versions of your daily routine.",
                                        Items: []PackingItem{
                                                {ID: "personal-toothbrush", Name: "Toothbrush + paste"},
                                                {ID: "personal-razor", Name: "Razor &amp; trimmer"},
                                                {ID: "personal-skincare", Name: "Skincare basics", Tip: "Cleanser, moisturizer, SPF."},
                                                {ID: "personal-hair", Name: "Hair care essentials"},
                                                {ID: "personal-shower", Name: "Shower essentials", Description: "Travel-size shampoo, conditioner, body wash."},
                                                {ID: "personal-deodorant", Name: "Deodorant"},
                                        },
                                },
                                {
                                        ID:          "wellness",
                                        Title:       "Wellness &amp; Health",
                                        Icon:        "",
                                        Description: "Keep energy steady on the road.",
                                        Items: []PackingItem{
                                                {ID: "personal-meds", Name: "Medications &amp; supplements", Tip: "Pack a full supply + prescription copies."},
                                                {ID: "personal-firstaid", Name: "Mini first-aid kit", Description: "Bandages, pain relief, motion sickness aids."},
                                        },
                                },
                        },
                },
                {
                        ID:      "tech",
                        Title:   "Tech &amp; Power",
                        Emoji:   "",
                        Summary: "Stay connected and powered up anywhere.",
                        Groups: []PackingGroup{
                                {
                                        ID:          "devices",
                                        Title:       "Devices",
                                        Icon:        "",
                                        Description: "Core electronics for travel days and downtime.",
                                        Items: []PackingItem{
                                                {ID: "tech-phone", Name: "Phone + charger"},
                                                {ID: "tech-laptop", Name: "Laptop + charger"},
                                                {ID: "tech-headphones", Name: "Headphones"},
                                        },
                                },
                                {
                                        ID:          "power",
                                        Title:       "Power &amp; Connectivity",
                                        Icon:        "",
                                        Description: "Adapters, cables, and portable power.",
                                        Items: []PackingItem{
                                                {ID: "tech-adapter", Name: "Universal travel adapter"},
                                                {ID: "tech-powerbank", Name: "Power bank", Tip: "10,000+ mAh keeps phones topped up."},
                                                {ID: "tech-cables", Name: "Charging cables"},
                                        },
                                },
                        },
                },
                {
                        ID:      "extras",
                        Title:   "Comfort Extras",
                        Emoji:   "",
                        Summary: "Optional upgrades and personal touches.",
                        Groups: []PackingGroup{
                                {
                                        ID:          "comfort",
                                        Title:       "Transit Comfort",
                                        Icon:        "",
                                        Description: "Make long travel days easier.",
                                        Items: []PackingItem{
                                                {ID: "extras-blanket", Name: "Lightweight blanket or wrap"},
                                                {ID: "extras-eye", Name: "Sleep kit", Tip: "Eye mask and earplugs."},
                                                {ID: "extras-sunglasses", Name: "Sunglasses"},
                                        },
                                },
                        },
                },
        }
}</span>

// packingListToMap converts PackingList to map for Firestore
func packingListToMap(pl *PackingList) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "tripId":        pl.TripID,
                "userId":        pl.UserID,
                "sections":      pl.Sections,
                "packedItemIds": pl.PackedItemIDs,
                "itemStatuses":  pl.ItemStatuses,
                "customItems":   pl.CustomItems,
                "createdAt":     pl.CreatedAt,
        }
}</span>

// parsePackingList parses Firestore data into PackingList
func parsePackingList(tripID string, data map[string]interface{}) *PackingList <span class="cov0" title="0">{
        pl := &amp;PackingList{
                ID:            tripID,
                PackedItemIDs: []string{},
                ItemStatuses:  make(map[string]string),
                CustomItems:   make(CustomItemsState),
        }

        if tripIDVal, ok := data["tripId"].(string); ok </span><span class="cov0" title="0">{
                pl.TripID = tripIDVal
        }</span>
        <span class="cov0" title="0">if userIDVal, ok := data["userId"].(string); ok </span><span class="cov0" title="0">{
                pl.UserID = userIDVal
        }</span>
        <span class="cov0" title="0">if createdAt, ok := data["createdAt"].(time.Time); ok </span><span class="cov0" title="0">{
                pl.CreatedAt = createdAt
        }</span>
        <span class="cov0" title="0">if updatedAt, ok := data["updatedAt"].(time.Time); ok </span><span class="cov0" title="0">{
                pl.UpdatedAt = updatedAt
        }</span>

        // Parse sections
        <span class="cov0" title="0">if sectionsRaw, ok := data["sections"].([]interface{}); ok </span><span class="cov0" title="0">{
                sections := []PackingSection{}
                for _, sectionData := range sectionsRaw </span><span class="cov0" title="0">{
                        if sectionMap, ok := sectionData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                section := parseSection(sectionMap)
                                sections = append(sections, section)
                        }</span>
                }
                <span class="cov0" title="0">pl.Sections = sections</span>
        }

        // Parse packed items
        <span class="cov0" title="0">if packedRaw, ok := data["packedItemIds"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, id := range packedRaw </span><span class="cov0" title="0">{
                        if idStr, ok := id.(string); ok </span><span class="cov0" title="0">{
                                pl.PackedItemIDs = append(pl.PackedItemIDs, idStr)
                        }</span>
                }
        }

        // Parse item statuses
        <span class="cov0" title="0">if statusesRaw, ok := data["itemStatuses"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for k, v := range statusesRaw </span><span class="cov0" title="0">{
                        if vStr, ok := v.(string); ok </span><span class="cov0" title="0">{
                                pl.ItemStatuses[k] = vStr
                        }</span>
                }
        }

        <span class="cov0" title="0">return pl</span>
}

// parseSection parses a section from map
func parseSection(data map[string]interface{}) PackingSection <span class="cov0" title="0">{
        section := PackingSection{
                Groups: []PackingGroup{},
        }

        if id, ok := data["id"].(string); ok </span><span class="cov0" title="0">{
                section.ID = id
        }</span>
        <span class="cov0" title="0">if title, ok := data["title"].(string); ok </span><span class="cov0" title="0">{
                section.Title = title
        }</span>
        <span class="cov0" title="0">if emoji, ok := data["emoji"].(string); ok </span><span class="cov0" title="0">{
                section.Emoji = emoji
        }</span>
        <span class="cov0" title="0">if summary, ok := data["summary"].(string); ok </span><span class="cov0" title="0">{
                section.Summary = summary
        }</span>

        <span class="cov0" title="0">if groupsRaw, ok := data["groups"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, groupData := range groupsRaw </span><span class="cov0" title="0">{
                        if groupMap, ok := groupData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                group := parseGroup(groupMap)
                                section.Groups = append(section.Groups, group)
                        }</span>
                }
        }

        <span class="cov0" title="0">return section</span>
}

// parseGroup parses a group from map
func parseGroup(data map[string]interface{}) PackingGroup <span class="cov0" title="0">{
        group := PackingGroup{
                Items: []PackingItem{},
        }

        if id, ok := data["id"].(string); ok </span><span class="cov0" title="0">{
                group.ID = id
        }</span>
        <span class="cov0" title="0">if title, ok := data["title"].(string); ok </span><span class="cov0" title="0">{
                group.Title = title
        }</span>
        <span class="cov0" title="0">if icon, ok := data["icon"].(string); ok </span><span class="cov0" title="0">{
                group.Icon = icon
        }</span>
        <span class="cov0" title="0">if desc, ok := data["description"].(string); ok </span><span class="cov0" title="0">{
                group.Description = desc
        }</span>

        <span class="cov0" title="0">if itemsRaw, ok := data["items"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, itemData := range itemsRaw </span><span class="cov0" title="0">{
                        if itemMap, ok := itemData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                item := parseItem(itemMap)
                                group.Items = append(group.Items, item)
                        }</span>
                }
        }

        <span class="cov0" title="0">return group</span>
}

// parseItem parses an item from map
func parseItem(data map[string]interface{}) PackingItem <span class="cov0" title="0">{
        item := PackingItem{}

        if id, ok := data["id"].(string); ok </span><span class="cov0" title="0">{
                item.ID = id
        }</span>
        <span class="cov0" title="0">if name, ok := data["name"].(string); ok </span><span class="cov0" title="0">{
                item.Name = name
        }</span>
        <span class="cov0" title="0">if desc, ok := data["description"].(string); ok </span><span class="cov0" title="0">{
                item.Description = desc
        }</span>
        <span class="cov0" title="0">if qty, ok := data["quantity"].(string); ok </span><span class="cov0" title="0">{
                item.Quantity = qty
        }</span>
        <span class="cov0" title="0">if tip, ok := data["tip"].(string); ok </span><span class="cov0" title="0">{
                item.Tip = tip
        }</span>
        <span class="cov0" title="0">if custom, ok := data["custom"].(bool); ok </span><span class="cov0" title="0">{
                item.Custom = custom
        }</span>

        <span class="cov0" title="0">return item</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package services

import (
        "context"
        "fmt"
        "math"
        "math/rand"
        "sort"
        "time"

        "cloud.google.com/go/storage"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// PhotoService handles photo voting, Elo ratings, and signed URLs
type PhotoService struct {
        repo          interfaces.Repository
        storageClient *storage.Client
        storageBucket string
        logger        *zap.Logger
}

// NewPhotoService creates a new photo service
func NewPhotoService(
        repo interfaces.Repository,
        storageClient *storage.Client,
        storageBucket string,
        logger *zap.Logger,
) *PhotoService <span class="cov8" title="1">{
        return &amp;PhotoService{
                repo:          repo,
                storageClient: storageClient,
                storageBucket: storageBucket,
                logger:        logger,
        }
}</span>

// BattlePhoto represents a photo in a battle session
type BattlePhoto struct {
        ID            string `json:"id" firestore:"id"`
        URL           string `json:"url" firestore:"url"`
        StoragePath   string `json:"storagePath" firestore:"storagePath"`
        LibraryID     string `json:"libraryId,omitempty" firestore:"libraryId,omitempty"`
        ThumbnailURL  string `json:"thumbnailUrl,omitempty" firestore:"thumbnailUrl,omitempty"`
        ThumbnailPath string `json:"thumbnailPath,omitempty" firestore:"thumbnailPath,omitempty"`
        Rating        int    `json:"rating" firestore:"rating"`
        Wins          int    `json:"wins" firestore:"wins"`
        Losses        int    `json:"losses" firestore:"losses"`
        TotalVotes    int    `json:"totalVotes" firestore:"totalVotes"`
}

// PhotoBattle represents a photo battle session
type PhotoBattle struct {
        ID           string            `json:"id" firestore:"-"`
        OwnerID      string            `json:"ownerId" firestore:"ownerId"`
        Photos       []BattlePhoto     `json:"photos" firestore:"photos"`
        PhotoAliases map[string]string `json:"photoAliases,omitempty" firestore:"photoAliases,omitempty"`
        SecretKey    string            `json:"secretKey" firestore:"secretKey"`
        CreatedAt    time.Time         `json:"createdAt" firestore:"createdAt"`
        UpdatedAt    time.Time         `json:"updatedAt,omitempty" firestore:"updatedAt,omitempty"`
}

// VoteHistory represents a vote history entry
type VoteHistory struct {
        WinnerID  string    `json:"winnerId" firestore:"winnerId"`
        LoserID   string    `json:"loserId" firestore:"loserId"`
        VoterID   string    `json:"voterId,omitempty" firestore:"voterId,omitempty"`
        CreatedAt time.Time `json:"createdAt" firestore:"createdAt"`
}

// SubmitVote processes a photo vote using Elo rating algorithm
func (s *PhotoService) SubmitVote(
        ctx context.Context,
        sessionID string,
        winnerID string,
        loserID string,
        voterID string,
) error <span class="cov0" title="0">{
        // Get session
        sessionPath := fmt.Sprintf("photoBattles/%s", sessionID)
        sessionData, err := s.repo.Get(ctx, sessionPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("session not found: %w", err)
        }</span>

        // Parse photos
        <span class="cov0" title="0">photosRaw, ok := sessionData["photos"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid photos data")
        }</span>

        <span class="cov0" title="0">photos := make([]BattlePhoto, len(photosRaw))
        for i, p := range photosRaw </span><span class="cov0" title="0">{
                photoMap, ok := p.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">photos[i] = parseBattlePhoto(photoMap)</span>
        }

        // Find winner and loser
        <span class="cov0" title="0">var winner, loser *BattlePhoto
        var winnerIdx, loserIdx int
        for i := range photos </span><span class="cov0" title="0">{
                if photos[i].ID == winnerID </span><span class="cov0" title="0">{
                        winner = &amp;photos[i]
                        winnerIdx = i
                }</span>
                <span class="cov0" title="0">if photos[i].ID == loserID </span><span class="cov0" title="0">{
                        loser = &amp;photos[i]
                        loserIdx = i
                }</span>
        }

        <span class="cov0" title="0">if winner == nil || loser == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid photos selected")
        }</span>

        <span class="cov0" title="0">ownerID, _ := sessionData["ownerId"].(string)
        winnerLibraryID := winner.LibraryID
        loserLibraryID := loser.LibraryID

        // Calculate Elo ratings
        K := 32.0
        expectedWinner := 1.0 / (1.0 + math.Pow(10, float64(loser.Rating-winner.Rating)/400.0))
        expectedLoser := 1.0 / (1.0 + math.Pow(10, float64(winner.Rating-loser.Rating)/400.0))

        winner.Rating = int(math.Max(0, math.Round(float64(winner.Rating)+K*(1.0-expectedWinner))))
        loser.Rating = int(math.Max(0, math.Round(float64(loser.Rating)+K*(0.0-expectedLoser))))
        winner.Wins++
        winner.TotalVotes++
        loser.Losses++
        loser.TotalVotes++

        // Update photos in array
        photos[winnerIdx] = *winner
        photos[loserIdx] = *loser

        // Update session
        updateData := map[string]interface{}{
                "photos":    photos,
                "updatedAt": time.Now(),
        }
        if err := s.repo.Update(ctx, sessionPath, updateData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update session: %w", err)
        }</span>

        // Save vote history
        <span class="cov0" title="0">historyPath := fmt.Sprintf("%s/history/%d", sessionPath, time.Now().UnixNano())
        historyData := map[string]interface{}{
                "winnerId":  winnerID,
                "loserId":   loserID,
                "voterId":   voterID,
                "createdAt": time.Now(),
        }
        if err := s.repo.Create(ctx, historyPath, historyData); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to save vote history", zap.Error(err))
        }</span>

        // Update library stats (if library IDs exist)
        <span class="cov0" title="0">if ownerID != "" </span><span class="cov0" title="0">{
                if winnerLibraryID != "" </span><span class="cov0" title="0">{
                        s.updateLibraryStats(ctx, ownerID, winnerLibraryID, "win", sessionID)
                }</span>
                <span class="cov0" title="0">if loserLibraryID != "" </span><span class="cov0" title="0">{
                        s.updateLibraryStats(ctx, ownerID, loserLibraryID, "loss", sessionID)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// updateLibraryStats updates photo library stats
func (s *PhotoService) updateLibraryStats(
        ctx context.Context,
        ownerID string,
        libraryID string,
        result string,
        sessionID string,
) <span class="cov0" title="0">{
        statsPath := fmt.Sprintf("users/%s/photoLibrary/%s", ownerID, libraryID)

        // Get current data to check session tracking
        data, err := s.repo.Get(ctx, statsPath)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get library stats", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">sessionIDs := []string{}
        if sessionsRaw, ok := data["sessionIds"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, sid := range sessionsRaw </span><span class="cov0" title="0">{
                        if sidStr, ok := sid.(string); ok </span><span class="cov0" title="0">{
                                sessionIDs = append(sessionIDs, sidStr)
                        }</span>
                }
        }

        <span class="cov0" title="0">alreadyCounted := false
        for _, sid := range sessionIDs </span><span class="cov0" title="0">{
                if sid == sessionID </span><span class="cov0" title="0">{
                        alreadyCounted = true
                        break</span>
                }
        }

        // Update stats
        <span class="cov0" title="0">updates := map[string]interface{}{
                "stats.totalVotes":  incrementValue(1),
                "stats.lastVotedAt": time.Now(),
        }

        if result == "win" </span><span class="cov0" title="0">{
                updates["stats.yesVotes"] = incrementValue(1)
        }</span>

        <span class="cov0" title="0">if !alreadyCounted </span><span class="cov0" title="0">{
                updates["stats.sessionCount"] = incrementValue(1)
                sessionIDs = append(sessionIDs, sessionID)
                updates["sessionIds"] = sessionIDs
        }</span>

        <span class="cov0" title="0">if err := s.repo.Update(ctx, statsPath, updates); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to update library stats", zap.Error(err))
        }</span>
}

// Helper to create increment value
func incrementValue(n int) interface{} <span class="cov0" title="0">{
        // This is a placeholder - in actual implementation would use Firestore FieldValue.increment
        // For now we'll handle it differently
        return n
}</span>

// GetNextPair selects the next optimal photo pair using Swiss-system pairing
func (s *PhotoService) GetNextPair(ctx context.Context, sessionID string) (*BattlePhoto, *BattlePhoto, error) <span class="cov0" title="0">{
        // Get session
        sessionPath := fmt.Sprintf("photoBattles/%s", sessionID)
        sessionData, err := s.repo.Get(ctx, sessionPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("session not found: %w", err)
        }</span>

        // Parse photos
        <span class="cov0" title="0">photosRaw, ok := sessionData["photos"].([]interface{})
        if !ok || len(photosRaw) &lt; 2 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("need at least two photos for a battle")
        }</span>

        <span class="cov0" title="0">photos := make([]BattlePhoto, len(photosRaw))
        for i, p := range photosRaw </span><span class="cov0" title="0">{
                photoMap, ok := p.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">photos[i] = parseBattlePhoto(photoMap)</span>
        }

        <span class="cov0" title="0">if len(photos) &lt; 2 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("need at least two photos for a battle")
        }</span>

        // Choose pair using Swiss-system algorithm
        <span class="cov0" title="0">left, right := s.choosePairForRanking(photos)

        // Enrich with library data if needed
        ownerID, _ := sessionData["ownerId"].(string)
        enrichedLeft := s.enrichPhotoData(ctx, left, ownerID)
        enrichedRight := s.enrichPhotoData(ctx, right, ownerID)

        return &amp;enrichedLeft, &amp;enrichedRight, nil</span>
}

// choosePairForRanking implements Swiss-system inspired pairing with Glicko-2 confidence tracking
func (s *PhotoService) choosePairForRanking(photos []BattlePhoto) (BattlePhoto, BattlePhoto) <span class="cov0" title="0">{
        // Normalize photos with defaults
        normalized := make([]BattlePhoto, len(photos))
        for i, photo := range photos </span><span class="cov0" title="0">{
                normalized[i] = photo
                if normalized[i].Rating == 0 </span><span class="cov0" title="0">{
                        normalized[i].Rating = 1200
                }</span>
        }

        // Calculate rating deviation for each photo
        <span class="cov0" title="0">type enrichedPhoto struct {
                BattlePhoto
                rd       float64
                priority float64
        }

        enriched := make([]enrichedPhoto, len(normalized))
        for i, photo := range normalized </span><span class="cov0" title="0">{
                rd := calculateRatingDeviation(photo.TotalVotes)
                priority := rd/350.0 + (1.0 / (1.0 + float64(photo.TotalVotes)*0.1))
                enriched[i] = enrichedPhoto{
                        BattlePhoto: photo,
                        rd:          rd,
                        priority:    priority,
                }
        }</span>

        // Phase 1: Exploration - bootstrap new photos (&lt; 5 votes)
        <span class="cov0" title="0">newPhotos := []enrichedPhoto{}
        for _, p := range enriched </span><span class="cov0" title="0">{
                if p.TotalVotes &lt; 5 </span><span class="cov0" title="0">{
                        newPhotos = append(newPhotos, p)
                }</span>
        }

        <span class="cov0" title="0">if len(newPhotos) &gt;= 2 </span><span class="cov0" title="0">{
                // Pair new photos with each other
                rand.Shuffle(len(newPhotos), func(i, j int) </span><span class="cov0" title="0">{
                        newPhotos[i], newPhotos[j] = newPhotos[j], newPhotos[i]
                }</span>)
                // #nosec G404 -- non-cryptographic random is fine for UI photo ordering
                <span class="cov0" title="0">if rand.Float64() &gt; 0.5 </span><span class="cov0" title="0">{
                        return newPhotos[0].BattlePhoto, newPhotos[1].BattlePhoto
                }</span>
                <span class="cov0" title="0">return newPhotos[1].BattlePhoto, newPhotos[0].BattlePhoto</span>
        }

        <span class="cov0" title="0">if len(newPhotos) == 1 </span><span class="cov0" title="0">{
                // Pair new photo with established photo near median rating
                newPhoto := newPhotos[0]
                established := []enrichedPhoto{}
                for _, p := range enriched </span><span class="cov0" title="0">{
                        if p.ID != newPhoto.ID &amp;&amp; p.TotalVotes &gt;= 5 </span><span class="cov0" title="0">{
                                established = append(established, p)
                        }</span>
                }

                <span class="cov0" title="0">if len(established) &gt; 0 </span><span class="cov0" title="0">{
                        medianRating := 1200
                        sort.Slice(established, func(i, j int) bool </span><span class="cov0" title="0">{
                                return math.Abs(float64(established[i].Rating-medianRating)) &lt;
                                        math.Abs(float64(established[j].Rating-medianRating))
                        }</span>)

                        <span class="cov0" title="0">poolSize := 3
                        if len(established) &lt; poolSize </span><span class="cov0" title="0">{
                                poolSize = len(established)
                        }</span>
                        // #nosec G404 -- non-cryptographic random is fine for opponent selection
                        <span class="cov0" title="0">opponent := established[rand.Intn(poolSize)]

                        // #nosec G404 -- non-cryptographic random is fine for UI photo ordering
                        if rand.Float64() &gt; 0.5 </span><span class="cov0" title="0">{
                                return newPhoto.BattlePhoto, opponent.BattlePhoto
                        }</span>
                        <span class="cov0" title="0">return opponent.BattlePhoto, newPhoto.BattlePhoto</span>
                }
        }

        // Phase 2: Exploitation - maximize information gain
        <span class="cov0" title="0">sort.Slice(enriched, func(i, j int) bool </span><span class="cov0" title="0">{
                return enriched[i].priority &gt; enriched[j].priority
        }</span>)

        // Select anchor from top 30%
        <span class="cov0" title="0">anchorPoolSize := int(math.Max(2, math.Ceil(float64(len(enriched))*0.3)))
        // #nosec G404 -- non-cryptographic random is fine for anchor selection
        anchor := enriched[rand.Intn(anchorPoolSize)]

        // Find best opponents by information gain
        type candidate struct {
                photo      enrichedPhoto
                gain       float64
                ratingDiff int
        }

        candidates := []candidate{}
        for _, opponent := range enriched </span><span class="cov0" title="0">{
                if opponent.ID == anchor.ID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">gain := informationGain(anchor.BattlePhoto, opponent.BattlePhoto)
                ratingDiff := int(math.Abs(float64(anchor.Rating - opponent.Rating)))
                candidates = append(candidates, candidate{
                        photo:      opponent,
                        gain:       gain,
                        ratingDiff: ratingDiff,
                })</span>
        }

        <span class="cov0" title="0">if len(candidates) == 0 </span><span class="cov0" title="0">{
                // Fallback: just return first two photos
                return enriched[0].BattlePhoto, enriched[1].BattlePhoto
        }</span>

        // Sort by information gain
        <span class="cov0" title="0">sort.Slice(candidates, func(i, j int) bool </span><span class="cov0" title="0">{
                gainDiff := candidates[j].gain - candidates[i].gain
                if math.Abs(gainDiff) &gt; 0.01 </span><span class="cov0" title="0">{
                        return gainDiff &gt; 0
                }</span>
                <span class="cov0" title="0">return candidates[i].ratingDiff &lt; candidates[j].ratingDiff</span>
        })

        // Select from top 20%
        <span class="cov0" title="0">opponentPoolSize := int(math.Max(3, math.Ceil(float64(len(candidates))*0.2)))
        if opponentPoolSize &gt; len(candidates) </span><span class="cov0" title="0">{
                opponentPoolSize = len(candidates)
        }</span>

        // Weighted random selection
        <span class="cov0" title="0">totalWeight := 0.0
        for i := 0; i &lt; opponentPoolSize; i++ </span><span class="cov0" title="0">{
                totalWeight += candidates[i].gain
        }</span>

        // #nosec G404 -- non-cryptographic random is fine for weighted selection
        <span class="cov0" title="0">random := rand.Float64() * totalWeight
        chosen := candidates[0]
        for i := 0; i &lt; opponentPoolSize; i++ </span><span class="cov0" title="0">{
                random -= candidates[i].gain
                if random &lt;= 0 </span><span class="cov0" title="0">{
                        chosen = candidates[i]
                        break</span>
                }
        }

        // Randomize order
        // #nosec G404 -- non-cryptographic random is fine for UI photo ordering
        <span class="cov0" title="0">if rand.Float64() &gt; 0.5 </span><span class="cov0" title="0">{
                return anchor.BattlePhoto, chosen.photo.BattlePhoto
        }</span>
        <span class="cov0" title="0">return chosen.photo.BattlePhoto, anchor.BattlePhoto</span>
}

// calculateRatingDeviation calculates Glicko-2 inspired confidence metric
func calculateRatingDeviation(totalVotes int) float64 <span class="cov0" title="0">{
        minRD := 30.0
        maxRD := 350.0
        decayRate := 0.15

        return minRD + (maxRD-minRD)*math.Exp(-decayRate*float64(totalVotes))
}</span>

// expectedScore calculates expected match outcome using Glicko-2 formula
func expectedScore(ratingA, ratingB int, rdA, rdB float64) float64 <span class="cov0" title="0">{
        Q := math.Ln10 / 400.0
        g := 1.0 / math.Sqrt(1.0+3.0*Q*Q*(rdA*rdA+rdB*rdB)/(math.Pi*math.Pi))
        return 1.0 / (1.0 + math.Pow(10, -g*float64(ratingA-ratingB)/400.0))
}</span>

// informationGain calculates information gain from a potential matchup
func informationGain(photoA, photoB BattlePhoto) float64 <span class="cov0" title="0">{
        rdA := calculateRatingDeviation(photoA.TotalVotes)
        rdB := calculateRatingDeviation(photoB.TotalVotes)

        expected := expectedScore(photoA.Rating, photoB.Rating, rdA, rdB)
        outcomeVariance := expected * (1.0 - expected)
        uncertaintyFactor := (rdA + rdB) / (2.0 * 350.0)

        return 0.7*outcomeVariance + 0.3*uncertaintyFactor
}</span>

// enrichPhotoData enriches photo with library data
func (s *PhotoService) enrichPhotoData(ctx context.Context, photo BattlePhoto, ownerID string) BattlePhoto <span class="cov0" title="0">{
        // If photo already has url and storagePath, return as is
        if photo.URL != "" &amp;&amp; photo.StoragePath != "" </span><span class="cov0" title="0">{
                return photo
        }</span>

        // Otherwise, fetch from library
        <span class="cov0" title="0">if photo.LibraryID == "" || ownerID == "" </span><span class="cov0" title="0">{
                return photo
        }</span>

        <span class="cov0" title="0">libraryPath := fmt.Sprintf("users/%s/photoLibrary/%s", ownerID, photo.LibraryID)
        libraryData, err := s.repo.Get(ctx, libraryPath)
        if err != nil </span><span class="cov0" title="0">{
                return photo
        }</span>

        <span class="cov0" title="0">if url, ok := libraryData["url"].(string); ok &amp;&amp; url != "" </span><span class="cov0" title="0">{
                photo.URL = url
        }</span>
        <span class="cov0" title="0">if storagePath, ok := libraryData["storagePath"].(string); ok &amp;&amp; storagePath != "" </span><span class="cov0" title="0">{
                photo.StoragePath = storagePath
        }</span>
        <span class="cov0" title="0">if thumbnailURL, ok := libraryData["thumbnailUrl"].(string); ok </span><span class="cov0" title="0">{
                photo.ThumbnailURL = thumbnailURL
        }</span>
        <span class="cov0" title="0">if thumbnailPath, ok := libraryData["thumbnailPath"].(string); ok </span><span class="cov0" title="0">{
                photo.ThumbnailPath = thumbnailPath
        }</span>

        <span class="cov0" title="0">return photo</span>
}

// GetSignedURL generates a signed URL for a storage path
func (s *PhotoService) GetSignedURL(
        ctx context.Context,
        userID string,
        path string,
        expiresAt *time.Time,
) (string, time.Time, error) <span class="cov0" title="0">{
        // Verify user owns the path
        if err := s.assertUserOwnsPath(userID, path); err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, err
        }</span>

        // Default expiry: 5 years
        <span class="cov0" title="0">expires := time.Now().Add(5 * 365 * 24 * time.Hour)
        if expiresAt != nil </span><span class="cov0" title="0">{
                expires = *expiresAt
        }</span>

        // Generate signed URL
        <span class="cov0" title="0">bucket := s.storageClient.Bucket(s.storageBucket)

        url, err := bucket.SignedURL(path, &amp;storage.SignedURLOptions{
                Method:  "GET",
                Expires: expires,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, fmt.Errorf("failed to generate signed URL: %w", err)
        }</span>

        <span class="cov0" title="0">return url, expires, nil</span>
}

// assertUserOwnsPath verifies user owns the storage path
func (s *PhotoService) assertUserOwnsPath(userID string, path string) error <span class="cov0" title="0">{
        // Path must start with "images/"
        if len(path) &lt; 7 || path[:7] != "images/" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid storage path")
        }</span>

        // Path format: images/{type}/{uid}/{filename}
        // Split and verify UID matches
        <span class="cov0" title="0">segments := splitPath(path)
        if len(segments) &lt; 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("path is incomplete")
        }</span>

        <span class="cov0" title="0">pathUID := segments[2]
        if pathUID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("permission denied: cannot access other users' files")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper to split path by '/'
func splitPath(path string) []string <span class="cov0" title="0">{
        result := []string{}
        current := ""
        for _, c := range path </span><span class="cov0" title="0">{
                if c == '/' </span><span class="cov0" title="0">{
                        if current != "" </span><span class="cov0" title="0">{
                                result = append(result, current)
                                current = ""
                        }</span>
                } else<span class="cov0" title="0"> {
                        current += string(c)
                }</span>
        }
        <span class="cov0" title="0">if current != "" </span><span class="cov0" title="0">{
                result = append(result, current)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// parseBattlePhoto parses a BattlePhoto from Firestore data
func parseBattlePhoto(data map[string]interface{}) BattlePhoto <span class="cov0" title="0">{
        photo := BattlePhoto{
                Rating: 1200, // Default rating
        }

        if id, ok := data["id"].(string); ok </span><span class="cov0" title="0">{
                photo.ID = id
        }</span>
        <span class="cov0" title="0">if url, ok := data["url"].(string); ok </span><span class="cov0" title="0">{
                photo.URL = url
        }</span>
        <span class="cov0" title="0">if storagePath, ok := data["storagePath"].(string); ok </span><span class="cov0" title="0">{
                photo.StoragePath = storagePath
        }</span>
        <span class="cov0" title="0">if libraryID, ok := data["libraryId"].(string); ok </span><span class="cov0" title="0">{
                photo.LibraryID = libraryID
        }</span>
        <span class="cov0" title="0">if thumbnailURL, ok := data["thumbnailUrl"].(string); ok </span><span class="cov0" title="0">{
                photo.ThumbnailURL = thumbnailURL
        }</span>
        <span class="cov0" title="0">if thumbnailPath, ok := data["thumbnailPath"].(string); ok </span><span class="cov0" title="0">{
                photo.ThumbnailPath = thumbnailPath
        }</span>
        <span class="cov0" title="0">if rating, ok := data["rating"].(int64); ok </span><span class="cov0" title="0">{
                photo.Rating = int(rating)
        }</span> else<span class="cov0" title="0"> if rating, ok := data["rating"].(float64); ok </span><span class="cov0" title="0">{
                photo.Rating = int(rating)
        }</span>
        <span class="cov0" title="0">if wins, ok := data["wins"].(int64); ok </span><span class="cov0" title="0">{
                photo.Wins = int(wins)
        }</span> else<span class="cov0" title="0"> if wins, ok := data["wins"].(float64); ok </span><span class="cov0" title="0">{
                photo.Wins = int(wins)
        }</span>
        <span class="cov0" title="0">if losses, ok := data["losses"].(int64); ok </span><span class="cov0" title="0">{
                photo.Losses = int(losses)
        }</span> else<span class="cov0" title="0"> if losses, ok := data["losses"].(float64); ok </span><span class="cov0" title="0">{
                photo.Losses = int(losses)
        }</span>
        <span class="cov0" title="0">if totalVotes, ok := data["totalVotes"].(int64); ok </span><span class="cov0" title="0">{
                photo.TotalVotes = int(totalVotes)
        }</span> else<span class="cov0" title="0"> if totalVotes, ok := data["totalVotes"].(float64); ok </span><span class="cov0" title="0">{
                photo.TotalVotes = int(totalVotes)
        }</span>

        <span class="cov0" title="0">return photo</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// PlaceInsightsService handles place insights generation
type PlaceInsightsService struct {
        openaiClient *clients.OpenAIClient
        logger       *zap.Logger
}

// NewPlaceInsightsService creates a new place insights service
func NewPlaceInsightsService(
        openaiClient *clients.OpenAIClient,
        logger *zap.Logger,
) *PlaceInsightsService <span class="cov8" title="1">{
        return &amp;PlaceInsightsService{
                openaiClient: openaiClient,
                logger:       logger,
        }
}</span>

// PlaceInsights represents the AI-generated insights for a destination
type PlaceInsights struct {
        Destination    string                 `json:"destination"`
        Overview       string                 `json:"overview,omitempty"`
        BestTimeToGo   string                 `json:"bestTimeToGo,omitempty"`
        MustSeePlaces  []string               `json:"mustSeePlaces,omitempty"`
        LocalCuisine   []string               `json:"localCuisine,omitempty"`
        CulturalTips   []string               `json:"culturalTips,omitempty"`
        BudgetGuide    map[string]interface{} `json:"budgetGuide,omitempty"`
        Transportation map[string]interface{} `json:"transportation,omitempty"`
        Safety         string                 `json:"safety,omitempty"`
        Language       string                 `json:"language,omitempty"`
        Currency       string                 `json:"currency,omitempty"`
        AdditionalInfo map[string]interface{} `json:"additionalInfo,omitempty"`
}

// GeneratePlaceInsights generates AI-powered insights for a destination
func (s *PlaceInsightsService) GeneratePlaceInsights(
        ctx context.Context,
        destinationName string,
        country string,
) (*PlaceInsights, error) <span class="cov0" title="0">{
        // Build prompt
        prompt := s.buildPlaceInsightsPrompt(destinationName, country)

        // Call OpenAI with JSON mode
        response, err := s.openaiClient.ChatCompletion(ctx, clients.ChatCompletionRequest{
                Model: "gpt-4o-mini",
                Messages: []clients.ChatMessage{
                        {
                                Role:    "system",
                                Content: "You are a travel expert providing comprehensive, accurate destination insights. Always respond with valid JSON.",
                        },
                        {
                                Role:    "user",
                                Content: prompt,
                        },
                },
                Temperature:    0.35,
                MaxTokens:      12000,
                ResponseFormat: &amp;clients.ResponseFormat{Type: "json_object"},
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate insights: %w", err)
        }</span>

        <span class="cov0" title="0">if response.Content == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty response from OpenAI")
        }</span>

        // Parse JSON response
        <span class="cov0" title="0">var insights PlaceInsights
        if err := json.Unmarshal([]byte(response.Content), &amp;insights); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse insights JSON: %w", err)
        }</span>

        // Set destination name
        <span class="cov0" title="0">insights.Destination = destinationName

        return &amp;insights, nil</span>
}

// buildPlaceInsightsPrompt builds the prompt for place insights
func (s *PlaceInsightsService) buildPlaceInsightsPrompt(destinationName, country string) string <span class="cov0" title="0">{
        countryContext := ""
        if country != "" </span><span class="cov0" title="0">{
                countryContext = fmt.Sprintf(" in %s", country)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`Generate comprehensive travel insights for %s%s.

Provide detailed information in JSON format with the following structure:

{
  "overview": "Brief overview of the destination (2-3 sentences)",
  "bestTimeToGo": "Best time to visit and why (weather, festivals, etc.)",
  "mustSeePlaces": ["List of 5-7 must-see attractions or places"],
  "localCuisine": ["List of 4-5 must-try local dishes or food experiences"],
  "culturalTips": ["List of 4-6 important cultural etiquette tips"],
  "budgetGuide": {
    "budget": "Budget range per day (e.g., '$50-100/day')",
    "midRange": "Mid-range budget per day",
    "luxury": "Luxury budget per day",
    "notes": "Brief notes on costs"
  },
  "transportation": {
    "gettingThere": "How to get there (flights, etc.)",
    "gettingAround": "How to get around locally",
    "tips": "Transportation tips"
  },
  "safety": "Safety information and tips (2-3 sentences)",
  "language": "Primary language(s) spoken and useful phrases",
  "currency": "Local currency and payment info",
  "additionalInfo": {
    "visaInfo": "Basic visa information",
    "connectivity": "Internet/SIM card info",
    "emergencyNumbers": "Important emergency contacts"
  }
}

Be specific, practical, and up-to-date. Focus on actionable information for travelers.`,
                destinationName, countryContext)</span>
}

// VisaService handles visa requirements queries
type VisaService struct {
        repo   interfaces.Repository
        logger *zap.Logger
}

// NewVisaService creates a new visa service
func NewVisaService(repo interfaces.Repository, logger *zap.Logger) *VisaService <span class="cov8" title="1">{
        return &amp;VisaService{
                repo:   repo,
                logger: logger,
        }
}</span>

// VisaRequirement represents visa requirements for a destination
type VisaRequirement struct {
        ID                 string      `json:"id" firestore:"id"`
        SourceCountry      CountryInfo `json:"sourceCountry" firestore:"sourceCountry"`
        DestinationCountry CountryInfo `json:"destinationCountry" firestore:"destinationCountry"`
        VisaType           string      `json:"visaType" firestore:"visaType"`
        Duration           string      `json:"duration" firestore:"duration"`
        Description        string      `json:"description" firestore:"description"`
        Region             string      `json:"region" firestore:"region"`
        Requirements       []string    `json:"requirements" firestore:"requirements"`
        Notes              string      `json:"notes,omitempty" firestore:"notes,omitempty"`
        LastUpdated        string      `json:"lastUpdated" firestore:"lastUpdated"`
        Confidence         string      `json:"confidence" firestore:"confidence"`
        Source             string      `json:"source" firestore:"source"`
}

// CountryInfo represents country information
type CountryInfo struct {
        Code string `json:"code" firestore:"code"`
        Name string `json:"name" firestore:"name"`
        Flag string `json:"flag,omitempty" firestore:"flag,omitempty"`
}

// GetVisaRequirements gets visa requirements for a nationality
func (s *VisaService) GetVisaRequirements(
        ctx context.Context,
        nationality string,
) ([]VisaRequirement, error) <span class="cov0" title="0">{
        if nationality == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nationality is required")
        }</span>

        // Query visa_requirements collection
        // In Firestore, we need to query all documents where sourceCountry.code == nationality
        // Since we can't do nested field queries directly with the repository interface,
        // we'll need to get all visa requirements and filter them

        // For now, let's use a simpler approach: construct document IDs
        // The document ID format is: {sourceCountryCode}_{destinationCountryCode}
        // We'll scan for all documents starting with the nationality code

        // Get all visa_requirements documents
        <span class="cov0" title="0">requirements := []VisaRequirement{}

        // Since our repository interface doesn't support complex queries,
        // we'll use a workaround: try to fetch known destination countries
        // In a production system, you'd want to add a Query method to the repository

        // For now, return a simplified response indicating the service is available
        // The actual implementation would require querying Firestore with a where clause
        // which our current repository interface doesn't fully support

        s.logger.Warn("Visa requirements query needs Firestore query support",
                zap.String("nationality", nationality),
        )

        // Return empty list for now - this would need proper Firestore query support
        return requirements, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package services

import (
        "context"
        "fmt"
        "strings"
        "time"

        "cloud.google.com/go/firestore"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// PlaidService handles Plaid banking operations
type PlaidService struct {
        plaidClient *clients.PlaidClient
        repo        interfaces.Repository
        logger      *zap.Logger
}

// NewPlaidService creates a new Plaid service
func NewPlaidService(plaidClient *clients.PlaidClient, repo interfaces.Repository, logger *zap.Logger) *PlaidService <span class="cov8" title="1">{
        return &amp;PlaidService{
                plaidClient: plaidClient,
                repo:        repo,
                logger:      logger,
        }
}</span>

// CreateLinkTokenRequest holds parameters for creating a link token
type CreateLinkTokenRequest struct {
        UID         string
        Email       string
        Platform    string
        RedirectURI string
}

// CreateLinkToken creates a Plaid Link token for new connections
func (s *PlaidService) CreateLinkToken(ctx context.Context, req CreateLinkTokenRequest) (map[string]interface{}, error) <span class="cov0" title="0">{
        s.logger.Debug("Creating link token",
                zap.String("uid", req.UID),
                zap.String("platform", req.Platform),
        )

        result, err := s.plaidClient.CreateLinkToken(ctx, clients.CreateLinkTokenRequest{
                UserID:      req.UID,
                UserEmail:   req.Email,
                Platform:    req.Platform,
                RedirectURI: req.RedirectURI,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "link_token": result.LinkToken,
                "expires_at": result.Expiration.Format(time.RFC3339),
        }, nil</span>
}

// CreateRelinkTokenRequest holds parameters for creating a relink token
type CreateRelinkTokenRequest struct {
        UID      string
        Email    string
        ItemID   string
        Platform string
}

// CreateRelinkToken creates a Plaid Link token for updating/relinking
func (s *PlaidService) CreateRelinkToken(ctx context.Context, req CreateRelinkTokenRequest) (map[string]interface{}, error) <span class="cov0" title="0">{
        s.logger.Debug("Creating relink token",
                zap.String("uid", req.UID),
                zap.String("itemId", req.ItemID),
        )

        // Verify ownership
        itemPath := fmt.Sprintf("plaidItems/%s", req.ItemID)
        itemData, err := s.repo.Get(ctx, itemPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("item not found: %w", err)
        }</span>
        <span class="cov0" title="0">if itemData == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("item not found")
        }</span>

        <span class="cov0" title="0">if itemData["uid"] != req.UID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not authorized to access this item")
        }</span>

        // Get encrypted access token
        <span class="cov0" title="0">accessToken, err := s.getAccessToken(ctx, req.ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create link token in update mode
        <span class="cov0" title="0">result, err := s.plaidClient.CreateLinkToken(ctx, clients.CreateLinkTokenRequest{
                UserID:      req.UID,
                UserEmail:   req.Email,
                Platform:    req.Platform,
                AccessToken: accessToken,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "link_token": result.LinkToken,
                "expires_at": result.Expiration.Format(time.RFC3339),
        }, nil</span>
}

// ExchangePublicTokenRequest holds parameters for exchanging a public token
type ExchangePublicTokenRequest struct {
        UID         string
        PublicToken string
}

// ExchangePublicToken exchanges a public token for an access token and stores connection
func (s *PlaidService) ExchangePublicToken(ctx context.Context, req ExchangePublicTokenRequest) (map[string]interface{}, error) <span class="cov0" title="0">{
        s.logger.Debug("Exchanging public token", zap.String("uid", req.UID))

        // Exchange public token
        exchangeResult, err := s.plaidClient.ExchangePublicToken(ctx, clients.ExchangePublicTokenRequest{
                PublicToken: req.PublicToken,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">itemID := exchangeResult.ItemID
        accessToken := exchangeResult.AccessToken

        // Get item info
        item, err := s.plaidClient.GetItem(ctx, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get item", zap.Error(err))
                return nil, err
        }</span>

        // Get institution info
        <span class="cov0" title="0">var institutionName string
        if item.InstitutionID != "" </span><span class="cov0" title="0">{
                institution, instErr := s.plaidClient.GetInstitution(ctx, item.InstitutionID)
                if instErr != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Could not fetch institution name", zap.Error(instErr))
                        institutionName = "Unknown Institution"
                }</span> else<span class="cov0" title="0"> {
                        institutionName = institution.Name
                }</span>
        } else<span class="cov0" title="0"> {
                institutionName = "Unknown Institution"
        }</span>

        // Encrypt access token (simplified - in production, use proper KMS)
        <span class="cov0" title="0">encryptedToken := s.encryptAccessToken(accessToken)

        // Store item in Firestore
        itemPath := fmt.Sprintf("plaidItems/%s", itemID)
        itemData := map[string]interface{}{
                "uid":             req.UID,
                "institutionId":   item.InstitutionID,
                "institutionName": institutionName,
                "status":          "ok",
                "kmsRef":          encryptedToken,
                "lastSyncAt":      time.Now(),
                "createdAt":       time.Now(),
        }

        if storeErr := s.repo.SetDocument(ctx, itemPath, itemData); storeErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store item: %w", storeErr)
        }</span>

        // Get accounts
        <span class="cov0" title="0">accounts, err := s.plaidClient.GetAccounts(ctx, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get accounts", zap.Error(err))
                return nil, err
        }</span>

        // Store accounts
        <span class="cov0" title="0">accountDocs := []map[string]interface{}{}
        for _, account := range accounts </span><span class="cov0" title="0">{
                accountPath := fmt.Sprintf("accounts/%s", account.AccountID)
                accountData := map[string]interface{}{
                        "uid":     req.UID,
                        "itemId":  itemID,
                        "type":    account.Type,
                        "subtype": account.Subtype,
                        "name":    account.Name,
                        "mask":    account.Mask,
                        "balances": map[string]interface{}{
                                "current":     account.Balances.Current,
                                "available":   account.Balances.Available,
                                "isoCurrency": account.Balances.IsoCurrency,
                                "limit":       account.Balances.Limit,
                        },
                        "officialName": account.OfficialName,
                        "updatedAt":    time.Now(),
                }

                if err := s.repo.SetDocument(ctx, accountPath, accountData); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to store account", zap.Error(err), zap.String("accountId", account.AccountID))
                        continue</span>
                }

                <span class="cov0" title="0">accountDocs = append(accountDocs, map[string]interface{}{
                        "id":   account.AccountID,
                        "name": account.Name,
                        "type": account.Type,
                        "mask": account.Mask,
                })</span>
        }

        // Trigger initial transaction sync (async)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                syncCtx := context.Background()
                if _, err := s.syncTransactions(syncCtx, itemID, accessToken, req.UID, nil); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to sync transactions after exchange", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">s.logger.Info("Public token exchanged successfully",
                zap.String("uid", req.UID),
                zap.String("itemId", itemID),
                zap.String("institution", institutionName),
                zap.Int("accounts", len(accountDocs)),
        )

        return map[string]interface{}{
                "itemId":          itemID,
                "institutionId":   item.InstitutionID,
                "institutionName": institutionName,
                "accounts":        accountDocs,
        }, nil</span>
}

// MarkRelinkingRequest holds parameters for marking relinking as complete
type MarkRelinkingRequest struct {
        UID    string
        ItemID string
}

// MarkRelinking marks an item as successfully relinked
func (s *PlaidService) MarkRelinking(ctx context.Context, req MarkRelinkingRequest) error <span class="cov0" title="0">{
        s.logger.Debug("Marking relinking complete",
                zap.String("uid", req.UID),
                zap.String("itemId", req.ItemID),
        )

        // Verify ownership
        itemPath := fmt.Sprintf("plaidItems/%s", req.ItemID)
        itemData, err := s.repo.Get(ctx, itemPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found: %w", err)
        }</span>
        <span class="cov0" title="0">if itemData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found")
        }</span>

        <span class="cov0" title="0">if itemData["uid"] != req.UID </span><span class="cov0" title="0">{
                return fmt.Errorf("not authorized to access this item")
        }</span>

        // Update status to ok
        <span class="cov0" title="0">if updateErr := s.updateItemStatus(ctx, req.ItemID, "ok"); updateErr != nil </span><span class="cov0" title="0">{
                return updateErr
        }</span>

        // Get access token and trigger sync
        <span class="cov0" title="0">accessToken, err := s.getAccessToken(ctx, req.ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get current cursor
        <span class="cov0" title="0">var cursor *string
        if cursorVal, ok := itemData["cursor"].(string); ok &amp;&amp; cursorVal != "" </span><span class="cov0" title="0">{
                cursor = &amp;cursorVal
        }</span>

        // Trigger sync (async)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                syncCtx := context.Background()
                if _, err := s.syncTransactions(syncCtx, req.ItemID, accessToken, req.UID, cursor); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to sync transactions after relinking", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// TriggerSyncRequest holds parameters for triggering a sync
type TriggerSyncRequest struct {
        UID    string
        ItemID string
}

// TriggerSync manually triggers a transaction sync
func (s *PlaidService) TriggerSync(ctx context.Context, req TriggerSyncRequest) (map[string]interface{}, error) <span class="cov0" title="0">{
        s.logger.Debug("Triggering transaction sync",
                zap.String("uid", req.UID),
                zap.String("itemId", req.ItemID),
        )

        // Verify ownership
        itemPath := fmt.Sprintf("plaidItems/%s", req.ItemID)
        itemData, err := s.repo.Get(ctx, itemPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("item not found: %w", err)
        }</span>
        <span class="cov0" title="0">if itemData == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("item not found")
        }</span>

        <span class="cov0" title="0">if itemData["uid"] != req.UID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not authorized to access this item")
        }</span>

        // Get access token
        <span class="cov0" title="0">accessToken, err := s.getAccessToken(ctx, req.ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get current cursor
        <span class="cov0" title="0">var cursor *string
        if cursorVal, ok := itemData["cursor"].(string); ok &amp;&amp; cursorVal != "" </span><span class="cov0" title="0">{
                cursor = &amp;cursorVal
        }</span>

        // Sync transactions
        <span class="cov0" title="0">result, err := s.syncTransactions(ctx, req.ItemID, accessToken, req.UID, cursor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "ok":       true,
                "added":    result["added"],
                "modified": result["modified"],
                "removed":  result["removed"],
        }, nil</span>
}

// HandleWebhook processes Plaid webhook events
func (s *PlaidService) HandleWebhook(ctx context.Context, webhookType string, webhookCode string, itemID string, error_code *string) error <span class="cov0" title="0">{
        s.logger.Info("Processing Plaid webhook",
                zap.String("type", webhookType),
                zap.String("code", webhookCode),
                zap.String("itemId", itemID),
        )

        switch webhookType </span>{
        case "TRANSACTIONS":<span class="cov0" title="0">
                return s.handleTransactionsWebhook(ctx, webhookCode, itemID)</span>
        case "ITEM":<span class="cov0" title="0">
                return s.handleItemWebhook(ctx, webhookCode, itemID, error_code)</span>
        default:<span class="cov0" title="0">
                s.logger.Warn("Unknown webhook type", zap.String("type", webhookType))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleTransactionsWebhook handles transaction-related webhooks
func (s *PlaidService) handleTransactionsWebhook(ctx context.Context, code string, itemID string) error <span class="cov0" title="0">{
        switch code </span>{
        case "SYNC_UPDATES_AVAILABLE":<span class="cov0" title="0">
                // Trigger sync in background
                go func() </span><span class="cov0" title="0">{
                        syncCtx := context.Background()
                        itemPath := fmt.Sprintf("plaidItems/%s", itemID)
                        itemData, err := s.repo.Get(syncCtx, itemPath)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to get item for webhook sync", zap.Error(err))
                                return
                        }</span>
                        <span class="cov0" title="0">if itemData == nil </span><span class="cov0" title="0">{
                                s.logger.Error("Item not found for webhook sync")
                                return
                        }</span>

                        <span class="cov0" title="0">uid, ok := itemData["uid"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                s.logger.Error("Invalid item data - no uid")
                                return
                        }</span>

                        <span class="cov0" title="0">accessToken, err := s.getAccessToken(syncCtx, itemID)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to get access token for webhook sync", zap.Error(err))
                                return
                        }</span>

                        <span class="cov0" title="0">var cursor *string
                        if cursorVal, ok := itemData["cursor"].(string); ok &amp;&amp; cursorVal != "" </span><span class="cov0" title="0">{
                                cursor = &amp;cursorVal
                        }</span>

                        <span class="cov0" title="0">if _, err := s.syncTransactions(syncCtx, itemID, accessToken, uid, cursor); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to sync transactions from webhook", zap.Error(err))
                        }</span>
                }()
        }

        <span class="cov0" title="0">return nil</span>
}

// handleItemWebhook handles item-related webhooks
func (s *PlaidService) handleItemWebhook(ctx context.Context, code string, itemID string, error_code *string) error <span class="cov0" title="0">{
        switch code </span>{
        case "ERROR":<span class="cov0" title="0">
                if error_code != nil </span><span class="cov0" title="0">{
                        return s.updateItemStatus(ctx, itemID, "error:"+*error_code)
                }</span>
                <span class="cov0" title="0">return s.updateItemStatus(ctx, itemID, "error")</span>
        case "PENDING_EXPIRATION":<span class="cov0" title="0">
                return s.updateItemStatus(ctx, itemID, "pending_expiration")</span>
        case "LOGIN_REPAIRED":<span class="cov0" title="0">
                return s.updateItemStatus(ctx, itemID, "ok")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// syncTransactions syncs transactions for an item
func (s *PlaidService) syncTransactions(ctx context.Context, itemID string, accessToken string, uid string, cursor *string) (map[string]interface{}, error) <span class="cov0" title="0">{
        totalAdded := 0
        totalModified := 0
        totalRemoved := 0

        var currentCursor *string = cursor
        hasMore := true

        for hasMore </span><span class="cov0" title="0">{
                result, err := s.plaidClient.SyncTransactions(ctx, clients.SyncTransactionsRequest{
                        AccessToken: accessToken,
                        Cursor:      currentCursor,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Process added transactions
                <span class="cov0" title="0">for _, txn := range result.Added </span><span class="cov0" title="0">{
                        txnPath := fmt.Sprintf("transactions/%s", txn.TransactionID)
                        txnData := map[string]interface{}{
                                "uid":                uid,
                                "itemId":             itemID,
                                "accountId":          txn.AccountID,
                                "plaidTransactionId": txn.TransactionID,
                                "postedAt":           txn.Date,
                                "authorizedAt":       txn.AuthorizedDate,
                                "pending":            txn.Pending,
                                "amount":             txn.Amount,
                                "isoCurrency":        txn.IsoCurrency,
                                "merchant": map[string]interface{}{
                                        "name":       txn.Name,
                                        "normalized": normalizeMerchantName(txn.Name),
                                },
                                "originalDescription": txn.Name,
                                "category_base":       txn.Category,
                                "category_premium":    txn.PersonalFinanceCategory,
                                "confidence":          0.8,
                                "isSubscription":      false,
                                "recurringStreamId":   nil,
                                "ingestedAt":          time.Now(),
                                "updatedAt":           time.Now(),
                                "source":              "plaid",
                        }

                        if txn.MerchantName != nil </span><span class="cov0" title="0">{
                                txnData["merchant"].(map[string]interface{})["name"] = *txn.MerchantName
                                txnData["merchant"].(map[string]interface{})["normalized"] = normalizeMerchantName(*txn.MerchantName)
                        }</span>

                        <span class="cov0" title="0">if err := s.repo.SetDocument(ctx, txnPath, txnData); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to store transaction", zap.Error(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">totalAdded++</span>
                }

                // Process modified transactions
                <span class="cov0" title="0">for _, txn := range result.Modified </span><span class="cov0" title="0">{
                        txnPath := fmt.Sprintf("transactions/%s", txn.TransactionID)
                        updates := map[string]interface{}{
                                "pending":   txn.Pending,
                                "amount":    txn.Amount,
                                "updatedAt": time.Now(),
                        }

                        if err := s.repo.UpdateDocument(ctx, txnPath, updates); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to update transaction", zap.Error(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">totalModified++</span>
                }

                // Process removed transactions
                <span class="cov0" title="0">for _, removed := range result.Removed </span><span class="cov0" title="0">{
                        txnPath := fmt.Sprintf("transactions/%s", removed.TransactionID)
                        if err := s.repo.DeleteDocument(ctx, txnPath); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to delete transaction", zap.Error(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">totalRemoved++</span>
                }

                // Update cursor and check if more data
                <span class="cov0" title="0">currentCursor = &amp;result.NextCursor
                hasMore = result.HasMore</span>
        }

        // Update item with latest cursor and sync time
        <span class="cov0" title="0">itemPath := fmt.Sprintf("plaidItems/%s", itemID)
        if err := s.repo.UpdateDocument(ctx, itemPath, map[string]interface{}{
                "cursor":     *currentCursor,
                "lastSyncAt": time.Now(),
        }); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update item cursor", zap.Error(err))
        }</span>

        <span class="cov0" title="0">s.logger.Info("Transaction sync complete",
                zap.String("itemId", itemID),
                zap.Int("added", totalAdded),
                zap.Int("modified", totalModified),
                zap.Int("removed", totalRemoved),
        )

        return map[string]interface{}{
                "added":    totalAdded,
                "modified": totalModified,
                "removed":  totalRemoved,
        }, nil</span>
}

// getAccessToken retrieves and decrypts the access token for an item
func (s *PlaidService) getAccessToken(ctx context.Context, itemID string) (string, error) <span class="cov0" title="0">{
        itemPath := fmt.Sprintf("plaidItems/%s", itemID)
        itemData, err := s.repo.Get(ctx, itemPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get item: %w", err)
        }</span>
        <span class="cov0" title="0">if itemData == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("item not found")
        }</span>

        <span class="cov0" title="0">encryptedToken, ok := itemData["kmsRef"].(string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no access token found for item")
        }</span>

        // Decrypt access token (simplified - in production, use proper KMS)
        <span class="cov0" title="0">accessToken := s.decryptAccessToken(encryptedToken)

        return accessToken, nil</span>
}

// updateItemStatus updates the status of a Plaid item
func (s *PlaidService) updateItemStatus(ctx context.Context, itemID string, status string) error <span class="cov0" title="0">{
        itemPath := fmt.Sprintf("plaidItems/%s", itemID)
        return s.repo.UpdateDocument(ctx, itemPath, map[string]interface{}{
                "status":    status,
                "updatedAt": firestore.ServerTimestamp,
        })
}</span>

// encryptAccessToken encrypts an access token (simplified)
// In production, use Google Cloud KMS or similar
func (s *PlaidService) encryptAccessToken(accessToken string) string <span class="cov0" title="0">{
        // TODO: Implement proper encryption using Cloud KMS
        // For now, this is a placeholder that just base64 encodes
        // In production, use: github.com/googleapis/google-cloud-go/kms
        return fmt.Sprintf("encrypted:%s", accessToken)
}</span>

// decryptAccessToken decrypts an access token (simplified)
func (s *PlaidService) decryptAccessToken(encryptedToken string) string <span class="cov0" title="0">{
        // TODO: Implement proper decryption using Cloud KMS
        // For now, just strip the prefix
        return strings.TrimPrefix(encryptedToken, "encrypted:")
}</span>

// normalizeMerchantName normalizes a merchant name for matching
func normalizeMerchantName(name string) string <span class="cov0" title="0">{
        // Convert to lowercase
        normalized := strings.ToLower(name)

        // Remove special characters
        normalized = strings.Map(func(r rune) rune </span><span class="cov0" title="0">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == ' ' </span><span class="cov0" title="0">{
                        return r
                }</span>
                <span class="cov0" title="0">return -1</span>
        }, normalized)

        // Trim spaces
        <span class="cov0" title="0">normalized = strings.TrimSpace(normalized)

        // Replace multiple spaces with single space
        for strings.Contains(normalized, "  ") </span><span class="cov0" title="0">{
                normalized = strings.ReplaceAll(normalized, "  ", " ")
        }</span>

        <span class="cov0" title="0">return normalized</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package services

import (
        "context"
        "fmt"
        "math"
        "sort"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// SpendingAnalyticsService handles spending analytics computations
type SpendingAnalyticsService struct {
        repo   interfaces.Repository
        logger *zap.Logger
}

// NewSpendingAnalyticsService creates a new spending analytics service
func NewSpendingAnalyticsService(repo interfaces.Repository, logger *zap.Logger) *SpendingAnalyticsService <span class="cov8" title="1">{
        return &amp;SpendingAnalyticsService{
                repo:   repo,
                logger: logger,
        }
}</span>

// SpendingAnalytics holds the complete spending analytics response
type SpendingAnalytics struct {
        Stats             SpendingStats  `json:"stats"`
        CategoryBreakdown []CategoryItem `json:"categoryBreakdown"`
        AccountBreakdown  []AccountItem  `json:"accountBreakdown"`
        TrendData         []TrendItem    `json:"trendData"`
        TopMerchants      []MerchantItem `json:"topMerchants"`
        DateRange         DateRangeInfo  `json:"dateRange"`
}

// SpendingStats holds overall spending statistics
type SpendingStats struct {
        TotalSpend        float64 `json:"totalSpend"`
        TotalIncome       float64 `json:"totalIncome"`
        AvgDailySpend     float64 `json:"avgDailySpend"`
        SubscriptionSpend float64 `json:"subscriptionSpend"`
        SubscriptionCount int     `json:"subscriptionCount"`
        TransactionCount  int     `json:"transactionCount"`
}

// CategoryItem holds spending by category
type CategoryItem struct {
        Name  string  `json:"name"`
        Value float64 `json:"value"`
}

// AccountItem holds spending by account
type AccountItem struct {
        Name  string  `json:"name"`
        Value float64 `json:"value"`
}

// TrendItem holds daily spending trend
type TrendItem struct {
        Date   string  `json:"date"`
        Spend  float64 `json:"spend"`
        Income float64 `json:"income"`
}

// MerchantItem holds spending by merchant
type MerchantItem struct {
        Name  string  `json:"name"`
        Value float64 `json:"value"`
}

// DateRangeInfo holds date range information
type DateRangeInfo struct {
        Start string `json:"start"`
        End   string `json:"end"`
        Days  int    `json:"days"`
}

// ComputeSpendingAnalytics computes spending analytics for a user
func (s *SpendingAnalyticsService) ComputeSpendingAnalytics(ctx context.Context, uid string, startDate, endDate string, accountIDs []string) (*SpendingAnalytics, error) <span class="cov0" title="0">{
        s.logger.Debug("Computing spending analytics",
                zap.String("uid", uid),
                zap.String("startDate", startDate),
                zap.String("endDate", endDate),
                zap.Int("accountCount", len(accountIDs)),
        )

        // Parse dates
        start, err := time.Parse("2006-01-02", startDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid start date: %w", err)
        }</span>
        <span class="cov0" title="0">end, err := time.Parse("2006-01-02", endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid end date: %w", err)
        }</span>

        // Fetch transactions
        <span class="cov0" title="0">transactions, err := s.fetchTransactions(ctx, uid, start, end, accountIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Fetched transactions",
                zap.Int("count", len(transactions)),
        )

        // Calculate days in range
        days := int(math.Round(end.Sub(start).Hours()/24)) + 1

        // Compute analytics
        analytics := &amp;SpendingAnalytics{
                DateRange: DateRangeInfo{
                        Start: startDate,
                        End:   endDate,
                        Days:  days,
                },
        }

        // Compute stats
        analytics.Stats = s.computeStats(transactions, days)

        // Compute category breakdown
        analytics.CategoryBreakdown = s.computeCategoryBreakdown(transactions)

        // Compute account breakdown
        analytics.AccountBreakdown = s.computeAccountBreakdown(transactions)

        // Compute trend data
        analytics.TrendData = s.computeTrendData(transactions)

        // Compute top merchants
        analytics.TopMerchants = s.computeTopMerchants(transactions)

        s.logger.Info("Spending analytics computed",
                zap.String("uid", uid),
                zap.Int("transactions", analytics.Stats.TransactionCount),
                zap.Float64("totalSpend", analytics.Stats.TotalSpend),
        )

        return analytics, nil</span>
}

// fetchTransactions fetches transactions for a user in date range
func (s *SpendingAnalyticsService) fetchTransactions(ctx context.Context, uid string, startDate, endDate time.Time, accountIDs []string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        collectionPath := fmt.Sprintf("users/%s/transactions", uid)
        allTransactions, err := s.repo.List(ctx, collectionPath, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter by date range and account IDs client-side
        <span class="cov0" title="0">var transactions []map[string]interface{}
        startDateStr := startDate.Format("2006-01-02")
        endDateStr := endDate.Format("2006-01-02")

        for _, txn := range allTransactions </span><span class="cov0" title="0">{
                // Filter by date range
                if postedAt, ok := txn["postedAt"].(string); ok </span><span class="cov0" title="0">{
                        if postedAt &lt; startDateStr || postedAt &gt; endDateStr </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Filter by account IDs if provided
                <span class="cov0" title="0">if len(accountIDs) &gt; 0 </span><span class="cov0" title="0">{
                        accountID, ok := txn["accountId"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">found := false
                        for _, id := range accountIDs </span><span class="cov0" title="0">{
                                if accountID == id </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">transactions = append(transactions, txn)</span>
        }

        <span class="cov0" title="0">return transactions, nil</span>
}

// computeStats computes overall spending statistics
func (s *SpendingAnalyticsService) computeStats(transactions []map[string]interface{}, days int) SpendingStats <span class="cov0" title="0">{
        stats := SpendingStats{
                TransactionCount: len(transactions),
        }

        for _, txn := range transactions </span><span class="cov0" title="0">{
                // Get signedAmount (positive = spend, negative = income)
                signedAmount := s.getFloatField(txn, "signedAmount")
                if signedAmount == 0 </span><span class="cov0" title="0">{
                        // Fallback to amount field if signedAmount not present
                        amount := s.getFloatField(txn, "amount")
                        isIncome := s.getBoolField(txn, "isIncome")
                        if isIncome </span><span class="cov0" title="0">{
                                signedAmount = -amount
                        }</span> else<span class="cov0" title="0"> {
                                signedAmount = amount
                        }</span>
                }

                <span class="cov0" title="0">if signedAmount &gt;= 0 </span><span class="cov0" title="0">{
                        // Spending
                        stats.TotalSpend += signedAmount

                        // Check if subscription
                        if s.getBoolField(txn, "subscription") || s.getBoolField(txn, "isSubscription") </span><span class="cov0" title="0">{
                                stats.SubscriptionSpend += signedAmount
                                stats.SubscriptionCount++
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Income
                        stats.TotalIncome += math.Abs(signedAmount)
                }</span>
        }

        // Calculate average daily spend
        <span class="cov0" title="0">if days &gt; 0 </span><span class="cov0" title="0">{
                stats.AvgDailySpend = stats.TotalSpend / float64(days)
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// computeCategoryBreakdown computes spending by category
func (s *SpendingAnalyticsService) computeCategoryBreakdown(transactions []map[string]interface{}) []CategoryItem <span class="cov0" title="0">{
        totals := make(map[string]float64)

        for _, txn := range transactions </span><span class="cov0" title="0">{
                signedAmount := s.getSignedAmount(txn)
                if signedAmount &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span> // Skip income
                }

                <span class="cov0" title="0">category := s.getStringField(txn, "category")
                if category == "" </span><span class="cov0" title="0">{
                        // Try category_base (array)
                        if catBase, ok := txn["category_base"].([]interface{}); ok &amp;&amp; len(catBase) &gt; 0 </span><span class="cov0" title="0">{
                                if cat, ok := catBase[0].(string); ok </span><span class="cov0" title="0">{
                                        category = cat
                                }</span>
                        }
                }
                <span class="cov0" title="0">if category == "" </span><span class="cov0" title="0">{
                        category = "Uncategorized"
                }</span>

                <span class="cov0" title="0">totals[category] += signedAmount</span>
        }

        // Convert to slice and sort
        <span class="cov0" title="0">items := make([]CategoryItem, 0, len(totals))
        for name, value := range totals </span><span class="cov0" title="0">{
                items = append(items, CategoryItem{
                        Name:  name,
                        Value: value,
                })
        }</span>

        <span class="cov0" title="0">sort.Slice(items, func(i, j int) bool </span><span class="cov0" title="0">{
                return items[i].Value &gt; items[j].Value
        }</span>)

        // Return top 8
        <span class="cov0" title="0">if len(items) &gt; 8 </span><span class="cov0" title="0">{
                items = items[:8]
        }</span>

        <span class="cov0" title="0">return items</span>
}

// computeAccountBreakdown computes spending by account
func (s *SpendingAnalyticsService) computeAccountBreakdown(transactions []map[string]interface{}) []AccountItem <span class="cov0" title="0">{
        totals := make(map[string]float64)

        for _, txn := range transactions </span><span class="cov0" title="0">{
                signedAmount := s.getSignedAmount(txn)
                if signedAmount &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span> // Skip income
                }

                <span class="cov0" title="0">accountName := s.getStringField(txn, "accountName")
                if accountName == "" </span><span class="cov0" title="0">{
                        accountName = "Unknown Account"
                }</span>

                <span class="cov0" title="0">totals[accountName] += signedAmount</span>
        }

        // Convert to slice and sort
        <span class="cov0" title="0">items := make([]AccountItem, 0, len(totals))
        for name, value := range totals </span><span class="cov0" title="0">{
                items = append(items, AccountItem{
                        Name:  name,
                        Value: value,
                })
        }</span>

        <span class="cov0" title="0">sort.Slice(items, func(i, j int) bool </span><span class="cov0" title="0">{
                return items[i].Value &gt; items[j].Value
        }</span>)

        <span class="cov0" title="0">return items</span>
}

// computeTrendData computes daily spending trend
func (s *SpendingAnalyticsService) computeTrendData(transactions []map[string]interface{}) []TrendItem <span class="cov0" title="0">{
        daily := make(map[string]*TrendItem)

        for _, txn := range transactions </span><span class="cov0" title="0">{
                // Get date (postedAt field)
                date := s.getStringField(txn, "postedAt")
                if date == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if daily[date] == nil </span><span class="cov0" title="0">{
                        daily[date] = &amp;TrendItem{
                                Date:   date,
                                Spend:  0,
                                Income: 0,
                        }
                }</span>

                <span class="cov0" title="0">signedAmount := s.getSignedAmount(txn)
                if signedAmount &gt;= 0 </span><span class="cov0" title="0">{
                        daily[date].Spend += signedAmount
                }</span> else<span class="cov0" title="0"> {
                        daily[date].Income += math.Abs(signedAmount)
                }</span>
        }

        // Convert to slice and sort by date
        <span class="cov0" title="0">items := make([]TrendItem, 0, len(daily))
        for _, item := range daily </span><span class="cov0" title="0">{
                // Round values
                item.Spend = math.Round(item.Spend)
                item.Income = math.Round(item.Income)
                items = append(items, *item)
        }</span>

        <span class="cov0" title="0">sort.Slice(items, func(i, j int) bool </span><span class="cov0" title="0">{
                return items[i].Date &lt; items[j].Date
        }</span>)

        <span class="cov0" title="0">return items</span>
}

// computeTopMerchants computes top merchants by spending
func (s *SpendingAnalyticsService) computeTopMerchants(transactions []map[string]interface{}) []MerchantItem <span class="cov0" title="0">{
        totals := make(map[string]float64)

        for _, txn := range transactions </span><span class="cov0" title="0">{
                signedAmount := s.getSignedAmount(txn)
                if signedAmount &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span> // Skip income
                }

                <span class="cov0" title="0">merchant := s.getMerchantName(txn)
                if merchant == "" </span><span class="cov0" title="0">{
                        merchant = "Unknown"
                }</span>

                <span class="cov0" title="0">totals[merchant] += signedAmount</span>
        }

        // Convert to slice and sort
        <span class="cov0" title="0">items := make([]MerchantItem, 0, len(totals))
        for name, value := range totals </span><span class="cov0" title="0">{
                items = append(items, MerchantItem{
                        Name:  name,
                        Value: value,
                })
        }</span>

        <span class="cov0" title="0">sort.Slice(items, func(i, j int) bool </span><span class="cov0" title="0">{
                return items[i].Value &gt; items[j].Value
        }</span>)

        // Return top 5
        <span class="cov0" title="0">if len(items) &gt; 5 </span><span class="cov0" title="0">{
                items = items[:5]
        }</span>

        <span class="cov0" title="0">return items</span>
}

// Helper functions

func (s *SpendingAnalyticsService) getSignedAmount(txn map[string]interface{}) float64 <span class="cov0" title="0">{
        // Try signedAmount first
        if signedAmount := s.getFloatField(txn, "signedAmount"); signedAmount != 0 </span><span class="cov0" title="0">{
                return signedAmount
        }</span>

        // Fallback to amount + isIncome
        <span class="cov0" title="0">amount := s.getFloatField(txn, "amount")
        isIncome := s.getBoolField(txn, "isIncome")
        if isIncome </span><span class="cov0" title="0">{
                return -amount
        }</span>
        <span class="cov0" title="0">return amount</span>
}

func (s *SpendingAnalyticsService) getMerchantName(txn map[string]interface{}) string <span class="cov0" title="0">{
        // Try merchant.name first (object)
        if merchant, ok := txn["merchant"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if name, ok := merchant["name"].(string); ok &amp;&amp; name != "" </span><span class="cov0" title="0">{
                        return name
                }</span>
        }

        // Try merchant as string
        <span class="cov0" title="0">if merchant, ok := txn["merchant"].(string); ok &amp;&amp; merchant != "" </span><span class="cov0" title="0">{
                return merchant
        }</span>

        // Try merchantName field
        <span class="cov0" title="0">if merchantName, ok := txn["merchantName"].(string); ok &amp;&amp; merchantName != "" </span><span class="cov0" title="0">{
                return merchantName
        }</span>

        // Try originalDescription
        <span class="cov0" title="0">if desc, ok := txn["originalDescription"].(string); ok &amp;&amp; desc != "" </span><span class="cov0" title="0">{
                return desc
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func (s *SpendingAnalyticsService) getFloatField(txn map[string]interface{}, field string) float64 <span class="cov0" title="0">{
        if val, ok := txn[field].(float64); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">if val, ok := txn[field].(int64); ok </span><span class="cov0" title="0">{
                return float64(val)
        }</span>
        <span class="cov0" title="0">if val, ok := txn[field].(int); ok </span><span class="cov0" title="0">{
                return float64(val)
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (s *SpendingAnalyticsService) getStringField(txn map[string]interface{}, field string) string <span class="cov0" title="0">{
        if val, ok := txn[field].(string); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (s *SpendingAnalyticsService) getBoolField(txn map[string]interface{}, field string) bool <span class="cov0" title="0">{
        if val, ok := txn[field].(bool); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package services

import (
        "context"
        "fmt"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository/interfaces"
)

// StockService handles stock-related operations
type StockService struct {
        repo               interfaces.Repository
        alphaVantageClient *clients.AlphaVantageClient
        logger             *zap.Logger
}

// NewStockService creates a new stock service
func NewStockService(
        repo interfaces.Repository,
        alphaVantageClient *clients.AlphaVantageClient,
        logger *zap.Logger,
) *StockService <span class="cov8" title="1">{
        return &amp;StockService{
                repo:               repo,
                alphaVantageClient: alphaVantageClient,
                logger:             logger,
        }
}</span>

// GetStockPrice fetches the current stock price
// First checks Firestore cache (marketData/latestPrices), then falls back to Alpha Vantage
func (s *StockService) GetStockPrice(ctx context.Context, userID, ticker string) (*clients.StockQuote, error) <span class="cov8" title="1">{
        s.logger.Info("Fetching stock price",
                zap.String("uid", userID),
                zap.String("ticker", ticker),
        )

        // Try to get from Firestore cache first
        cachedQuote, err := s.getQuoteFromCache(ctx, ticker)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get quote from cache, falling back to API",
                        zap.String("ticker", ticker),
                        zap.Error(err),
                )
        }</span> else<span class="cov8" title="1"> if cachedQuote != nil </span><span class="cov0" title="0">{
                s.logger.Info("Returning cached quote",
                        zap.String("ticker", ticker),
                        zap.Float64("price", cachedQuote.Price),
                )
                return cachedQuote, nil
        }</span>

        // Fall back to Alpha Vantage API
        <span class="cov8" title="1">if s.alphaVantageClient == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Alpha Vantage client not configured")
        }</span>

        <span class="cov0" title="0">quote, err := s.alphaVantageClient.GetQuote(ctx, ticker)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch quote from Alpha Vantage: %w", err)
        }</span>

        <span class="cov0" title="0">return quote, nil</span>
}

// GetStockHistory fetches historical stock data
func (s *StockService) GetStockHistory(ctx context.Context, userID, ticker string, days int) (*clients.StockHistory, error) <span class="cov8" title="1">{
        s.logger.Info("Fetching stock history",
                zap.String("uid", userID),
                zap.String("ticker", ticker),
                zap.Int("days", days),
        )

        if s.alphaVantageClient == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Alpha Vantage client not configured")
        }</span>

        // Fetch from Alpha Vantage
        <span class="cov0" title="0">history, err := s.alphaVantageClient.GetHistoricalData(ctx, ticker, days)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch historical data: %w", err)
        }</span>

        <span class="cov0" title="0">return history, nil</span>
}

// getQuoteFromCache retrieves a cached quote from Firestore
func (s *StockService) getQuoteFromCache(ctx context.Context, ticker string) (*clients.StockQuote, error) <span class="cov8" title="1">{
        // Get the latest prices document
        path := "marketData/latestPrices"
        data, err := s.repo.Get(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if data == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Extract tickers map
        <span class="cov0" title="0">tickersData, ok := data["tickers"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Get the specific ticker data
        <span class="cov0" title="0">tickerData, ok := tickersData[ticker].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Parse the quote
        <span class="cov0" title="0">quote, err := s.parseTickerData(ticker, tickerData, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return quote, nil</span>
}

// parseTickerData parses ticker data from Firestore
func (s *StockService) parseTickerData(ticker string, tickerData, parentData map[string]interface{}) (*clients.StockQuote, error) <span class="cov0" title="0">{
        // Extract price (required)
        price, ok := tickerData["price"].(float64)
        if !ok </span><span class="cov0" title="0">{
                priceInt, okInt := tickerData["price"].(int64)
                if !okInt </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid or missing price for ticker %s", ticker)
                }</span>
                <span class="cov0" title="0">price = float64(priceInt)</span>
        }

        // Extract change (optional)
        <span class="cov0" title="0">change, _ := tickerData["change"].(float64)
        if change == 0 </span><span class="cov0" title="0">{
                changeInt, _ := tickerData["change"].(int64)
                change = float64(changeInt)
        }</span>

        // Extract changePercent (optional)
        <span class="cov0" title="0">changePercent, _ := tickerData["changePercent"].(float64)
        if changePercent == 0 </span><span class="cov0" title="0">{
                changePercentInt, _ := tickerData["changePercent"].(int64)
                changePercent = float64(changePercentInt)
        }</span>

        // Extract timestamp
        <span class="cov0" title="0">timestamp, tsOk := tickerData["timestamp"].(string)
        if !tsOk </span><span class="cov0" title="0">{
                fetchedAt, faOk := tickerData["fetchedAt"].(string)
                if !faOk </span><span class="cov0" title="0">{
                        refreshedAt, raOk := parentData["refreshedAt"].(string)
                        if raOk </span><span class="cov0" title="0">{
                                timestamp = refreshedAt
                        }</span>
                } else<span class="cov0" title="0"> {
                        timestamp = fetchedAt
                }</span>
        }

        // Extract source
        <span class="cov0" title="0">source, ok := tickerData["source"].(string)
        if !ok </span><span class="cov0" title="0">{
                source, ok = parentData["source"].(string)
                if !ok </span><span class="cov0" title="0">{
                        source = "Cached Market Data"
                }</span>
        }

        <span class="cov0" title="0">return &amp;clients.StockQuote{
                Symbol:        ticker,
                Price:         price,
                Change:        change,
                ChangePercent: changePercent,
                Timestamp:     timestamp,
                Source:        source,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/stripe/stripe-go/v76"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository"
)

const (
        StripeCustomersCollection = "stripeCustomers"
        SubscriptionStatusDoc     = "current"
)

// StripeBillingService handles Stripe billing operations
type StripeBillingService struct {
        stripeClient *clients.StripeClient
        repo         *repository.FirestoreRepository
        logger       *zap.Logger
}

// NewStripeBillingService creates a new Stripe billing service
func NewStripeBillingService(
        stripeClient *clients.StripeClient,
        repo *repository.FirestoreRepository,
        logger *zap.Logger,
) *StripeBillingService <span class="cov0" title="0">{
        return &amp;StripeBillingService{
                stripeClient: stripeClient,
                repo:         repo,
                logger:       logger,
        }
}</span>

// CreateCheckoutSession creates a Stripe checkout session for a user
func (s *StripeBillingService) CreateCheckoutSession(ctx context.Context, uid string, userEmail string, successURL, cancelURL string) (string, error) <span class="cov0" title="0">{
        s.logger.Info("Creating checkout session",
                zap.String("uid", uid),
                zap.String("email", userEmail),
        )

        // Create Stripe checkout session
        session, err := s.stripeClient.CreateCheckoutSession(userEmail, successURL, cancelURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create checkout session: %w", err)
        }</span>

        // Store session metadata
        // This helps track checkout sessions for debugging
        <span class="cov0" title="0">sessionData := map[string]interface{}{
                "uid":       uid,
                "sessionId": session.ID,
                "email":     userEmail,
                "status":    "pending",
                "createdAt": time.Now(),
                "expiresAt": time.Unix(session.ExpiresAt, 0),
        }

        sessionPath := fmt.Sprintf("users/%s/checkoutSessions/%s", uid, session.ID)
        err = s.repo.CreateDocument(ctx, sessionPath, sessionData)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to store checkout session", zap.Error(err))
                // Don't fail the request if we can't store metadata
        }</span>

        <span class="cov0" title="0">return session.URL, nil</span>
}

// CreatePortalSession creates a Stripe billing portal session
func (s *StripeBillingService) CreatePortalSession(ctx context.Context, uid string, returnURL string) (string, error) <span class="cov0" title="0">{
        s.logger.Info("Creating portal session", zap.String("uid", uid))

        // Get customer ID from Firestore
        customerID, err := s.getStripeCustomerID(ctx, uid)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get customer ID: %w", err)
        }</span>

        <span class="cov0" title="0">if customerID == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no Stripe customer found for user")
        }</span>

        // Create portal session
        <span class="cov0" title="0">session, err := s.stripeClient.CreatePortalSession(customerID, returnURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create portal session: %w", err)
        }</span>

        <span class="cov0" title="0">return session.URL, nil</span>
}

// HandleWebhookEvent processes Stripe webhook events
func (s *StripeBillingService) HandleWebhookEvent(ctx context.Context, event stripe.Event) error <span class="cov0" title="0">{
        s.logger.Info("Processing webhook event",
                zap.String("type", string(event.Type)),
                zap.String("eventId", event.ID),
        )

        switch event.Type </span>{
        case "customer.subscription.created":<span class="cov0" title="0">
                return s.handleSubscriptionCreated(ctx, event)</span>
        case "customer.subscription.updated":<span class="cov0" title="0">
                return s.handleSubscriptionUpdated(ctx, event)</span>
        case "customer.subscription.deleted":<span class="cov0" title="0">
                return s.handleSubscriptionDeleted(ctx, event)</span>
        case "checkout.session.completed":<span class="cov0" title="0">
                return s.handleCheckoutCompleted(ctx, event)</span>
        case "invoice.paid":<span class="cov0" title="0">
                return s.handleInvoicePaid(ctx, event)</span>
        case "invoice.payment_failed":<span class="cov0" title="0">
                return s.handleInvoicePaymentFailed(ctx, event)</span>
        default:<span class="cov0" title="0">
                s.logger.Debug("Unhandled webhook event type", zap.String("type", string(event.Type)))
                return nil</span>
        }
}

// handleSubscriptionCreated handles subscription.created event
func (s *StripeBillingService) handleSubscriptionCreated(ctx context.Context, event stripe.Event) error <span class="cov0" title="0">{
        var subscription stripe.Subscription
        if err := json.Unmarshal(event.Data.Raw, &amp;subscription); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return s.syncSubscriptionToFirestore(ctx, &amp;subscription)</span>
}

// handleSubscriptionUpdated handles subscription.updated event
func (s *StripeBillingService) handleSubscriptionUpdated(ctx context.Context, event stripe.Event) error <span class="cov0" title="0">{
        var subscription stripe.Subscription
        if err := json.Unmarshal(event.Data.Raw, &amp;subscription); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse subscription: %w", err)
        }</span>

        <span class="cov0" title="0">return s.syncSubscriptionToFirestore(ctx, &amp;subscription)</span>
}

// handleSubscriptionDeleted handles subscription.deleted event
func (s *StripeBillingService) handleSubscriptionDeleted(ctx context.Context, event stripe.Event) error <span class="cov0" title="0">{
        var subscription stripe.Subscription
        if err := json.Unmarshal(event.Data.Raw, &amp;subscription); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse subscription: %w", err)
        }</span>

        // Mark subscription as canceled in Firestore
        <span class="cov0" title="0">uid, err := s.getUIDFromCustomerID(ctx, getCustomerID(&amp;subscription))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get UID: %w", err)
        }</span>

        <span class="cov0" title="0">if uid == "" </span><span class="cov0" title="0">{
                s.logger.Warn("No UID found for customer", zap.String("customerId", getCustomerID(&amp;subscription)))
                return nil
        }</span>

        <span class="cov0" title="0">statusPath := fmt.Sprintf("users/%s/subscriptionStatus/%s", uid, SubscriptionStatusDoc)
        updates := map[string]interface{}{
                "status": "canceled",
                "tier":   "free",
                "entitlements": map[string]interface{}{
                        "aiProcessing": false,
                },
                "canceledAt": time.Now(),
        }

        return s.repo.UpdateDocument(ctx, statusPath, updates)</span>
}

// handleCheckoutCompleted handles checkout.session.completed event
func (s *StripeBillingService) handleCheckoutCompleted(ctx context.Context, event stripe.Event) error <span class="cov0" title="0">{
        var session stripe.CheckoutSession
        if err := json.Unmarshal(event.Data.Raw, &amp;session); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse checkout session: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Checkout completed",
                zap.String("sessionId", session.ID),
                zap.String("customerId", session.Customer.ID),
        )

        // Record customer mapping
        if session.Customer != nil &amp;&amp; session.Metadata != nil </span><span class="cov0" title="0">{
                if uid, ok := session.Metadata["uid"]; ok </span><span class="cov0" title="0">{
                        err := s.recordCustomerMapping(ctx, session.Customer.ID, uid)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to record customer mapping", zap.Error(err))
                        }</span>
                }
        }

        // If there's a subscription, sync it
        <span class="cov0" title="0">if session.Subscription != nil </span><span class="cov0" title="0">{
                subscriptionID := getSubscriptionIDFromSession(&amp;session)
                subscription, err := s.stripeClient.GetSubscription(subscriptionID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get subscription: %w", err)
                }</span>

                <span class="cov0" title="0">return s.syncSubscriptionToFirestore(ctx, subscription)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleInvoicePaid handles invoice.paid event
func (s *StripeBillingService) handleInvoicePaid(ctx context.Context, event stripe.Event) error <span class="cov0" title="0">{
        var invoice stripe.Invoice
        if err := json.Unmarshal(event.Data.Raw, &amp;invoice); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse invoice: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Invoice paid",
                zap.String("invoiceId", invoice.ID),
                zap.String("customerId", invoice.Customer.ID),
                zap.Int64("amount", invoice.AmountPaid),
        )

        // If invoice has a subscription, sync it
        if invoice.Subscription != nil </span><span class="cov0" title="0">{
                subscriptionID := invoice.Subscription.ID
                subscription, err := s.stripeClient.GetSubscription(subscriptionID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get subscription: %w", err)
                }</span>

                <span class="cov0" title="0">return s.syncSubscriptionToFirestore(ctx, subscription)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleInvoicePaymentFailed handles invoice.payment_failed event
func (s *StripeBillingService) handleInvoicePaymentFailed(ctx context.Context, event stripe.Event) error <span class="cov0" title="0">{
        var invoice stripe.Invoice
        if err := json.Unmarshal(event.Data.Raw, &amp;invoice); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse invoice: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Warn("Invoice payment failed",
                zap.String("invoiceId", invoice.ID),
                zap.String("customerId", invoice.Customer.ID),
        )

        // Update subscription status to past_due if needed
        if invoice.Subscription != nil </span><span class="cov0" title="0">{
                subscriptionID := invoice.Subscription.ID
                subscription, err := s.stripeClient.GetSubscription(subscriptionID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get subscription: %w", err)
                }</span>

                <span class="cov0" title="0">return s.syncSubscriptionToFirestore(ctx, subscription)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// syncSubscriptionToFirestore syncs a Stripe subscription to Firestore
func (s *StripeBillingService) syncSubscriptionToFirestore(ctx context.Context, subscription *stripe.Subscription) error <span class="cov0" title="0">{
        customerID := getCustomerID(subscription)

        // Get UID from customer ID
        uid, err := s.getUIDFromCustomerID(ctx, customerID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get UID: %w", err)
        }</span>

        <span class="cov0" title="0">if uid == "" </span><span class="cov0" title="0">{
                s.logger.Warn("No UID found for customer", zap.String("customerId", customerID))
                return nil
        }</span>

        // Map subscription to status
        <span class="cov0" title="0">status := mapSubscriptionToStatus(subscription)

        // Update subscription status in Firestore
        statusPath := fmt.Sprintf("users/%s/subscriptionStatus/%s", uid, SubscriptionStatusDoc)
        err = s.repo.SetDocument(ctx, statusPath, status)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update subscription status: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Subscription synced to Firestore",
                zap.String("uid", uid),
                zap.String("subscriptionId", subscription.ID),
                zap.String("status", string(subscription.Status)),
        )

        return nil</span>
}

// Helper functions

func (s *StripeBillingService) getStripeCustomerID(ctx context.Context, uid string) (string, error) <span class="cov0" title="0">{
        statusPath := fmt.Sprintf("users/%s/subscriptionStatus/%s", uid, SubscriptionStatusDoc)
        doc, err := s.repo.GetDocument(ctx, statusPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var status models.SubscriptionStatus
        if err := doc.DataTo(&amp;status); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if status.StripeCustomerID == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return *status.StripeCustomerID, nil</span>
}

func (s *StripeBillingService) getUIDFromCustomerID(ctx context.Context, customerID string) (string, error) <span class="cov0" title="0">{
        if customerID == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Query stripe customers collection
        <span class="cov0" title="0">customerPath := fmt.Sprintf("%s/%s", StripeCustomersCollection, customerID)
        doc, err := s.repo.GetDocument(ctx, customerPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil // Not found is ok
        }</span>

        <span class="cov0" title="0">var data map[string]interface{}
        if err := doc.DataTo(&amp;data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if uid, ok := data["uid"].(string); ok </span><span class="cov0" title="0">{
                return uid, nil
        }</span>

        <span class="cov0" title="0">return "", nil</span>
}

func (s *StripeBillingService) recordCustomerMapping(ctx context.Context, customerID, uid string) error <span class="cov0" title="0">{
        if customerID == "" || uid == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">customerPath := fmt.Sprintf("%s/%s", StripeCustomersCollection, customerID)
        data := map[string]interface{}{
                "uid":       uid,
                "updatedAt": time.Now(),
        }

        return s.repo.SetDocument(ctx, customerPath, data)</span>
}

// Helper functions for extracting IDs

func getCustomerID(subscription *stripe.Subscription) string <span class="cov0" title="0">{
        if subscription.Customer == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return subscription.Customer.ID</span>
}

func getSubscriptionIDFromSession(session *stripe.CheckoutSession) string <span class="cov0" title="0">{
        if session.Subscription == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return session.Subscription.ID</span>
}

// mapSubscriptionToStatus converts Stripe subscription to Firestore status
func mapSubscriptionToStatus(subscription *stripe.Subscription) map[string]interface{} <span class="cov0" title="0">{
        customerID := getCustomerID(subscription)
        priceID := ""
        if len(subscription.Items.Data) &gt; 0 </span><span class="cov0" title="0">{
                priceID = subscription.Items.Data[0].Price.ID
        }</span>

        // Determine tier based on status
        <span class="cov0" title="0">tier := "free"
        aiAllowed := false
        activeStatuses := []stripe.SubscriptionStatus{
                stripe.SubscriptionStatusActive,
                stripe.SubscriptionStatusTrialing,
                stripe.SubscriptionStatusPastDue,
        }

        for _, status := range activeStatuses </span><span class="cov0" title="0">{
                if subscription.Status == status </span><span class="cov0" title="0">{
                        tier = "pro"
                        aiAllowed = true
                        break</span>
                }
        }

        <span class="cov0" title="0">status := map[string]interface{}{
                "tier":                 tier,
                "status":               string(subscription.Status),
                "stripeCustomerId":     customerID,
                "stripeSubscriptionId": subscription.ID,
                "priceId":              priceID,
                "currentPeriodEnd":     time.Unix(subscription.CurrentPeriodEnd, 0),
                "currentPeriodStart":   time.Unix(subscription.CurrentPeriodStart, 0),
                "cancelAtPeriodEnd":    subscription.CancelAtPeriodEnd,
                "updatedAt":            time.Now(),
        }

        if subscription.CancelAt &gt; 0 </span><span class="cov0" title="0">{
                status["cancelAt"] = time.Unix(subscription.CancelAt, 0)
        }</span>

        <span class="cov0" title="0">if subscription.TrialEnd &gt; 0 </span><span class="cov0" title="0">{
                status["trialEndsAt"] = time.Unix(subscription.TrialEnd, 0)
        }</span>

        // Set entitlements
        <span class="cov0" title="0">status["entitlements"] = map[string]interface{}{
                "aiProcessing":       aiAllowed,
                "aiCreditsRemaining": nil,
                "aiCreditsResetsAt":  time.Unix(subscription.CurrentPeriodEnd, 0),
        }

        return status</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "cloud.google.com/go/firestore"
        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository"
)

const (
        AnonymousSessionCollection = "anonymousSessions"
        // Note: SubscriptionStatusDoc is defined in stripe_billing.go
)

// SubscriptionService handles subscription and AI entitlement checks
type SubscriptionService struct {
        repo        *repository.FirestoreRepository
        logger      *zap.Logger
        overrideKey string
        cache       map[string]*cachedSubscription
}

type cachedSubscription struct {
        status    *models.SubscriptionStatus
        expiresAt time.Time
}

// NewSubscriptionService creates a new subscription service
func NewSubscriptionService(repo *repository.FirestoreRepository, logger *zap.Logger, overrideKey string) *SubscriptionService <span class="cov8" title="1">{
        return &amp;SubscriptionService{
                repo:        repo,
                logger:      logger,
                overrideKey: overrideKey,
                cache:       make(map[string]*cachedSubscription),
        }
}</span>

// IsAIAllowed checks if the user has AI access
// Returns (allowed bool, entitlement info, error)
func (s *SubscriptionService) IsAIAllowed(ctx context.Context, uid string, isAnonymous bool) (bool, string, error) <span class="cov0" title="0">{
        // Anonymous users need special check
        if isAnonymous </span><span class="cov0" title="0">{
                return s.checkAnonymousAIAccess(ctx, uid)
        }</span>

        // Regular users: check subscription
        <span class="cov0" title="0">return s.checkSubscriptionAIAccess(ctx, uid)</span>
}

// checkAnonymousAIAccess checks if anonymous user has AI access
func (s *SubscriptionService) checkAnonymousAIAccess(ctx context.Context, uid string) (bool, string, error) <span class="cov0" title="0">{
        sessionPath := fmt.Sprintf("%s/%s", AnonymousSessionCollection, uid)
        doc, err := s.repo.GetDocument(ctx, sessionPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, "Anonymous session not found", nil
        }</span>

        <span class="cov0" title="0">var session models.AnonymousSession
        if err := doc.DataTo(&amp;session); err != nil </span><span class="cov0" title="0">{
                return false, "Failed to read session", err
        }</span>

        // Check allowAi flag
        <span class="cov0" title="0">if !session.AllowAi </span><span class="cov0" title="0">{
                // Check override key
                if s.overrideKey != "" &amp;&amp; session.CiOverrideKey != nil &amp;&amp; *session.CiOverrideKey == s.overrideKey </span><span class="cov0" title="0">{
                        s.logger.Debug("Anonymous AI access granted via override key", zap.String("uid", uid))
                        return true, "Override key matched", nil
                }</span>
                <span class="cov0" title="0">return false, "AI not enabled for anonymous session", nil</span>
        }

        // Check cleanup pending
        <span class="cov0" title="0">if session.CleanupPending </span><span class="cov0" title="0">{
                return false, "Session cleanup pending", nil
        }</span>

        // Check expiry
        <span class="cov0" title="0">if session.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                // Mark as expired
                err := s.repo.SetDocument(ctx, sessionPath, map[string]interface{}{
                        "status":         "expired",
                        "cleanupPending": true,
                        "expiredAt":      time.Now(),
                })
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to mark session as expired", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return false, "Session expired", nil</span>
        }

        <span class="cov0" title="0">return true, "Anonymous session active", nil</span>
}

// checkSubscriptionAIAccess checks if regular user has AI access
func (s *SubscriptionService) checkSubscriptionAIAccess(ctx context.Context, uid string) (bool, string, error) <span class="cov0" title="0">{
        // Check cache first
        if cached, ok := s.cache[uid]; ok </span><span class="cov0" title="0">{
                if time.Now().Before(cached.expiresAt) </span><span class="cov0" title="0">{
                        return s.evaluateSubscription(cached.status)
                }</span>
        }

        // Fetch from Firestore
        <span class="cov0" title="0">statusPath := fmt.Sprintf("users/%s/subscriptionStatus/%s", uid, SubscriptionStatusDoc)
        doc, err := s.repo.GetDocument(ctx, statusPath)
        if err != nil </span><span class="cov0" title="0">{
                // No subscription found - treat as free tier
                s.logger.Debug("No subscription found", zap.String("uid", uid))
                return false, "Pro subscription required", nil
        }</span>

        <span class="cov0" title="0">var status models.SubscriptionStatus
        if err := doc.DataTo(&amp;status); err != nil </span><span class="cov0" title="0">{
                return false, "Failed to read subscription", err
        }</span>

        // Cache for 1 minute
        <span class="cov0" title="0">s.cache[uid] = &amp;cachedSubscription{
                status:    &amp;status,
                expiresAt: time.Now().Add(1 * time.Minute),
        }

        return s.evaluateSubscription(&amp;status)</span>
}

// evaluateSubscription evaluates subscription status for AI access
func (s *SubscriptionService) evaluateSubscription(status *models.SubscriptionStatus) (bool, string, error) <span class="cov0" title="0">{
        // Check tier
        if status.Tier != "pro" </span><span class="cov0" title="0">{
                return false, "Pro subscription required", nil
        }</span>

        // Check entitlements
        <span class="cov0" title="0">if status.Entitlements == nil </span><span class="cov0" title="0">{
                return false, "No entitlements found", nil
        }</span>

        <span class="cov0" title="0">if !status.Entitlements.AiProcessing </span><span class="cov0" title="0">{
                return false, "AI processing not enabled", nil
        }</span>

        // Check credits if applicable
        <span class="cov0" title="0">if status.Entitlements.AiCreditsRemaining != nil </span><span class="cov0" title="0">{
                if *status.Entitlements.AiCreditsRemaining &lt;= 0 </span><span class="cov0" title="0">{
                        return false, "AI credits exhausted", nil
                }</span>
        }

        <span class="cov0" title="0">return true, "Pro subscription active", nil</span>
}

// IncrementUsage increments AI usage counters
func (s *SubscriptionService) IncrementUsage(ctx context.Context, uid string, tokensUsed int) error <span class="cov0" title="0">{
        // Update usage stats
        usagePath := fmt.Sprintf("users/%s/usageStats/ai", uid)

        updates := map[string]interface{}{
                "totalRequests":   firestore.Increment(1),
                "totalTokens":     firestore.Increment(tokensUsed),
                "lastRequestAt":   time.Now(),
                "monthlyRequests": firestore.Increment(1),
                "monthlyTokens":   firestore.Increment(tokensUsed),
        }

        err := s.repo.SetDocument(ctx, usagePath, updates)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to increment usage", zap.Error(err), zap.String("uid", uid))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ClearCache clears the subscription cache
func (s *SubscriptionService) ClearCache(uid string) <span class="cov8" title="1">{
        delete(s.cache, uid)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/repository"
)

// ThoughtProcessingService processes thoughts with AI
type ThoughtProcessingService struct {
        repo            *repository.FirestoreRepository
        openaiClient    *clients.OpenAIClient
        anthropicClient *clients.AnthropicClient
        contextGatherer *ContextGathererService
        subscriptionSvc *SubscriptionService
        actionProcessor *ActionProcessor
        logger          *zap.Logger
}

// NewThoughtProcessingService creates a new thought processing service
func NewThoughtProcessingService(
        repo *repository.FirestoreRepository,
        openaiClient *clients.OpenAIClient,
        anthropicClient *clients.AnthropicClient,
        contextGatherer *ContextGathererService,
        subscriptionSvc *SubscriptionService,
        actionProcessor *ActionProcessor,
        logger *zap.Logger,
) *ThoughtProcessingService <span class="cov0" title="0">{
        return &amp;ThoughtProcessingService{
                repo:            repo,
                openaiClient:    openaiClient,
                anthropicClient: anthropicClient,
                contextGatherer: contextGatherer,
                subscriptionSvc: subscriptionSvc,
                actionProcessor: actionProcessor,
                logger:          logger,
        }
}</span>

// ProcessThought processes a thought with AI
func (s *ThoughtProcessingService) ProcessThought(ctx context.Context, thoughtID string, thought map[string]interface{}, modelName string) error <span class="cov0" title="0">{
        uid := ctx.Value("uid").(string)
        isAnonymous := ctx.Value("isAnonymous").(bool)

        s.logger.Info("Processing thought",
                zap.String("uid", uid),
                zap.String("thoughtId", thoughtID),
                zap.String("model", modelName),
        )

        // 1. Check AI access
        allowed, reason, err := s.subscriptionSvc.IsAIAllowed(ctx, uid, isAnonymous)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check AI access: %w", err)
        }</span>
        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                return fmt.Errorf("AI access denied: %s", reason)
        }</span>

        // 2. Check if already processed
        <span class="cov0" title="0">if tags, ok := thought["tags"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, tag := range tags </span><span class="cov0" title="0">{
                        if tag == "processed" </span><span class="cov0" title="0">{
                                return fmt.Errorf("thought already processed")
                        }</span>
                }
        }

        // 3. Update thought status to processing
        <span class="cov0" title="0">thoughtPath := fmt.Sprintf("users/%s/thoughts/%s", uid, thoughtID)
        err = s.repo.UpdateDocument(ctx, thoughtPath, map[string]interface{}{
                "aiProcessingStatus": "processing",
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update thought status: %w", err)
        }</span>

        // 4. Gather user context
        <span class="cov0" title="0">userContext, err := s.contextGatherer.GatherContext(ctx, uid)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to gather context", zap.Error(err))
                userContext = &amp;models.UserContext{} // Continue with empty context
        }</span>

        // 5. Build prompt
        <span class="cov0" title="0">prompt := s.buildPrompt(thought, userContext)

        // 6. Call AI
        var response *clients.ChatCompletionResponse
        if modelName == "" || strings.Contains(modelName, "gpt") </span><span class="cov0" title="0">{
                // Use OpenAI
                response, err = s.openaiClient.ChatCompletion(ctx, clients.ChatCompletionRequest{
                        Model: modelName,
                        Messages: []clients.ChatMessage{
                                {Role: "system", Content: prompt},
                        },
                        ResponseFormat: &amp;clients.ResponseFormat{Type: "json_object"},
                })
        }</span> else<span class="cov0" title="0"> {
                // Use Anthropic
                response, err = s.anthropicClient.ChatCompletion(ctx, clients.ChatCompletionRequest{
                        Model: modelName,
                        Messages: []clients.ChatMessage{
                                {Role: "user", Content: prompt},
                        },
                })
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Mark as failed (ignore error since we're already in error path)
                _ = s.repo.UpdateDocument(ctx, thoughtPath, map[string]interface{}{
                        "aiProcessingStatus": "failed",
                        "aiProcessingError":  err.Error(),
                })
                return fmt.Errorf("AI request failed: %w", err)
        }</span>

        // 7. Parse AI response
        <span class="cov0" title="0">var aiResponse models.ThoughtProcessingResponse
        if parseErr := json.Unmarshal([]byte(response.Content), &amp;aiResponse); parseErr != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to parse AI response", zap.Error(parseErr), zap.String("content", response.Content))
                return fmt.Errorf("failed to parse AI response: %w", parseErr)
        }</span>

        // 8. Execute actions
        <span class="cov0" title="0">executedActions := 0
        for _, action := range aiResponse.Actions </span><span class="cov0" title="0">{
                // Only auto-execute high confidence actions
                if action.Confidence &gt;= 95 </span><span class="cov0" title="0">{
                        actionErr := s.actionProcessor.ExecuteAction(ctx, uid, thoughtID, action)
                        if actionErr != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to execute action",
                                        zap.Error(actionErr),
                                        zap.String("actionType", action.Type),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                executedActions++
                        }</span>
                }
        }

        // 9. Update thought with results
        <span class="cov0" title="0">tags := []interface{}{"processed"}
        if existingTags, ok := thought["tags"].([]interface{}); ok </span><span class="cov0" title="0">{
                tags = append(existingTags, "processed")
        }</span>

        <span class="cov0" title="0">updates := map[string]interface{}{
                "tags":               tags,
                "aiProcessingStatus": "completed",
                "processedAt":        time.Now(),
                "aiMetadata": map[string]interface{}{
                        "model":           response.Model,
                        "tokensUsed":      response.TokensUsed,
                        "actionsFound":    len(aiResponse.Actions),
                        "actionsExecuted": executedActions,
                        "processedAt":     time.Now(),
                },
        }

        err = s.repo.UpdateDocument(ctx, thoughtPath, updates)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update thought: %w", err)
        }</span>

        // 10. Increment usage stats (error not critical)
        <span class="cov0" title="0">_ = s.subscriptionSvc.IncrementUsage(ctx, uid, response.TokensUsed)

        s.logger.Info("Thought processing completed",
                zap.String("uid", uid),
                zap.String("thoughtId", thoughtID),
                zap.Int("tokensUsed", response.TokensUsed),
                zap.Int("actionsExecuted", executedActions),
        )

        return nil</span>
}

// buildPrompt builds the AI prompt for thought processing
func (s *ThoughtProcessingService) buildPrompt(thought map[string]interface{}, context *models.UserContext) string <span class="cov0" title="0">{
        // Extract thought text
        thoughtText := ""
        if text, ok := thought["text"].(string); ok </span><span class="cov0" title="0">{
                thoughtText = text
        }</span>

        <span class="cov0" title="0">thoughtType := "neutral"
        if t, ok := thought["type"].(string); ok </span><span class="cov0" title="0">{
                thoughtType = t
        }</span>

        <span class="cov0" title="0">tags := []string{}
        if t, ok := thought["tags"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, tag := range t </span><span class="cov0" title="0">{
                        if tagStr, ok := tag.(string); ok </span><span class="cov0" title="0">{
                                tags = append(tags, tagStr)
                        }</span>
                }
        }

        // Build context section
        <span class="cov0" title="0">contextSection := s.buildContextSection(context)

        // Build the prompt (matches the TypeScript version)
        prompt := fmt.Sprintf(`You are an intelligent thought processor for a productivity and mental wellness app.

Available Tools (connect thoughts to tools for processing):
- tasks: Thought contains actionable items that should become tasks
- projects: Relates to project planning or execution
- goals: Connects to personal or professional goals
- moodtracker: Expresses emotions or mental state that should be tracked
- cbt: Contains cognitive distortions or negative thinking patterns suitable for CBT analysis
- focus: Suitable for focused work sessions or deep work
- brainstorming: Contains ideas for exploration and ideation
- relationships: Mentions people or relationship dynamics
- notes: General reference or learning material to save
- errands: Contains to-do items for daily tasks

Available Actions:
- createRelationship: Connect this thought to a tool or entity
  * For tool connections: Use when thought should be processed by a specific tool
  * For entity connections: Use to link thought to tasks, projects, goals, moods, or people
- createTask: Create a new task from the thought
- enhanceTask: Enhance an existing task with information from this thought (provide taskId in data)
- createProject: Create a new project
- createGoal: Create a new goal
- createMood: Create a mood entry

%s

User Thought:
Text: "%s"
Type: %s
Current Tags: %s

Analyze this thought and suggest helpful actions. Consider:
1. **Tool Tags**: Which tools (tasks, projects, goals, mood, cbt, etc.) can benefit from this thought?
2. **Existing Data Context**: Review the user's current goals, projects, tasks, and moods to determine if this thought should:
   - Link to an existing project/goal (use createRelationship action)
   - Create a new project/goal (use createProject/createGoal action)
   - Enhance an existing task with new information (use enhanceTask with taskId)
   - Create a new task (use createTask)
   - Track mood/emotion (use createMood)
3. **Confidence Scoring**: For each action, provide a confidence score (0-100):
   - 99-100: Very high confidence, safe to auto-apply immediately
   - 70-98: Medium confidence, show as suggestion for user approval
   - 0-69: Low confidence, do not suggest

Respond ONLY with valid JSON (no markdown, no code blocks):
{
  "actions": [
    {
      "type": "createRelationship",
      "confidence": 95,
      "data": {
        "targetType": "tool",
        "targetId": "tasks",
        "relationshipType": "should-be-processed-by",
        "reasoning": "Thought contains actionable items that should become tasks"
      },
      "reasoning": "Thought contains clear actionable items"
    },
    {
      "type": "createTask",
      "confidence": 85,
      "data": {
        "title": "specific task title",
        "category": "mastery",
        "priority": "high"
      },
      "reasoning": "Clear actionable item identified"
    }
  ]
}

Rules:
- Only suggest actions that are truly helpful
- Don't create tasks for vague thoughts
- Use appropriate categories: health, wealth, mastery, connection
- Be conservative with task creation
- Consider existing user data when making decisions
- Confidence scores should be accurate and conservative
- Each relationship should have clear reasoning explaining why the connection is valuable`, contextSection, thoughtText, thoughtType, strings.Join(tags, ", "))

        return prompt</span>
}

// buildContextSection builds the user context section of the prompt
func (s *ThoughtProcessingService) buildContextSection(context *models.UserContext) string <span class="cov0" title="0">{
        var sections []string

        if len(context.Goals) &gt; 0 </span><span class="cov0" title="0">{
                goalsStr := fmt.Sprintf("\nGoals (%d):", len(context.Goals))
                for _, goal := range context.Goals </span><span class="cov0" title="0">{
                        title := getStringField(goal, "title")
                        status := getStringField(goal, "status")
                        objective := getStringField(goal, "objective")
                        goalsStr += fmt.Sprintf("\n- %s (%s) - %s", title, status, objective)
                }</span>
                <span class="cov0" title="0">sections = append(sections, goalsStr)</span>
        }

        <span class="cov0" title="0">if len(context.Projects) &gt; 0 </span><span class="cov0" title="0">{
                projectsStr := fmt.Sprintf("\nProjects (%d):", len(context.Projects))
                for _, project := range context.Projects </span><span class="cov0" title="0">{
                        title := getStringField(project, "title")
                        status := getStringField(project, "status")
                        description := getStringField(project, "description")
                        projectsStr += fmt.Sprintf("\n- %s (%s) - %s", title, status, description)
                }</span>
                <span class="cov0" title="0">sections = append(sections, projectsStr)</span>
        }

        <span class="cov0" title="0">if len(context.Tasks) &gt; 0 </span><span class="cov0" title="0">{
                tasksStr := fmt.Sprintf("\nActive Tasks (%d):", len(context.Tasks))
                for _, task := range context.Tasks </span><span class="cov0" title="0">{
                        title := getStringField(task, "title")
                        category := getStringField(task, "category")
                        priority := getStringField(task, "priority")
                        tasksStr += fmt.Sprintf("\n- %s (%s) - %s", title, category, priority)
                }</span>
                <span class="cov0" title="0">sections = append(sections, tasksStr)</span>
        }

        <span class="cov0" title="0">if len(context.Moods) &gt; 0 </span><span class="cov0" title="0">{
                moodsStr := fmt.Sprintf("\nRecent Moods (%d):", len(context.Moods))
                for _, mood := range context.Moods </span><span class="cov0" title="0">{
                        value := getIntField(mood, "value")
                        note := getStringField(mood, "note")
                        moodsStr += fmt.Sprintf("\n- %d/10 - %s", value, note)
                }</span>
                <span class="cov0" title="0">sections = append(sections, moodsStr)</span>
        }

        <span class="cov0" title="0">if len(sections) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return "User's Current Data Context:" + strings.Join(sections, "\n")</span>
}

// Helper functions to safely extract fields from maps
func getStringField(m map[string]interface{}, key string) string <span class="cov0" title="0">{
        if val, ok := m[key].(string); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getIntField(m map[string]interface{}, key string) int <span class="cov0" title="0">{
        if val, ok := m[key].(float64); ok </span><span class="cov0" title="0">{
                return int(val)
        }</span>
        <span class="cov0" title="0">if val, ok := m[key].(int); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"

        "go.uber.org/zap"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/clients"
        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
)

// TransactionCategorizationService handles AI-powered transaction categorization
type TransactionCategorizationService struct {
        openaiClient *clients.OpenAIClient
        logger       *zap.Logger
}

// NewTransactionCategorizationService creates a new categorization service
func NewTransactionCategorizationService(
        openaiClient *clients.OpenAIClient,
        logger *zap.Logger,
) *TransactionCategorizationService <span class="cov0" title="0">{
        return &amp;TransactionCategorizationService{
                openaiClient: openaiClient,
                logger:       logger,
        }
}</span>

// EnhanceTransactions enhances a batch of transactions with AI categorization
func (s *TransactionCategorizationService) EnhanceTransactions(
        ctx context.Context,
        transactions []models.CSVTransaction,
) (*models.EnhancementResult, error) <span class="cov0" title="0">{
        if len(transactions) == 0 </span><span class="cov0" title="0">{
                return &amp;models.EnhancementResult{
                        Transactions: []models.EnhancedTransaction{},
                        Summary: models.EnhancementSummary{
                                TotalProcessed:        0,
                                CategoriesUsed:        []string{},
                                SubscriptionsDetected: 0,
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">s.logger.Info("Enhancing transactions",
                zap.Int("count", len(transactions)),
        )

        // Build the prompt
        systemMessage := s.buildSystemPrompt()
        userMessage := s.buildUserPrompt(transactions)

        // Call OpenAI
        response, err := s.openaiClient.ChatCompletion(ctx, clients.ChatCompletionRequest{
                Model: "gpt-4o",
                Messages: []clients.ChatMessage{
                        {Role: "system", Content: systemMessage},
                        {Role: "user", Content: userMessage},
                },
                Temperature:    0.3,
                MaxTokens:      2000,
                ResponseFormat: &amp;clients.ResponseFormat{Type: "json_object"},
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to call OpenAI: %w", err)
        }</span>

        <span class="cov0" title="0">if response.Content == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no response from OpenAI")
        }</span>

        <span class="cov0" title="0">aiResponse := response.Content

        // Parse the response
        result, err := s.parseAIResponse(aiResponse, len(transactions))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to parse AI response",
                        zap.Error(err),
                        zap.String("response", aiResponse),
                )
                return nil, fmt.Errorf("failed to parse AI response: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Successfully enhanced transactions",
                zap.Int("total", result.Summary.TotalProcessed),
                zap.Int("categories", len(result.Summary.CategoriesUsed)),
                zap.Int("subscriptions", result.Summary.SubscriptionsDetected),
        )

        return result, nil</span>
}

// buildSystemPrompt creates the system prompt for transaction enhancement
func (s *TransactionCategorizationService) buildSystemPrompt() string <span class="cov0" title="0">{
        return `You are a financial transaction categorization assistant.

Your task is to analyze transaction descriptions and provide:
1. A clean merchant name
2. A specific category from the list below
3. Whether it's a recurring subscription
4. Any relevant notes

Categories (use these exactly):
- Groceries
- Restaurants &amp; Dining
- Transportation
- Shopping
- Entertainment
- Healthcare
- Bills &amp; Utilities
- Housing
- Insurance
- Travel
- Education
- Personal Care
- Gifts &amp; Donations
- Business Expenses
- Investments
- Transfers
- Fees &amp; Charges
- Other

Rules:
- Extract clean merchant names (e.g., "AMZN MKTP US"  "Amazon")
- Categorize accurately based on the description
- Mark subscriptions (Netflix, Spotify, gym memberships, etc.) as isSubscription: true
- Keep notes brief and relevant
- Return valid JSON matching this schema:
{
  "transactions": [
    {
      "originalDescription": "original description from input",
      "merchantName": "Clean Merchant Name",
      "category": "Category Name",
      "isSubscription": false,
      "notes": "Brief note if relevant"
    }
  ],
  "summary": {
    "totalProcessed": 0,
    "categoriesUsed": [],
    "subscriptionsDetected": 0
  }
}`
}</span>

// buildUserPrompt creates the user prompt with transaction data
func (s *TransactionCategorizationService) buildUserPrompt(transactions []models.CSVTransaction) string <span class="cov0" title="0">{
        transactionsJSON, _ := json.MarshalIndent(transactions, "", "  ")
        return fmt.Sprintf("Please categorize and enhance these transactions:\n\n%s", string(transactionsJSON))
}</span>

// parseAIResponse parses the AI response into structured data
func (s *TransactionCategorizationService) parseAIResponse(aiResponse string, expectedCount int) (*models.EnhancementResult, error) <span class="cov0" title="0">{
        // Try to extract JSON from the response
        jsonStr := extractJSON(aiResponse)

        var result models.EnhancementResult
        if err := json.Unmarshal([]byte(jsonStr), &amp;result); err != nil </span><span class="cov0" title="0">{
                // Try alternative parsing strategies
                result = s.tryAlternativeParsing(aiResponse, expectedCount)
        }</span>

        // Validate and fill in summary if missing
        <span class="cov0" title="0">if result.Summary.TotalProcessed == 0 </span><span class="cov0" title="0">{
                result.Summary = s.buildSummary(result.Transactions, expectedCount)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// tryAlternativeParsing attempts alternative parsing strategies
func (s *TransactionCategorizationService) tryAlternativeParsing(aiResponse string, expectedCount int) models.EnhancementResult <span class="cov0" title="0">{
        // Try parsing as array directly
        var transactions []models.EnhancedTransaction
        if err := json.Unmarshal([]byte(extractJSON(aiResponse)), &amp;transactions); err == nil </span><span class="cov0" title="0">{
                return models.EnhancementResult{
                        Transactions: transactions,
                        Summary:      s.buildSummary(transactions, expectedCount),
                }
        }</span>

        // Return empty result if all parsing fails
        <span class="cov0" title="0">s.logger.Warn("Failed to parse AI response, returning empty result")
        return models.EnhancementResult{
                Transactions: []models.EnhancedTransaction{},
                Summary: models.EnhancementSummary{
                        TotalProcessed:        0,
                        CategoriesUsed:        []string{},
                        SubscriptionsDetected: 0,
                },
        }</span>
}

// buildSummary builds a summary from enhanced transactions
func (s *TransactionCategorizationService) buildSummary(transactions []models.EnhancedTransaction, expectedCount int) models.EnhancementSummary <span class="cov0" title="0">{
        categoriesMap := make(map[string]bool)
        subscriptions := 0

        for _, tx := range transactions </span><span class="cov0" title="0">{
                if tx.Category != "" </span><span class="cov0" title="0">{
                        categoriesMap[tx.Category] = true
                }</span>
                <span class="cov0" title="0">if tx.IsSubscription </span><span class="cov0" title="0">{
                        subscriptions++
                }</span>
        }

        <span class="cov0" title="0">categories := make([]string, 0, len(categoriesMap))
        for category := range categoriesMap </span><span class="cov0" title="0">{
                categories = append(categories, category)
        }</span>

        <span class="cov0" title="0">totalProcessed := len(transactions)
        if totalProcessed == 0 &amp;&amp; expectedCount &gt; 0 </span><span class="cov0" title="0">{
                totalProcessed = expectedCount
        }</span>

        <span class="cov0" title="0">return models.EnhancementSummary{
                TotalProcessed:        totalProcessed,
                CategoriesUsed:        categories,
                SubscriptionsDetected: subscriptions,
        }</span>
}

// extractJSON extracts JSON from a string that may contain markdown or other formatting
func extractJSON(s string) string <span class="cov0" title="0">{
        // Try to find JSON in markdown code blocks
        re := regexp.MustCompile("```(?:json)?\\s*([\\s\\S]*?)```")
        matches := re.FindStringSubmatch(s)
        if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                return strings.TrimSpace(matches[1])
        }</span>

        // Try to find JSON by braces
        <span class="cov0" title="0">firstBrace := strings.Index(s, "{")
        lastBrace := strings.LastIndex(s, "}")
        if firstBrace != -1 &amp;&amp; lastBrace != -1 &amp;&amp; lastBrace &gt; firstBrace </span><span class="cov0" title="0">{
                return strings.TrimSpace(s[firstBrace : lastBrace+1])
        }</span>

        // Return trimmed string as-is
        <span class="cov0" title="0">return strings.TrimSpace(s)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package utils

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
)

// ParseCSVLine parses a single CSV line handling quoted fields properly (RFC 4180)
func ParseCSVLine(line string) []string <span class="cov8" title="1">{
        var result []string
        var current strings.Builder
        inQuotes := false

        for i := 0; i &lt; len(line); i++ </span><span class="cov8" title="1">{
                char := rune(line[i])

                // Look ahead for next character
                var nextChar rune
                if i+1 &lt; len(line) </span><span class="cov8" title="1">{
                        nextChar = rune(line[i+1])
                }</span>

                <span class="cov8" title="1">if char == '"' </span><span class="cov8" title="1">{
                        if inQuotes &amp;&amp; nextChar == '"' </span><span class="cov8" title="1">{
                                // Escaped quote within quoted field
                                current.WriteRune('"')
                                i++ // Skip next quote
                        }</span> else<span class="cov8" title="1"> {
                                // Toggle quote state
                                inQuotes = !inQuotes
                        }</span>
                } else<span class="cov8" title="1"> if char == ',' &amp;&amp; !inQuotes </span><span class="cov8" title="1">{
                        // Field separator outside quotes
                        result = append(result, strings.TrimSpace(current.String()))
                        current.Reset()
                }</span> else<span class="cov8" title="1"> {
                        current.WriteRune(char)
                }</span>
        }

        // Push the last field
        <span class="cov8" title="1">result = append(result, strings.TrimSpace(current.String()))

        return result</span>
}

// ParseCSV parses CSV content into transaction objects
// Handles quoted fields with commas (common in Amex statements)
func ParseCSV(csvContent string) ([]models.CSVTransaction, error) <span class="cov8" title="1">{
        lines := strings.Split(strings.TrimSpace(csvContent), "\n")

        if len(lines) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty CSV file")
        }</span>

        // Skip header row if it exists
        <span class="cov8" title="1">startIndex := 0
        if strings.Contains(strings.ToLower(lines[0]), "date") </span><span class="cov8" title="1">{
                startIndex = 1
        }</span>

        <span class="cov8" title="1">var transactions []models.CSVTransaction

        for i := startIndex; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                line := strings.TrimSpace(lines[i])
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Parse CSV line properly handling quoted fields
                <span class="cov8" title="1">values := ParseCSVLine(line)

                if len(values) &gt;= 3 </span><span class="cov8" title="1">{
                        // Parse amount - handle negative numbers, currency symbols, parentheses
                        amountStr := values[2]
                        amountStr = strings.ReplaceAll(amountStr, "$", "")
                        amountStr = strings.ReplaceAll(amountStr, ",", "")

                        amount := 0.0

                        // Handle parentheses notation for negative numbers (common in accounting)
                        if strings.Contains(amountStr, "(") &amp;&amp; strings.Contains(amountStr, ")") </span><span class="cov8" title="1">{
                                amountStr = strings.ReplaceAll(amountStr, "(", "")
                                amountStr = strings.ReplaceAll(amountStr, ")", "")
                                parsedAmount, err := strconv.ParseFloat(amountStr, 64)
                                if err == nil </span><span class="cov8" title="1">{
                                        amount = -parsedAmount
                                }</span>
                        } else<span class="cov8" title="1"> {
                                parsedAmount, err := strconv.ParseFloat(amountStr, 64)
                                if err == nil </span><span class="cov8" title="1">{
                                        amount = parsedAmount
                                }</span>
                        }

                        <span class="cov8" title="1">transactions = append(transactions, models.CSVTransaction{
                                Date:        values[0],
                                Description: values[1],
                                Amount:      amount,
                        })</span>
                }
        }

        <span class="cov8" title="1">if len(transactions) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no valid transactions found in CSV")
        }</span>

        <span class="cov8" title="1">return transactions, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package utils

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/config"
)

// NewLogger creates a new zap logger based on configuration
func NewLogger(cfg *config.LoggingConfig) (*zap.Logger, error) <span class="cov8" title="1">{
        var zapConfig zap.Config

        if cfg.Development || cfg.Format == "console" </span><span class="cov8" title="1">{
                zapConfig = zap.NewDevelopmentConfig()
                zapConfig.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
        }</span> else<span class="cov8" title="1"> {
                zapConfig = zap.NewProductionConfig()
        }</span>

        // Set log level
        <span class="cov8" title="1">var level zapcore.Level
        if err := level.UnmarshalText([]byte(cfg.Level)); err != nil </span><span class="cov8" title="1">{
                level = zapcore.InfoLevel
        }</span>
        <span class="cov8" title="1">zapConfig.Level = zap.NewAtomicLevelAt(level)

        // Set output paths
        if cfg.Output != "" &amp;&amp; cfg.Output != "stdout" </span><span class="cov8" title="1">{
                zapConfig.OutputPaths = []string{cfg.Output}
        }</span>

        // Enable/disable stacktrace
        <span class="cov8" title="1">if !cfg.EnableStacktrace </span><span class="cov8" title="1">{
                zapConfig.DisableStacktrace = true
        }</span>

        <span class="cov8" title="1">return zapConfig.Build()</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package utils

import (
        "encoding/json"
        "net/http"

        "github.com/mesbahtanvir/focus-notebook/backend/internal/models"
)

// RespondJSON sends a JSON response
func RespondJSON(w http.ResponseWriter, data interface{}, statusCode int) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        if data != nil </span><span class="cov8" title="1">{
                if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                        // If encoding fails, log but don't try to send another response
                        http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                }</span>
        }
}

// WriteJSON is an alias for RespondJSON
func WriteJSON(w http.ResponseWriter, data interface{}, statusCode int) <span class="cov8" title="1">{
        RespondJSON(w, data, statusCode)
}</span>

// RespondError sends an error response
func RespondError(w http.ResponseWriter, message string, statusCode int) <span class="cov8" title="1">{
        RespondJSON(w, models.ErrorResponse{
                Error: message,
        }, statusCode)
}</span>

// WriteError is an alias for RespondError
func WriteError(w http.ResponseWriter, message string, statusCode int) <span class="cov8" title="1">{
        RespondError(w, message, statusCode)
}</span>

// RespondSuccess sends a success response
func RespondSuccess(w http.ResponseWriter, data interface{}, message string) <span class="cov8" title="1">{
        RespondJSON(w, models.SuccessResponse{
                Success: true,
                Data:    data,
                Message: message,
        }, http.StatusOK)
}</span>

// ParseJSON parses JSON request body
func ParseJSON(r *http.Request, v interface{}) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ _ = r.Body.Close() }</span>()
        <span class="cov8" title="1">return json.NewDecoder(r.Body).Decode(v)</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package firebase

import (
        "context"
        "fmt"

        "cloud.google.com/go/firestore"
        firebase "firebase.google.com/go/v4"
        "firebase.google.com/go/v4/auth"
        "firebase.google.com/go/v4/storage"
        "google.golang.org/api/option"
)

// Admin wraps Firebase Admin SDK clients
type Admin struct {
        App       *firebase.App
        Auth      *auth.Client
        Firestore *firestore.Client
        Storage   *storage.Client
}

// Config holds Firebase initialization configuration
type Config struct {
        ProjectID       string
        CredentialsPath string
        StorageBucket   string
        DatabaseID      string
}

// Initialize creates and initializes Firebase Admin SDK clients
func Initialize(ctx context.Context, cfg *Config) (*Admin, error) <span class="cov8" title="1">{
        // Validate config
        if cfg.ProjectID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("project_id is required")
        }</span>
        <span class="cov8" title="1">if cfg.CredentialsPath == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("credentials_path is required")
        }</span>

        // Initialize Firebase App
        <span class="cov8" title="1">conf := &amp;firebase.Config{
                ProjectID:     cfg.ProjectID,
                StorageBucket: cfg.StorageBucket,
        }

        opt := option.WithCredentialsFile(cfg.CredentialsPath)
        app, err := firebase.NewApp(ctx, conf, opt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize Firebase app: %w", err)
        }</span>

        // Initialize Auth client
        <span class="cov8" title="1">authClient, err := app.Auth(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to initialize Auth client: %w", err)
        }</span>

        // Initialize Firestore client
        <span class="cov0" title="0">firestoreClient, err := app.Firestore(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize Firestore client: %w", err)
        }</span>

        // Initialize Storage client
        <span class="cov0" title="0">storageClient, err := app.Storage(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize Storage client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Admin{
                App:       app,
                Auth:      authClient,
                Firestore: firestoreClient,
                Storage:   storageClient,
        }, nil</span>
}

// Close closes all Firebase clients
func (a *Admin) Close() error <span class="cov8" title="1">{
        if a.Firestore != nil </span><span class="cov0" title="0">{
                if err := a.Firestore.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close Firestore client: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// HealthCheck verifies Firebase connectivity
func (a *Admin) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Try to access Firestore
        _, err := a.Firestore.Collection("_health").Doc("_check").Get(ctx)
        if err != nil &amp;&amp; !isNotFoundError(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("firestore health check failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func isNotFoundError(err error) bool <span class="cov8" title="1">{
        // Check if error is "not found" (which is acceptable for health check)
        return err != nil &amp;&amp; (err.Error() == "not found" || err.Error() == "rpc error: code = NotFound")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
